class Strategy(StrategyBase):
    """第一层：免费基础定投策略
    
    专为解决Moomoo用户定投痛点设计的开源策略
    - 简化配置，一键启用
    - 3层回撤加仓保护
    - 完善的风险控制
    - 支持回测和实盘
    """

    def initialize(self):
        """初始化策略"""
        try:
            self._version = "v2.1.0-Tiered"
            self._tier = "免费基础版"
            self._description = (
                "🆓 免费基础定投策略 - 解决Moomoo定投痛点\n"
                "✅ 固定周期智能定投\n" 
                "✅ 3层回撤加仓保护 (5%/10%/20%)\n"
                "✅ 完善风险控制系统\n"
                "✅ 预设参数模板，一键启用\n"
                "💡 升级付费版可获得8层回撤+成本定投算法"
            )
            
            self.trigger_symbols()
            self.custom_indicator()
            self.global_variables()
            self.setup_presets()
            self.print_welcome()
            
            # 核心状态变量
            self.current_drawdown_layer = -1  # -1表示还没有触发任何层级
            self.last_investment_time = None
            self.highest_price = None
            self.last_valid_price = 100.0  # 默认价格
            self.strategy_start_price = None  # 策略启动价格
            self.drawdown_reset_threshold = 0.05  # 价格上涨5%重置回撤层级
            
            # 回测支持
            import collections
            self.high_queue = collections.deque(maxlen=20)
            # 获取用户设置的本金，如果没有设置则使用默认值
            if self.backtest:
                self.initial_balance = total_cash(currency=Currency.USD)
                self.virtual_balance = self.initial_balance
            else:
                self.virtual_balance = None
            self._position = 0
            self._total_cost = 0.0
            
        except Exception as e:
            print(f"❌ 初始化失败: {str(e)}")

    def trigger_symbols(self):
        """设置交易标的"""
        try:
            self.stock = declare_trig_symbol()
            print(f"📈 交易标的: {self.stock}")
        except Exception as e:
            print(f"❌ 标的设置失败: {str(e)}")

    def custom_indicator(self):
        """注册自定义技术指标"""
        try:
            # 注册一个简单的移动平均线指标供参考
            self.register_indicator(
                indicator_name='MA',
                script='MA5:MA(CLOSE,5),COLORFF8D1E;',
                param_list=[]
            )
            print("📊 技术指标注册完成")
        except Exception as e:
            print(f"❌ 技术指标注册失败: {str(e)}")

    def global_variables(self):
        """全局变量设置 - 分层版"""
        try:
            # 版本层级选择 (核心功能)
            self.version_tier = show_variable(1, GlobalType.INT)  # 1=免费版 2=付费版(¥35/月)
            
            # 预设模板选择
            self.preset_mode = show_variable(2, GlobalType.INT)  # 1=保守 2=平衡 3=积极
            
            # 基础参数（在预设基础上可微调）
            self.qty = show_variable(20, GlobalType.INT)  # 每次定投股数
            self.interval_min = show_variable(1440, GlobalType.INT)  # 定投周期（分钟）
            
            # 功能开关
            self.backtest = show_variable(True, GlobalType.BOOL)  # 回测模式
            self.basic_invest_only = show_variable(False, GlobalType.BOOL)  # 仅定投模式
            
            # 免费版固定参数（不可配置）
            self.drawdown_layers = [5.0, 10.0, 20.0]  # 3层回撤阈值
            self.drawdown_multipliers = [1.5, 2.0, 3.0]  # 对应加仓倍数
            self.extreme_drawdown_pct = 50.0  # 极端回撤保护
            self.log_level = 0  # 简化日志
            
            print(f"⚙️ 参数配置完成")
            
        except Exception as e:
            print(f"❌ 参数设置失败: {str(e)}")

    def setup_presets(self):
        """设置预设模板"""
        presets = {
            1: {  # 保守型
                "name": "保守型",
                "description": "低风险，适合稳健投资者",
                "base_qty": 10,
                "interval": 10080,  # 1周
                "risk_level": "低"
            },
            2: {  # 平衡型  
                "name": "平衡型",
                "description": "中等风险收益，适合大多数用户", 
                "base_qty": 20,
                "interval": 1440,  # 1天
                "risk_level": "中"
            },
            3: {  # 积极型
                "name": "积极型", 
                "description": "高频交易，适合风险承受能力强的用户",
                "base_qty": 50,
                "interval": 60,  # 1小时
                "risk_level": "高"
            }
        }
        
        if self.preset_mode in presets:
            preset = presets[self.preset_mode]
            self.preset_name = preset["name"]
            self.preset_desc = preset["description"] 
            self.risk_level = preset["risk_level"]
            
            # 应用预设（如果用户未修改默认值）
            if self.qty == 20:  # 默认值，应用预设
                self.qty = preset["base_qty"]
            if self.interval_min == 1440:  # 默认值，应用预设  
                self.interval_min = preset["interval"]
        else:
            self.preset_name = "自定义"
            self.preset_desc = "用户自定义参数"
            self.risk_level = "未知"

    def print_welcome(self):
        """打印欢迎信息 - 分层版"""
        version_info = {
            1: {"name": "免费基础版", "features": "固定定投+风险提醒", "color": "🆓"},
            2: {"name": "付费进阶版(¥35/月)", "features": "3层智能加仓系统", "color": "💎"}
        }
        
        current_version = version_info.get(self.version_tier, version_info[1])
        
        print("\n" + "="*60)
        print(f"🚀 DCA智能定投策略 {self._version}")
        print("="*60)
        print(f"{current_version['color']} 当前版本: {current_version['name']}")
        print(f"✨ 核心功能: {current_version['features']}")
        
        if self.version_tier == 1:
            print("\n🆓 免费版功能:")
            print("   ✅ 固定周期智能定投")
            print("   ✅ 基础回撤监控提醒")
            print("   ✅ 风险保护系统")
            print("   ✅ 投资记录统计")
        elif self.version_tier == 2:
            print("\n💎 付费版功能 (¥35/月):")
            print("   ✅ 包含免费版所有功能")
            print("   ✅ 3层智能加仓 (5%/10%/20%)")
            print("   ✅ 动态倍数调整 (1.5x/2x/3x)")
            print("   ✅ 个性化参数配置")
            print("   ✅ 极端回撤保护")
            
        print("\n📊 当前配置:")
        print(f"   版本等级: {self.version_tier} ({'免费版' if self.version_tier == 1 else '付费版'})")
        print(f"   投资模板: {self.preset_name} ({self.preset_desc})")
        print(f"   风险等级: {self.risk_level}")
        print(f"   定投数量: {self.qty}股")
        print(f"   定投周期: {self.interval_min}分钟 ({self._get_interval_desc()})")
        print(f"   回撤阈值: {self.drawdown_layers}")
        print(f"   运行模式: {'回测' if self.backtest else '实盘'}")
        
        if self.version_tier == 1:
            print("\n🎯 升级提示:")
            print("   💡 付费版支持智能3层加仓，回撤时自动增加投资")
            print("   💡 联系作者升级至付费版(¥35/月)解锁完整功能")
        
        print("="*60 + "\n")

    def _get_interval_desc(self):
        """获取周期描述"""
        if self.interval_min == 60:
            return "1小时"
        elif self.interval_min == 1440:
            return "1天"
        elif self.interval_min == 10080:
            return "1周"
        else:
            return f"{self.interval_min}分钟"

    def handle_data(self):
        """主要交易逻辑 - 分层架构"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            latest_price, highest_price, account_balance = self.get_market_data()
            
            # 计算回撤和持仓信息
            drawdown = self.calculate_drawdown(latest_price)
            position = self.get_position()
            
            if self.log_level >= 1:
                print(f"📊 价格={latest_price:.2f}, 回撤={drawdown:.2f}%, 持仓={position}, 最高价={self.highest_price:.2f}")

            # 分层功能路由
            if self.version_tier == 1:
                # 免费版逻辑
                self.free_version_logic(current_time, latest_price, account_balance, drawdown)
            elif self.version_tier == 2:
                # 付费版逻辑 
                self.advanced_version_logic(current_time, latest_price, account_balance, drawdown)
            else:
                # 默认免费版
                print("⚠️ 版本参数错误，使用免费版功能")
                self.free_version_logic(current_time, latest_price, account_balance, drawdown)

        except Exception as e:
            import traceback
            error_msg = str(e) if str(e) else "未知错误"
            print(f"❌ 策略执行错误: {error_msg}")
            print(f"错误详情: {traceback.format_exc()}")

    def get_market_data(self):
        """获取市场数据"""
        if self.backtest:
            # 回测模式
            try:
                if not hasattr(self, 'bar_index'):
                    self.bar_index = 0
                self.bar_index += 1
                
                latest_price = bar_close(self.stock, bar_type=BarType.D1, select=1)
                if latest_price is None or latest_price <= 0:
                    print(f"⚠️ 获取价格失败，使用默认价格")
                    latest_price = 100.0  # 默认价格
                
                # 记录有效价格供后续使用
                if latest_price > 0:
                    self.last_valid_price = latest_price
                
                self.high_queue.append(latest_price)
                
                # 使用条件判断替代min()函数
                available_days = self.bar_index if self.bar_index < 20 else 20
                high_list = list(self.high_queue)[-available_days:]
                if len(high_list) == 0:
                    highest_price = latest_price
                elif len(high_list) == 1:
                    highest_price = high_list[0]
                else:
                    # 使用Moomoo支持的max()函数格式，传入具体数值
                    highest_price = high_list[0]
                    for price in high_list[1:]:
                        if price > highest_price:
                            highest_price = price
                
                account_balance = self.virtual_balance
                return latest_price, highest_price, account_balance
            except Exception as e:
                print(f"回测数据获取错误: {str(e)}")
                # 返回默认值避免策略崩溃
                return 100.0, 100.0, self.virtual_balance
        else:
            # 实盘模式
            latest_price = current_price(self.stock, price_type=THType.FTH)
            if latest_price is None or latest_price <= 0:
                latest_price = self.last_valid_price
            else:
                self.last_valid_price = latest_price
            
            high_list = [bar_high(self.stock, bar_type=BarType.D1, select=i) for i in range(1, 21)]
            # 处理可能的None值并找出最大值
            valid_highs = [h for h in high_list if h is not None and h > 0]
            if len(valid_highs) == 0:
                highest_price = latest_price
            elif len(valid_highs) == 1:
                highest_price = valid_highs[0]
            else:
                highest_price = valid_highs[0]
                for price in valid_highs[1:]:
                    if price > highest_price:
                        highest_price = price
            
            account_balance = total_cash(currency=Currency.USD)
            return latest_price, highest_price, account_balance

    def calculate_drawdown(self, latest_price):
        """计算回撤幅度 - 修复版"""
        # 初始化策略启动价格和最高价
        if self.strategy_start_price is None:
            self.strategy_start_price = latest_price
            self.highest_price = latest_price
            return 0.0
            
        # 更新最高价（只能上升，不能下降）
        if latest_price > self.highest_price:
            self.highest_price = latest_price
            # 价格创新高时，重置回撤层级（可选）
            if (latest_price - self.highest_price) / self.highest_price > self.drawdown_reset_threshold:
                self.current_drawdown_layer = -1  # 重置为未触发状态
        
        # 计算当前回撤
        if self.highest_price > 0:
            drawdown = (self.highest_price - latest_price) / self.highest_price * 100
        else:
            drawdown = 0.0
            
        return drawdown

    def calculate_add_position_qty(self, drawdown):
        """计算加仓数量 - 免费版3层"""
        for i, threshold in enumerate(self.drawdown_layers):
            if drawdown >= threshold:
                # 检查是否已经在这个层级或更高层级加过仓
                if i <= self.current_drawdown_layer:
                    continue
                    
                # 触发新的加仓层级
                self.current_drawdown_layer = i
                add_qty = int(self.qty * self.drawdown_multipliers[i])
                
                print(f"🎯 回撤加仓触发: 第{i+1}层 ({threshold}%), 倍数={self.drawdown_multipliers[i]}x, 数量={add_qty}股")
                return add_qty
        
        return 0

    def should_invest(self, current_time):
        """判断是否应该定投"""
        if self.last_investment_time is None:
            return True
        elapsed = (current_time - self.last_investment_time).total_seconds() / 60
        return elapsed >= self.interval_min

    def free_version_logic(self, current_time, latest_price, account_balance, drawdown):
        """免费版策略逻辑 - 基础定投 + 风险提醒"""
        
        # 风险提醒功能
        if drawdown >= 20.0:
            print(f"⚠️ 免费版风险提醒: 当前回撤{drawdown:.1f}%，建议关注市场变化")
        elif drawdown >= 10.0:
            print(f"📢 回撤监控: 当前回撤{drawdown:.1f}%")
            
        # 纯定投模式或基础回撤保护
        if self.basic_invest_only:
            if self.should_invest(current_time):
                self.execute_investment(latest_price, account_balance, self.qty, "基础定投")
        else:
            # 仅常规定投，不加仓
            if self.should_invest(current_time):
                self.execute_investment(latest_price, account_balance, self.qty, "定期定投")

    def advanced_version_logic(self, current_time, latest_price, account_balance, drawdown):
        """付费版策略逻辑 (¥35/月) - 智能3层加仓系统"""
        
        # 检查版本授权（实际使用时可连接服务器验证）
        if self.version_tier != 2:
            print("💡 3层智能加仓功能需要升级到付费版(¥35/月)，请联系作者")
            print("📱 当前使用免费版功能...")
            return self.free_version_logic(current_time, latest_price, account_balance, drawdown)
        
        # 极端回撤保护
        if drawdown >= self.extreme_drawdown_pct:
            print(f"🚨 极端回撤保护: {drawdown:.1f}% >= {self.extreme_drawdown_pct}%，仅定投模式")
            if self.should_invest(current_time):
                self.execute_investment(latest_price, account_balance, self.qty, "极端回撤保护")
            return

        # 智能3层加仓系统
        add_qty = self.calculate_add_position_qty(drawdown)
        if add_qty > 0:
            self.execute_investment(latest_price, account_balance, add_qty, f"付费版-第{self.current_drawdown_layer+1}层加仓")
            return

        # 常规定投
        if self.should_invest(current_time):
            self.execute_investment(latest_price, account_balance, self.qty, "付费版-定期定投")

    def execute_investment(self, latest_price, account_balance, quantity, trade_type="定投"):
        """执行投资"""
        # 参数合法性检查 - 付费版支持更灵活的数量
        if self.version_tier == 2:
            # 付费版：支持任意数量，仅检查基本范围
            if quantity < 1 or quantity > 1000:
                print(f"⚠️ 付费版参数修正: 投资数量 {quantity} -> 20股")
                quantity = 20
        else:
            # 免费版：必须是10的倍数
            if quantity < 10 or quantity > 1000 or quantity % 10 != 0:
                print(f"⚠️ 免费版参数修正: 投资数量 {quantity} -> 20股")
                quantity = 20

        if self.backtest:
            # 回测模式 - 使用place_market产生GUI交易打点
            required_cash = quantity * latest_price
            if required_cash > self.virtual_balance:
                # 资金不足，自动调整投资数量
                original_qty = quantity
                max_qty = int(self.virtual_balance // latest_price)
                if max_qty < 1:
                    print(f"💰 虚拟余额不足，无法购买任何股票: 需要${required_cash:.2f}, 可用${self.virtual_balance:.2f}")
                    return
                quantity = max_qty
                required_cash = quantity * latest_price
                print(f"⚠️ 资金调整: 原计划买{original_qty}股，调整为{quantity}股 (可用资金${self.virtual_balance:.2f})")
            
            if quantity < 1:
                print(f"💰 调整后数量不足1股，跳过本次投资")
                return

            # 调用place_market模拟下单，产生GUI交易打点
            order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
            
            # 精简日志输出，仅保留关键信息
            print(f"📊 {trade_type}: {quantity}股 @ ${latest_price:.2f} | 订单:{order_id}")
            
            # 更新虚拟账户
            self.virtual_balance -= required_cash
            self._total_cost += required_cash
            self._position += quantity
            
            print(f"💰 余额: ${self.virtual_balance:.2f} | 持仓: {self._position}股")
            
        else:
            # 实盘模式
            required_cash = quantity * latest_price
            if required_cash > account_balance:
                # 资金不足，按可用资金调整数量
                max_qty = int((account_balance // latest_price) // 10 * 10)
                if max_qty < 10:
                    print(f"💰 资金不足，无法投资")
                    return
                quantity = max_qty
                print(f"⚠️ 资金调整: 投资数量调整为 {quantity}股")

            try:
                # 使用市价买入确保成交
                order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
                print(f"✅ {trade_type}订单: {quantity}股 @ 市价, 订单号: {order_id}")
            except Exception as e:
                print(f"❌ 下单失败: {str(e)}")
                return

        self.last_investment_time = device_time(TimeZone.DEVICE_TIME_ZONE)

    def get_position(self):
        """获取持仓数量"""
        if self.backtest:
            return self._position
        try:
            return position_holding_qty(self.stock)
        except:
            return 0

    def get_total_cost(self):
        """获取总成本"""
        if self.backtest:
            return self._total_cost
        try:
            pos = position_holding_qty(self.stock)
            avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
            return pos * avg_cost
        except:
            return 0.0

    def get_avg_cost(self):
        """获取平均成本"""
        if self.backtest:
            return self._total_cost / self._position if self._position > 0 else 0.0
        try:
            return position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
        except:
            return 0.0