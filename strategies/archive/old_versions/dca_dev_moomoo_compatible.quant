class Strategy(StrategyBase):
    """混合开发版DCA定投策略 - v2.2.5-EnhancedParams
    
    包含免费版和付费版完整功能的开发调试版本
    - 通过version_tier参数控制功能层级
    - 免费版功能：每周定投 + 基础风险提醒
    - 付费版功能：每日定投 + 3层智能加仓
    - 用于开发调试、功能测试和性能验证
    - 分发时需生成对应的稳定版本
    
    [v2.2.5 参数优化]
    - 修复basic_invest_only布尔值类型处理问题
    - 增强参数类型验证和自动转换功能
    - 完善GUI参数验证：积极型预设、付费版每日定投正常
    - 优化调试信息显示，增加参数类型检查
    
    [v2.2.4 重大修复]  
    - 修复初始化顺序问题：先设置参数，再应用分层功能，最后应用预设
    - 添加详细的初始化阶段日志，便于调试追踪
    - 增强参数验证和debugging功能，识别qty=1等异常参数值
    - 重构setup_presets调用时机，避免interval_min未定义错误
    - 添加show_variable异常处理和fallback机制
    """

    def initialize(self):
        """初始化策略"""
        try:
            self._version = "v2.2.5-EnhancedParams"
            self._tier = "混合开发版"
            self._description = (
                "🔧 混合开发版DCA策略 - 开发调试专用\n"
                "✅ 包含免费版+付费版完整功能\n" 
                "✅ 通过version_tier参数控制功能层级\n"
                "✅ 用于功能开发、测试和bug修复\n"
                "✅ 支持分层功能验证和性能对比\n"
                "⚠️ 仅供开发使用，分发请用对应稳定版"
            )
            
            print("🚀 开始初始化 {0}".format(self._version))
            
            # 首先设置核心状态变量
            self.current_drawdown_layer = -1  # -1表示还没有触发任何层级
            self.last_investment_time = None
            self.highest_price = None
            self.last_valid_price = 100.0  # 默认价格
            self.strategy_start_price = None  # 策略启动价格
            self.drawdown_reset_threshold = 0.05  # 价格上涨5%重置回撤层级
            
            # 回测支持变量初始化
            import collections
            self.high_queue = collections.deque(maxlen=20)
            self._position = 0
            self._total_cost = 0.0
            self.virtual_balance = None  # 先初始化为None
            
            # 第一阶段：基础组件初始化
            print("📝 第一阶段: 基础组件初始化")
            self.trigger_symbols()
            self.custom_indicator()
            
            # 第二阶段：用户参数设置
            print("📝 第二阶段: 用户参数设置")
            self.global_variables()
            
            # 第三阶段：分层功能设置（必须在全局变量设置之后）
            print("📝 第三阶段: 分层功能设置")
            try:
                self.setup_tier_features()
                print("✅ 分层功能设置成功")
            except Exception as e:
                print("❌ setup_tier_features 失败: {0}".format(str(e)))
                import traceback
                print("详细错误: {0}".format(traceback.format_exc()))
                # 手动设置关键属性
                self.interval_min = 10080 if getattr(self, 'version_tier', 1) == 1 else 1440
                self.interval_desc = "手动设置周期 ({0}分钟)".format(self.interval_min)
                if not hasattr(self, 'virtual_balance') or self.virtual_balance is None:
                    self.virtual_balance = 10000.0
                    self.initial_balance = 10000.0
                print("🔧 手动设置: interval_min={0}, virtual_balance=${1}".format(self.interval_min, self.virtual_balance))
            
            # 第四阶段：预设配置应用（在分层功能设置之后）
            print("📝 第四阶段: 预设配置应用")
            self.setup_presets()
            
            # 第五阶段：最终验证和兜底设置
            print("📝 第五阶段: 最终验证和兜底设置")
            # 确保关键属性已设置
            if not hasattr(self, 'interval_min') or self.interval_min is None:
                self.interval_min = 10080 if getattr(self, 'version_tier', 1) == 1 else 1440
                print("⚠️ 最终检查: interval_min缺失，设置默认值{0}分钟".format(self.interval_min))
            
            # 最后确保虚拟余额已正确设置
            if self.backtest:
                if not hasattr(self, 'initial_balance') or self.initial_balance is None:
                    try:
                        self.initial_balance = total_cash(currency=Currency.USD)
                        if self.initial_balance is None or self.initial_balance <= 0:
                            self.initial_balance = 10000.0
                    except:
                        self.initial_balance = 10000.0
                        print("⚠️ 初始化：无法获取账户余额，使用默认$10,000")
                        
                if not hasattr(self, 'virtual_balance') or self.virtual_balance is None:
                    self.virtual_balance = self.initial_balance
                    
            print("✅ 初始化完成：虚拟余额=${0:,.0f}".format(getattr(self, 'virtual_balance', 0)))
            
            # 详细的初始化状态日志
            self.print_initialization_status()
            self.print_welcome()
            
        except Exception as e:
            print("❌ 初始化失败: {0}".format(str(e)))
            import traceback
            print("详细错误: {0}".format(traceback.format_exc()))

    def trigger_symbols(self):
        """设置交易标的"""
        try:
            self.stock = declare_trig_symbol()
            print("📈 交易标的: {0}".format(self.stock))
        except Exception as e:
            print("❌ 标的设置失败: {0}".format(str(e)))

    def custom_indicator(self):
        """注册自定义技术指标"""
        try:
            # 注册一个简单的移动平均线指标供参考
            self.register_indicator(
                indicator_name='MA',
                script='MA5:MA(CLOSE,5),COLORFF8D1E;',
                param_list=[]
            )
            print("📊 技术指标注册完成")
        except Exception as e:
            print("❌ 技术指标注册失败: {0}".format(str(e)))

    def global_variables(self):
        """全局变量设置 - 分层版"""
        try:
            # === 免费版基础参数 (用户主要配置) ===
            self.qty = show_variable(20, GlobalType.INT)  # 每次定投股数
            self.preset_mode = show_variable(2, GlobalType.INT)  # 1=保守 2=平衡 3=积极
            self.backtest = show_variable(True, GlobalType.BOOL)  # 回测模式
            self.basic_invest_only = show_variable(False, GlobalType.BOOL)  # 仅定投模式
            
            # === 付费版专属功能 (¥35/月) ===
            print("\n💡 以下为付费版(¥35/月)专属功能，免费版用户修改无效:")
            self.version_tier = show_variable(1, GlobalType.INT)  # 1=免费版 2=付费版(¥35/月)
            self.balance_mode = show_variable(1, GlobalType.INT)  # 1=系统默认 2=自定义(付费版)
            self.custom_balance = show_variable(50000, GlobalType.INT)  # 付费版可自定义资金
            self.interval_mode = show_variable(1, GlobalType.INT)  # 1=自动(版本决定) 2=每日(付费版) 3=每周 4=自定义(付费版)
            self.custom_interval_min = show_variable(1440, GlobalType.INT)  # 自定义周期(付费版)
            
            # 免费版固定参数（不可配置）
            self.drawdown_layers = [5.0, 10.0, 20.0]  # 3层回撤阈值
            self.drawdown_multipliers = [1.5, 2.0, 3.0]  # 对应加仓倍数
            self.extreme_drawdown_pct = 50.0  # 极端回撤保护
            self.log_level = 0  # 简化日志
            
            # 注意：不能重新赋值show_variable()声明的变量
            # 如果需要类型转换，应该在后续处理中使用bool(self.basic_invest_only)
            if isinstance(getattr(self, 'basic_invest_only', False), int):
                print("🔧 检测到basic_invest_only类型: int，后续将自动转换为bool")
            
            # 验证关键参数是否正确设置
            print("🔍 验证关键参数:")
            print("   qty: {0} (期望: 20)".format(getattr(self, 'qty', 'MISSING')))
            print("   version_tier: {0} (期望: 1或2)".format(getattr(self, 'version_tier', 'MISSING')))
            print("   preset_mode: {0} (期望: 2)".format(getattr(self, 'preset_mode', 'MISSING')))
            print("   basic_invest_only: {0} (类型: {1})".format(getattr(self, 'basic_invest_only', 'MISSING'), type(getattr(self, 'basic_invest_only', None))))
            
            print("⚙️ 参数配置完成")
            print("🔍 打印全局变量参数值 (调试用):")
            self.print_global_variables()
            
        except Exception as e:
            print("❌ 参数设置失败: {0}".format(str(e)))
            import traceback
            print("详细错误: {0}".format(traceback.format_exc()))

    def print_global_variables(self):
        """打印所有全局变量参数 - 用于调试"""
        print("=" * 50)
        try:
            print("📦 qty (定投股数): {0} [期望: 20]".format(getattr(self, 'qty', 'MISSING!')))
            print("🎛️ version_tier (版本层级): {0} [期望: 1或2]".format(getattr(self, 'version_tier', 'MISSING!')))
            print("💵 balance_mode (资金模式): {0} [期望: 1]".format(getattr(self, 'balance_mode', 'MISSING!')))  
            print("💰 custom_balance (自定义资金): {0} [期望: 50000]".format(getattr(self, 'custom_balance', 'MISSING!')))
            print("⏰ interval_mode (间隔模式): {0} [期望: 1]".format(getattr(self, 'interval_mode', 'MISSING!')))
            print("⏱️ custom_interval_min (自定义间隔): {0} [期望: 1440]".format(getattr(self, 'custom_interval_min', 'MISSING!')))
            print("🎨 preset_mode (预设模式): {0} [期望: 2]".format(getattr(self, 'preset_mode', 'MISSING!')))
            print("🔧 backtest (回测模式): {0} [期望: True]".format(getattr(self, 'backtest', 'MISSING!')))
            print("💡 basic_invest_only (仅定投): {0} [期望: False, 类型: {1}]".format(getattr(self, 'basic_invest_only', 'MISSING!'), type(getattr(self, 'basic_invest_only', None))))
            
            print("\n🔧 固定参数:")
            print("📊 drawdown_layers: {0}".format(getattr(self, 'drawdown_layers', 'MISSING!')))
            print("📈 drawdown_multipliers: {0}".format(getattr(self, 'drawdown_multipliers', 'MISSING!')))
            print("⚠️ extreme_drawdown_pct: {0}".format(getattr(self, 'extreme_drawdown_pct', 'MISSING!')))
            print("📝 log_level: {0}".format(getattr(self, 'log_level', 'MISSING!')))
            
            # 额外检查show_variable是否正常工作
            print("\n🔬 Show_variable测试:")
            print("   qty类型: {0}".format(type(getattr(self, 'qty', None))))
            print("   version_tier类型: {0}".format(type(getattr(self, 'version_tier', None))))
            
            # 检查是否是show_variable返回值问题
            if hasattr(self, 'qty'):
                print("   qty == 20? {0}".format(getattr(self, 'qty', None) == 20))
                print("   qty == 1? {0}".format(getattr(self, 'qty', None) == 1))
            
        except Exception as e:
            print("❌ 参数打印失败: {0}".format(str(e)))
            import traceback
            print("详细错误: {0}".format(traceback.format_exc()))
        print("=" * 50)

    def setup_presets(self):
        """设置预设模板 - 在分层功能设置之后调用"""
        try:
            print("🎨 开始应用预设配置: preset_mode={0}".format(getattr(self, 'preset_mode', 'None')))
            
            presets = {
                1: {  # 保守型
                    "name": "保守型",
                    "description": "低风险，适合稳健投资者",
                    "base_qty": 10,
                    "risk_level": "低"
                },
                2: {  # 平衡型  
                    "name": "平衡型",
                    "description": "中等风险收益，适合大多数用户", 
                    "base_qty": None,  # 使用用户输入值
                    "risk_level": "中"
                },
                3: {  # 积极型
                    "name": "积极型", 
                    "description": "高频交易，适合风险承受能力强的用户",
                    "base_qty": 50,
                    "risk_level": "高"
                }
            }
            
            if self.preset_mode in presets:
                preset = presets[self.preset_mode]
                self.preset_name = preset["name"]
                self.preset_desc = preset["description"] 
                self.risk_level = preset["risk_level"]
                
                # 应用预设数量（仅在预设有特定值且用户使用默认值时）
                if preset["base_qty"] is not None and self.qty == 20:  # 默认值20
                    print("📦 应用预设数量: {0} -> {1}".format(self.qty, preset['base_qty']))
                    self.qty = preset["base_qty"]
                else:
                    print("📦 保持用户数量设置: {0}".format(self.qty))
                    
            else:
                self.preset_name = "自定义"
                self.preset_desc = "用户自定义参数"
                self.risk_level = "未知"
                
            print("🎨 预设配置完成: {0} - 数量: {1}股".format(self.preset_name, self.qty))
            
        except Exception as e:
            print("❌ 预设配置失败: {0}".format(str(e)))
            # 设置默认值
            self.preset_name = "默认"
            self.preset_desc = "系统默认配置"
            self.risk_level = "中"

    def setup_tier_features(self):
        """设置分层功能特性"""
        try:
            print("🔧 开始分层功能设置: version_tier={0}".format(getattr(self, 'version_tier', 'None')))
            
            # 资金管理设置
            if self.version_tier >= 2 and self.balance_mode == 2:
                # 付费版：使用自定义资金
                if self.backtest:
                    self.initial_balance = self.custom_balance
                    self.virtual_balance = self.custom_balance
                print("💰 使用自定义资金: ${0:,}".format(self.custom_balance))
            else:
                # 免费版：使用系统默认资金
                if self.backtest:
                    try:
                        self.initial_balance = total_cash(currency=Currency.USD)
                        if self.initial_balance is None or self.initial_balance <= 0:
                            self.initial_balance = 10000.0  # 默认1万美元
                        self.virtual_balance = self.initial_balance
                    except:
                        # 如果获取失败，使用默认值
                        self.initial_balance = 10000.0
                        self.virtual_balance = 10000.0
                        print("⚠️ 无法获取账户余额，使用默认资金$10,000")
                if self.version_tier == 1 and self.balance_mode == 2:
                    print("💡 自定义资金为付费版功能，当前使用系统默认")
                
            # 投资周期设置
            if self.interval_mode == 1:  # 自动模式
                if self.version_tier == 1:
                    # 免费版：固定每周
                    self.interval_min = 10080  # 7天 * 24小时 * 60分钟
                    self.interval_desc = "每周定投 (免费版)"
                else:
                    # 付费版：默认每日
                    self.interval_min = 1440  # 1天
                    self.interval_desc = "每日定投 (付费版默认)"
            elif self.interval_mode == 2:  # 每日
                if self.version_tier >= 2:
                    self.interval_min = 1440
                    self.interval_desc = "每日定投"
                else:
                    print("💡 每日定投为付费版功能，免费版使用每周定投")
                    self.interval_min = 10080
                    self.interval_desc = "每周定投 (免费版限制)"
            elif self.interval_mode == 3:  # 每周
                self.interval_min = 10080
                self.interval_desc = "每周定投"
            elif self.interval_mode == 4:  # 自定义
                if self.version_tier >= 2:
                    self.interval_min = self.custom_interval_min
                    self.interval_desc = "自定义周期 ({0}分钟)".format(self.interval_min)
                else:
                    print("💡 自定义周期为付费版功能，免费版使用每周定投")
                    self.interval_min = 10080
                    self.interval_desc = "每周定投 (免费版限制)"
            
            print("📅 投资周期: {0}".format(self.interval_desc))
            
        except Exception as e:
            import traceback
            print("❌ 分层功能设置失败: {0}".format(str(e)))
            print("错误详情: {0}".format(traceback.format_exc()))
            # 回退到默认设置
            self.interval_min = 10080 if getattr(self, 'version_tier', 1) == 1 else 1440
            self.interval_desc = "默认周期 ({0}分钟) - 异常回退".format(self.interval_min)
            if not hasattr(self, 'virtual_balance') or self.virtual_balance is None:
                self.virtual_balance = 10000.0
                self.initial_balance = 10000.0
            print("🔧 异常回退设置完成: interval_min={0}, virtual_balance=${1}".format(self.interval_min, self.virtual_balance))

    def print_initialization_status(self):
        """打印详细的初始化状态 - 用于调试"""
        print("\n🔍 初始化状态详情 - {0}".format(self._version))
        print("=" * 50)
        print("📊 版本信息: {0}".format(self._tier))
        print("📈 交易标的: {0}".format(getattr(self, 'stock', 'Unknown')))
        print("🎛️ 版本层级: {0}".format(getattr(self, 'version_tier', 'Unknown')))
        print("💰 虚拟余额: ${0:,.2f}".format(getattr(self, 'virtual_balance', 0)))
        print("📅 投资周期: {0}分钟".format(getattr(self, 'interval_min', 0)))
        print("📦 定投数量: {0}股".format(getattr(self, 'qty', 0)))
        print("🔧 回测模式: {0}".format(getattr(self, 'backtest', False)))
        print("⚙️ 间隔模式: {0}".format(getattr(self, 'interval_mode', 0)))
        print("💵 资金模式: {0}".format(getattr(self, 'balance_mode', 0)))
        
        # 检查关键属性
        critical_attrs = ['interval_min', 'virtual_balance', 'qty', 'version_tier']
        missing_attrs = []
        for attr in critical_attrs:
            if not hasattr(self, attr) or getattr(self, attr) is None:
                missing_attrs.append(attr)
        
        if missing_attrs:
            print("⚠️ 缺失属性: {0}".format(missing_attrs))
        else:
            print("✅ 所有关键属性已初始化")
        print("=" * 50)

    def print_welcome(self):
        """打印欢迎信息 - 分层版"""
        version_info = {
            1: {"name": "免费基础版", "features": "固定定投+风险提醒", "color": "🆓"},
            2: {"name": "付费进阶版(¥35/月)", "features": "3层智能加仓系统", "color": "💎"}
        }
        
        current_version = version_info.get(self.version_tier, version_info[1])
        
        print("\n" + "="*60)
        print("🚀 DCA智能定投策略 {0}".format(self._version))
        print("="*60)
        print("{0} 当前版本: {1}".format(current_version['color'], current_version['name']))
        print("✨ 核心功能: {0}".format(current_version['features']))
        
        if self.version_tier == 1:
            print("\n🆓 免费版功能:")
            print("   ✅ 固定周期智能定投")
            print("   ✅ 基础回撤监控提醒")
            print("   ✅ 风险保护系统")
            print("   ✅ 投资记录统计")
        elif self.version_tier == 2:
            print("\n💎 付费版功能 (¥35/月):")
            print("   ✅ 包含免费版所有功能")
            print("   ✅ 3层智能加仓 (5%/10%/20%)")
            print("   ✅ 动态倍数调整 (1.5x/2x/3x)")
            print("   ✅ 个性化参数配置")
            print("   ✅ 极端回撤保护")
            
        print("\n📊 当前配置:")
        print("   版本等级: {0} ({1})".format(self.version_tier, '免费版' if self.version_tier == 1 else '付费版'))
        print("   投资模板: {0} ({1})".format(self.preset_name, self.preset_desc))
        print("   风险等级: {0}".format(self.risk_level))
        print("   定投数量: {0}股".format(self.qty))
        print("   投资周期: {0}".format(getattr(self, 'interval_desc', self._get_interval_desc())))
        if hasattr(self, 'virtual_balance'):
            print("   初始资金: ${0:,.0f}".format(self.virtual_balance))
        print("   回撤阈值: {0}".format(self.drawdown_layers))
        print("   运行模式: {0}".format('回测' if self.backtest else '实盘'))
        
        if self.version_tier == 1:
            print("\n🎯 升级提示:")
            print("   💡 付费版支持每日定投，获得更平滑的平均成本")
            print("   💡 付费版支持智能3层加仓，回撤时自动增加投资")
            print("   💡 付费版支持自定义资金(10K-500K)和投资周期")
            print("   💰 历史数据显示每日定投比每周定投收益提升3-8%")
            print("   💰 联系作者升级至付费版(¥35/月)解锁完整功能")
        
        print("="*60 + "\n")

    def _get_interval_desc(self):
        """获取周期描述"""
        if self.interval_min == 60:
            return "1小时"
        elif self.interval_min == 1440:
            return "1天"
        elif self.interval_min == 10080:
            return "1周"
        else:
            return "{0}分钟".format(self.interval_min)

    def handle_data(self):
        """主要交易逻辑 - 分层架构"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            latest_price, highest_price, account_balance = self.get_market_data()
            
            # 计算回撤和持仓信息
            drawdown = self.calculate_drawdown(latest_price)
            position = self.get_position()
            
            if self.log_level >= 1:
                print("📊 价格={0:.2f}, 回撤={1:.2f}%, 持仓={2}, 最高价={3:.2f}".format(latest_price, drawdown, position, self.highest_price))

            # 分层功能路由
            if self.version_tier == 1:
                # 免费版逻辑
                self.free_version_logic(current_time, latest_price, account_balance, drawdown)
            elif self.version_tier == 2:
                # 付费版逻辑 
                self.advanced_version_logic(current_time, latest_price, account_balance, drawdown)
            else:
                # 默认免费版
                print("⚠️ 版本参数错误，使用免费版功能")
                self.free_version_logic(current_time, latest_price, account_balance, drawdown)

        except Exception as e:
            import traceback
            error_msg = str(e) if str(e) else "未知错误"
            print("❌ 策略执行错误: {0}".format(error_msg))
            print("错误详情: {0}".format(traceback.format_exc()))

    def get_market_data(self):
        """获取市场数据"""
        if self.backtest:
            # 回测模式
            try:
                if not hasattr(self, 'bar_index'):
                    self.bar_index = 0
                self.bar_index += 1
                
                latest_price = bar_close(self.stock, bar_type=BarType.D1, select=1)
                if latest_price is None or latest_price <= 0:
                    print("⚠️ 获取价格失败，使用默认价格")
                    latest_price = 100.0  # 默认价格
                
                # 记录有效价格供后续使用
                if latest_price > 0:
                    self.last_valid_price = latest_price
                
                self.high_queue.append(latest_price)
                
                # 使用条件判断替代min()函数
                available_days = self.bar_index if self.bar_index < 20 else 20
                high_list = list(self.high_queue)[-available_days:]
                if len(high_list) == 0:
                    highest_price = latest_price
                elif len(high_list) == 1:
                    highest_price = high_list[0]
                else:
                    # 使用Moomoo支持的max()函数格式，传入具体数值
                    highest_price = high_list[0]
                    for price in high_list[1:]:
                        if price > highest_price:
                            highest_price = price
                
                account_balance = self.virtual_balance
                return latest_price, highest_price, account_balance
            except Exception as e:
                print("回测数据获取错误: {0}".format(str(e)))
                # 返回默认值避免策略崩溃
                default_balance = getattr(self, 'virtual_balance', 10000.0) or 10000.0
                return self.last_valid_price, self.last_valid_price, default_balance
        else:
            # 实盘模式
            latest_price = current_price(self.stock, price_type=THType.FTH)
            if latest_price is None or latest_price <= 0:
                latest_price = self.last_valid_price
            else:
                self.last_valid_price = latest_price
            
            high_list = [bar_high(self.stock, bar_type=BarType.D1, select=i) for i in range(1, 21)]
            # 处理可能的None值并找出最大值
            valid_highs = [h for h in high_list if h is not None and h > 0]
            if len(valid_highs) == 0:
                highest_price = latest_price
            elif len(valid_highs) == 1:
                highest_price = valid_highs[0]
            else:
                highest_price = valid_highs[0]
                for price in valid_highs[1:]:
                    if price > highest_price:
                        highest_price = price
            
            account_balance = total_cash(currency=Currency.USD)
            return latest_price, highest_price, account_balance

    def calculate_drawdown(self, latest_price):
        """计算回撤幅度 - 修复版"""
        # 初始化策略启动价格和最高价
        if self.strategy_start_price is None:
            self.strategy_start_price = latest_price
            self.highest_price = latest_price
            return 0.0
            
        # 更新最高价（只能上升，不能下降）
        if latest_price > self.highest_price:
            self.highest_price = latest_price
            # 价格创新高时，重置回撤层级（可选）
            if (latest_price - self.highest_price) / self.highest_price > self.drawdown_reset_threshold:
                self.current_drawdown_layer = -1  # 重置为未触发状态
        
        # 计算当前回撤
        if self.highest_price > 0:
            drawdown = (self.highest_price - latest_price) / self.highest_price * 100
        else:
            drawdown = 0.0
            
        return drawdown

    def calculate_add_position_qty(self, drawdown):
        """计算加仓数量 - 免费版3层"""
        for i, threshold in enumerate(self.drawdown_layers):
            if drawdown >= threshold:
                # 检查是否已经在这个层级或更高层级加过仓
                if i <= self.current_drawdown_layer:
                    continue
                    
                # 触发新的加仓层级
                self.current_drawdown_layer = i
                add_qty = int(self.qty * self.drawdown_multipliers[i])
                
                print("🎯 回撤加仓触发: 第{0}层 ({1}%), 倍数={2}x, 数量={3}股".format(i+1, threshold, self.drawdown_multipliers[i], add_qty))
                return add_qty
        
        return 0

    def should_invest(self, current_time):
        """判断是否应该定投"""
        if self.last_investment_time is None:
            return True
        elapsed = (current_time - self.last_investment_time).total_seconds() / 60
        
        # 健壮性检查：如果interval_min不存在，使用默认值
        if not hasattr(self, 'interval_min') or self.interval_min is None:
            # 根据版本层级设置默认值
            default_interval = 10080 if getattr(self, 'version_tier', 1) == 1 else 1440
            self.interval_min = default_interval
            print("⚠️ interval_min缺失，设置默认值: {0}分钟".format(self.interval_min))
        
        return elapsed >= self.interval_min

    def free_version_logic(self, current_time, latest_price, account_balance, drawdown):
        """免费版策略逻辑 - 基础定投 + 风险提醒"""
        
        # 风险提醒功能
        if drawdown >= 20.0:
            print("⚠️ 免费版风险提醒: 当前回撤{0:.1f}%，建议关注市场变化".format(drawdown))
        elif drawdown >= 10.0:
            print("📢 回撤监控: 当前回撤{0:.1f}%".format(drawdown))
            
        # 纯定投模式或基础回撤保护
        # 确保basic_invest_only是布尔值
        basic_only = bool(getattr(self, 'basic_invest_only', False))
        if basic_only:
            if self.should_invest(current_time):
                self.execute_investment(latest_price, account_balance, self.qty, "基础定投")
        else:
            # 仅常规定投，不加仓
            if self.should_invest(current_time):
                self.execute_investment(latest_price, account_balance, self.qty, "定期定投")

    def advanced_version_logic(self, current_time, latest_price, account_balance, drawdown):
        """付费版策略逻辑 (¥35/月) - 智能3层加仓系统"""
        
        # 检查版本授权（实际使用时可连接服务器验证）
        if self.version_tier != 2:
            print("💡 3层智能加仓功能需要升级到付费版(¥35/月)，请联系作者")
            print("📱 当前使用免费版功能...")
            return self.free_version_logic(current_time, latest_price, account_balance, drawdown)
        
        # 极端回撤保护
        if drawdown >= self.extreme_drawdown_pct:
            print("🚨 极端回撤保护: {0:.1f}% >= {1}%，仅定投模式".format(drawdown, self.extreme_drawdown_pct))
            if self.should_invest(current_time):
                self.execute_investment(latest_price, account_balance, self.qty, "极端回撤保护")
            return

        # 智能3层加仓系统
        add_qty = self.calculate_add_position_qty(drawdown)
        if add_qty > 0:
            self.execute_investment(latest_price, account_balance, add_qty, "付费版-第{0}层加仓".format(self.current_drawdown_layer+1))
            return

        # 常规定投
        if self.should_invest(current_time):
            self.execute_investment(latest_price, account_balance, self.qty, "付费版-定期定投")

    def execute_investment(self, latest_price, account_balance, quantity, trade_type="定投"):
        """执行投资"""
        
        # 调试日志
        print("🔧 投资执行调试: price={0}, balance={1}, qty={2}, type={3}".format(latest_price, account_balance, quantity, trade_type))
        print("🔧 当前状态: version_tier={0}, virtual_balance={1}".format(getattr(self, 'version_tier', 'None'), getattr(self, 'virtual_balance', 'None')))
        
        # 参数合法性检查 - 付费版支持更灵活的数量
        if self.version_tier == 2:
            # 付费版：支持任意数量，仅检查基本范围
            if quantity < 1 or quantity > 1000:
                print("⚠️ 付费版参数修正: 投资数量 {0} -> {1}股".format(quantity, self.qty))
                quantity = self.qty
        else:
            # 免费版：必须是10的倍数
            if quantity < 10 or quantity > 100 or quantity % 10 != 0:
                print("⚠️ 免费版参数修正: 投资数量 {0} -> 20股 (免费版要求10-100股，10的倍数)".format(quantity))
                quantity = 20  # 免费版默认值

        if self.backtest:
            # 回测模式 - 使用place_market产生GUI交易打点
            required_cash = quantity * latest_price
            
            # 确保virtual_balance不为None
            if self.virtual_balance is None:
                self.virtual_balance = 10000.0
                print("⚠️ 虚拟余额为None，设置默认值${0:,.0f}".format(self.virtual_balance))
            
            if required_cash > self.virtual_balance:
                # 资金不足，自动调整投资数量
                original_qty = quantity
                max_qty = int(self.virtual_balance // latest_price)
                if max_qty < 1:
                    print("💰 虚拟余额不足，无法购买任何股票: 需要${0:.2f}, 可用${1:.2f}".format(required_cash, self.virtual_balance))
                    return
                quantity = max_qty
                required_cash = quantity * latest_price
                print("⚠️ 资金调整: 原计划买{0}股，调整为{1}股 (可用资金${2:.2f})".format(original_qty, quantity, self.virtual_balance))
            
            if quantity < 1:
                print("💰 调整后数量不足1股，跳过本次投资")
                return

            # 调用place_market模拟下单，产生GUI交易打点
            order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
            
            # 精简日志输出，仅保留关键信息
            print("📊 {0}: {1}股 @ ${2:.2f} | 订单:{3}".format(trade_type, quantity, latest_price, order_id))
            
            # 更新虚拟账户
            self.virtual_balance -= required_cash
            self._total_cost += required_cash
            self._position += quantity
            
            print("💰 余额: ${0:.2f} | 持仓: {1}股".format(self.virtual_balance, self._position))
            
        else:
            # 实盘模式
            required_cash = quantity * latest_price
            if required_cash > account_balance:
                # 资金不足，按可用资金调整数量
                max_qty = int((account_balance // latest_price) // 10 * 10)
                if max_qty < 10:
                    print("💰 资金不足，无法投资")
                    return
                quantity = max_qty
                print("⚠️ 资金调整: 投资数量调整为 {0}股".format(quantity))

            try:
                # 使用市价买入确保成交
                order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
                print("✅ {0}订单: {1}股 @ 市价, 订单号: {2}".format(trade_type, quantity, order_id))
            except Exception as e:
                print("❌ 下单失败: {0}".format(str(e)))
                return

        self.last_investment_time = device_time(TimeZone.DEVICE_TIME_ZONE)

    def get_position(self):
        """获取持仓数量"""
        if self.backtest:
            return self._position
        try:
            return position_holding_qty(self.stock)
        except:
            return 0

    def get_total_cost(self):
        """获取总成本"""
        if self.backtest:
            return self._total_cost
        try:
            pos = position_holding_qty(self.stock)
            avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
            return pos * avg_cost
        except:
            return 0.0

    def get_avg_cost(self):
        """获取平均成本"""
        if self.backtest:
            return self._total_cost / self._position if self._position > 0 else 0.0
        try:
            return position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
        except:
            return 0.0