class Strategy(StrategyBase):
    """DCA定投策略 - 统一开发版 v2.5.0"""

    def initialize(self):
        """初始化策略"""
        try:
            self._version = "v2.5.0-MainDev"
            
            print("🚀 开始初始化 {0}".format(self._version))
            
            # 核心状态变量
            self.last_investment_time = None
            self.highest_price = None  # 兼容性保留
            self.run_highest_price = None  # 新的运行时最高价
            self.last_valid_price = 100.0
            self.strategy_start_price = None
            self.drawdown_reset_threshold = 0.05
            
            # 简化状态管理
            
            # 回测支持变量
            import collections
            self.high_queue = collections.deque(maxlen=20)
            self._position = 0
            self._total_cost = 0.0
            self.virtual_balance = None
            
            # 初始化组件
            self.trigger_symbols()
            self.custom_indicator()
            self.global_variables()
            self.setup_presets()  # 预设设置先执行，设定effective_qty
            self.setup_tier_features()  # 分层功能后执行，依赖effective_qty
            
            # v2.4.0 新增: 初始化历史最高价基准
            self.initialize_highest_price_baseline()
            
            print("✅ 初始化完成")
            self.print_welcome()
            
        except Exception as e:
            print("❌ 初始化失败: {0}".format(str(e)))

    def trigger_symbols(self):
        """设置交易标的"""
        try:
            self.stock = declare_trig_symbol()
            print("📈 交易标的: {0}".format(self.stock))
        except Exception as e:
            print("❌ 标的设置失败: {0}".format(str(e)))

    def custom_indicator(self):
        """注册自定义技术指标"""
        try:
            self.register_indicator(
                indicator_name='MA',
                script='MA5:MA(CLOSE,5),COLORFF8D1E;',
                param_list=[]
            )
        except Exception as e:
            print("❌ 技术指标注册失败: {0}".format(str(e)))

    def global_variables(self):
        """全局变量设置"""
        try:
            # === 基础参数 ===
            self.qty = show_variable(20, GlobalType.INT)
            self.preset_mode = show_variable(2, GlobalType.INT)  # 默认平衡型
            self.backtest = show_variable(True, GlobalType.BOOL)
            self.basic_invest_only = show_variable(False, GlobalType.BOOL)
            
            # === 分层功能参数 ===
            self.version_tier = show_variable(2, GlobalType.INT)  # 1=免费版 2=付费版
            self.balance_mode = show_variable(2, GlobalType.INT)  # 使用自定义资金
            self.custom_balance = show_variable(100000, GlobalType.INT)  # 增加到10万
            self.interval_mode = show_variable(1, GlobalType.INT)  # 自动模式
            self.custom_interval_min = show_variable(1440, GlobalType.INT)
            
            # === v2.4.0 新增: 激进乘数系统 ===
            self.aggressive_multiplier = show_variable(1.0, GlobalType.FLOAT)  # 1.0-2.5倍乘数
            
            # 基础固定参数 - v2.5.0扩展支持
            # 免费版: 3层, 付费版: 5层
            if self.version_tier == 1:
                self.drawdown_layers = [5.0, 10.0, 20.0]
                self.base_multipliers = [1.5, 2.0, 3.0]
            else:  # self.version_tier == 2 (付费版)
                self.drawdown_layers = [5.0, 10.0, 20.0, 35.0, 50.0] 
                self.base_multipliers = [1.5, 2.0, 3.0, 4.0, 5.0]
            
            self.extreme_drawdown_pct = 60.0  # 超过最高层的极端回撤阈值
            self.log_level = 0
            
            # 动态计算最终倍数 - 在setup_tier_features()中设置
            self.drawdown_multipliers = self.base_multipliers  # 默认值
            
            print("⚙️ 参数配置完成")
            
        except Exception as e:
            print("❌ 参数设置失败: {0}".format(str(e)))

    def setup_presets(self):
        """设置预设模板 - 实际应用数量设置"""
        try:
            presets = {
                1: {"name": "保守型", "description": "低风险", "base_qty": 10, "risk_level": "低"},
                2: {"name": "平衡型", "description": "中等风险", "base_qty": 15, "risk_level": "中"},
                3: {"name": "积极型", "description": "高风险", "base_qty": 25, "risk_level": "高"}
            }
            
            if self.preset_mode in presets:
                preset = presets[self.preset_mode]
                self.preset_name = preset["name"]
                self.preset_desc = preset["description"]
                self.risk_level = preset["risk_level"]
                
                # 尊重用户设置，预设仅作为建议
                self.effective_qty = self.qty
                recommended_qty = preset["base_qty"]
                
                if self.qty != recommended_qty:
                    print("💡 预设建议: {0}推荐{1}股，您选择{2}股".format(
                        self.preset_name, recommended_qty, self.qty))
                else:
                    print("✅ 预设匹配: {0} - 投资数量: {1}股".format(
                        self.preset_name, self.qty))
                    
            else:
                self.preset_name = "自定义"
                self.preset_desc = "用户自定义参数"
                self.risk_level = "中"
                self.effective_qty = self.qty
                
            print("🎨 预设配置: {0} - 数量: {1}股".format(self.preset_name, self.effective_qty))
            
        except Exception as e:
            print("❌ 预设配置失败: {0}".format(str(e)))
            self.preset_name = "默认"
            self.preset_desc = "系统默认配置"
            self.risk_level = "中"
            self.effective_qty = self.qty

    def setup_tier_features(self):
        """设置分层功能特性"""
        try:
            # 资金管理设置
            if self.version_tier >= 2 and self.balance_mode == 2:
                if self.backtest:
                    self.initial_balance = self.custom_balance
                    self.virtual_balance = self.custom_balance
                print("💰 使用自定义资金: ${0:,}".format(self.custom_balance))
            else:
                if self.backtest:
                    try:
                        self.initial_balance = total_cash(currency=Currency.USD)
                        if self.initial_balance is None or self.initial_balance <= 0:
                            self.initial_balance = 10000.0
                        self.virtual_balance = self.initial_balance
                    except:
                        self.initial_balance = 10000.0
                        self.virtual_balance = 10000.0
                        print("⚠️ 使用默认资金$10,000")
                
            # 投资周期设置
            if self.interval_mode == 1:  # 自动模式
                if self.version_tier == 1:
                    self.interval_min = 10080  # 每周
                    self.interval_desc = "每周定投 (免费版)"
                else:
                    # 付费版智能频率：根据资金和数量自动调整
                    daily_cost = self.effective_qty * 600  # 估算每日成本(SPY约$600)
                    max_days = int(self.virtual_balance / daily_cost)
                    
                    # 考虑智能加仓预留资金 (预留30%资金用于加仓)
                    conservative_days = int(max_days * 0.7)
                    
                    if conservative_days >= 5:  # 保守预估5天以上，使用每日定投
                        self.interval_min = 1440
                        self.interval_desc = "每日定投 (付费版智能)"
                    elif conservative_days >= 2:  # 保守预估2天以上，使用每周定投
                        self.interval_min = 10080
                        self.interval_desc = "每周定投 (付费版智能)"
                    else:  # 资金严重不足，使用双周
                        self.interval_min = 20160
                        self.interval_desc = "双周定投 (资金优化)"
                        
                    print("📊 智能频率计算: 预估{0}天资金(保守{1}天)，选择{2}".format(max_days, conservative_days, self.interval_desc))
                    
            elif self.interval_mode == 2:  # 强制每日
                if self.version_tier >= 2:
                    self.interval_min = 1440
                    self.interval_desc = "每日定投"
                else:
                    print("💡 每日定投为付费版功能")
                    self.interval_min = 10080
                    self.interval_desc = "每周定投 (免费版限制)"
            elif self.interval_mode == 3:  # 每周
                self.interval_min = 10080
                self.interval_desc = "每周定投"
            elif self.interval_mode == 4:  # 自定义
                if self.version_tier >= 2:
                    self.interval_min = self.custom_interval_min
                    self.interval_desc = "自定义周期 ({0}分钟)".format(self.interval_min)
                else:
                    print("💡 自定义周期为付费版功能")
                    self.interval_min = 10080
                    self.interval_desc = "每周定投 (免费版限制)"
            
            print("📅 投资周期: {0}".format(self.interval_desc))
            
            # v2.4.0 新增: 设置激进乘数系统
            self.setup_aggressive_multiplier_system()
            
        except Exception as e:
            print("❌ 分层功能设置失败: {0}".format(str(e)))
            self.interval_min = 10080 if getattr(self, 'version_tier', 1) == 1 else 1440
            self.interval_desc = "默认周期 ({0}分钟)".format(self.interval_min)
            if not hasattr(self, 'virtual_balance') or self.virtual_balance is None:
                self.virtual_balance = 10000.0
                self.initial_balance = 10000.0

    def initialize_highest_price_baseline(self):
        """初始化历史最高价基准 - v2.4.0新增"""
        try:
            print("📈 正在初始化历史最高价基准...")
            
            # 使用bar_custom API获取过去200个交易日的最高价
            historical_high = bar_custom(
                symbol=self.stock,
                data_type=BarDataType.HIGH,
                custom_num=200,  # 约200个交易日（约1年）
                custom_type=CustomType.D1,
                select=1
            )
            
            if historical_high and historical_high > 0:
                self.run_highest_price = historical_high
                print("✅ 历史最高价基准: ${0:.2f} (200日内)".format(historical_high))
            else:
                # 如果无法获取历史数据，使用当前价格
                current_price_val = current_price(self.stock, price_type=THType.FTH)
                if current_price_val and current_price_val > 0:
                    self.run_highest_price = current_price_val
                else:
                    self.run_highest_price = self.last_valid_price
                print("⚠️ 无法获取历史数据，使用当前价格: ${0:.2f}".format(self.run_highest_price))
            
            # 兼容性设置
            self.highest_price = self.run_highest_price
            
        except Exception as e:
            print("❌ 历史最高价初始化失败: {0}".format(str(e)))
            # 回退到当前价格
            self.run_highest_price = self.last_valid_price
            self.highest_price = self.run_highest_price
            print("🔧 使用默认值: ${0:.2f}".format(self.run_highest_price))

    def setup_aggressive_multiplier_system(self):
        """设置激进乘数系统 - v2.4.0新增"""
        try:
            print("🎯 正在设置激进乘数系统...")
            
            # 根据版本层级设置乘数限制
            if self.version_tier == 1:
                # 免费版：固定标准倍数
                self.aggressive_multiplier = 1.0
                print("🆓 免费版: 使用标准乘数 1.0x")
            elif self.version_tier == 2:
                # 付费版：允许激进乘数 1.0-2.5
                multiplier_input = getattr(self, 'aggressive_multiplier', 1.0)
                if multiplier_input < 1.0:
                    self.aggressive_multiplier = 1.0
                    print("⚠️ 乘数不能小于1.0，设置为1.0x")
                elif multiplier_input > 2.5:
                    self.aggressive_multiplier = 2.5
                    print("⚠️ 乘数不能超过2.5，设置为2.5x")
                else:
                    self.aggressive_multiplier = multiplier_input
                
                print("💰 付费版: 使用激进乘数 {0}x".format(self.aggressive_multiplier))
            
            # 计算最终倍数
            self.drawdown_multipliers = [
                m * self.aggressive_multiplier for m in self.base_multipliers
            ]
            
            print("📋 基础倍数: {0}".format(self.base_multipliers))
            print("🚀 最终倍数: {0}".format(["{0:.1f}x".format(m) for m in self.drawdown_multipliers]))
            
            # 显示层级和倍数对应关系
            for i, (layer, multiplier) in enumerate(zip(self.drawdown_layers, self.drawdown_multipliers)):
                print("   第{0}层: {1}%回撤 → {2:.1f}倍加仓".format(i+1, layer, multiplier))
            
        except Exception as e:
            print("❌ 激进乘数设置失败: {0}".format(str(e)))
            # 回退到标准倍数
            self.aggressive_multiplier = 1.0
            self.drawdown_multipliers = self.base_multipliers
            print("🔧 使用标准倍数")

    def print_welcome(self):
        """打印欢迎信息"""
        version_info = {
            1: {"name": "免费基础版", "features": "固定定投+风险提醒", "color": "🆓"},
            2: {"name": "付费进阶版(¥35/月)", "features": "智能加仓系统", "color": "💎"}
        }
        
        current_version = version_info.get(self.version_tier, version_info[1])
        
        print("="*60)
        print("🚀 DCA智能定投策略 {0}".format(self._version))
        print("="*60)
        print("{0} 当前版本: {1}".format(current_version['color'], current_version['name']))
        print("✨ 核心功能: {0}".format(current_version['features']))
        
        print("\n📊 当前配置:")
        print("   版本等级: {0} ({1})".format(self.version_tier, '免费版' if self.version_tier == 1 else '付费版'))
        print("   投资模板: {0} ({1})".format(self.preset_name, self.preset_desc))
        print("   用户设置: {0}股".format(self.qty))
        print("   实际投资: {0}股".format(self.effective_qty))
        print("   投资周期: {0}".format(getattr(self, 'interval_desc', '未知')))
        if hasattr(self, 'virtual_balance'):
            print("   初始资金: ${0:,.0f}".format(self.virtual_balance))
            # 计算大约可投资天数
            daily_cost = self.effective_qty * 600  # 估算
            estimated_days = int(self.virtual_balance / daily_cost)
            conservative_days = int(estimated_days * 0.7)
            print("   预估投资: 约{0}天 (保守{1}天，预留加仓资金)".format(estimated_days, conservative_days))
        print("   运行模式: {0}".format('回测' if self.backtest else '实盘'))
        
        # v2.4.0 新增：显示激进乘数系统
        if hasattr(self, 'run_highest_price'):
            print("   历史最高价: ${0:.2f}".format(self.run_highest_price))
        if hasattr(self, 'aggressive_multiplier'):
            print("   激进乘数: {0}x".format(self.aggressive_multiplier))
        if hasattr(self, 'drawdown_multipliers'):
            print("   回撤层级: {0}".format(self.drawdown_layers))
            print("   加仓倍数: {0}".format(["{0:.1f}x".format(m) for m in self.drawdown_multipliers]))
        
        if self.version_tier == 1:
            print("\n🎯 升级提示:")
            print("   💡 付费版支持智能频率调整")
            print("   💡 付费版支持智能加仓系统")
            print("   💰 联系作者升级至付费版(¥35/月)")
        
        print("="*60 + "\n")

    def handle_data(self):
        """主要交易逻辑"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            latest_price, account_balance = self.get_market_data()
            
            drawdown = self.calculate_drawdown(latest_price)
            
            # 添加调试信息
            if hasattr(self, 'bar_index') and self.bar_index % 5 == 0:  # 每5个bar打印一次
                print("📊 策略状态 - 时间: {0}, 价格: ${1:.2f}, 余额: ${2:.0f}, Bar: {3}".format(
                    current_time.strftime("%Y/%m/%d"), latest_price, account_balance, self.bar_index))
            
            # 分层功能路由
            if self.version_tier == 1:
                self.free_version_logic(current_time, latest_price, account_balance, drawdown)
            elif self.version_tier == 2:
                self.advanced_version_logic(current_time, latest_price, account_balance, drawdown)
            else:
                print("⚠️ 版本参数错误，使用免费版功能")
                self.free_version_logic(current_time, latest_price, account_balance, drawdown)

        except Exception as e:
            print("❌ 策略执行错误: {0}".format(str(e)))

    def get_market_data(self):
        """获取市场数据 - v2.4.0简化版"""
        if self.backtest:
            try:
                if not hasattr(self, 'bar_index'):
                    self.bar_index = 0
                self.bar_index += 1
                
                latest_price = bar_close(self.stock, bar_type=BarType.D1, select=1)
                if latest_price is None or latest_price <= 0:
                    latest_price = 100.0
                
                # 更新有效价格
                if latest_price > 0:
                    self.last_valid_price = latest_price
                
                account_balance = self.virtual_balance
                return latest_price, account_balance
                
            except Exception as e:
                print("回测数据获取错误: {0}".format(str(e)))
                default_balance = getattr(self, 'virtual_balance', 10000.0) or 10000.0
                return self.last_valid_price, default_balance
        else:
            # 实盘模式
            latest_price = current_price(self.stock, price_type=THType.FTH)
            if latest_price is None or latest_price <= 0:
                latest_price = self.last_valid_price
            else:
                self.last_valid_price = latest_price
            
            account_balance = total_cash(currency=Currency.USD)
            return latest_price, account_balance

    def calculate_drawdown(self, latest_price):
        """计算回撤幅度 - v2.4.0修复版"""
        # 初始化检查
        if not hasattr(self, 'run_highest_price') or self.run_highest_price is None:
            self.run_highest_price = latest_price
            print("⚠️ 运行时初始化最高价: ${0:.2f}".format(latest_price))
            
        # 实时更新运行时最高价
        if latest_price > self.run_highest_price:
            old_high = self.run_highest_price
            self.run_highest_price = latest_price
            print("📈 创新高: ${0:.2f} → ${1:.2f}".format(old_high, latest_price))
            
            # 价格创新高时重置回撤层级
            if hasattr(self, 'current_drawdown_layer'):
                self.current_drawdown_layer = -1
        
        # 兼容性更新旧的highest_price
        self.highest_price = self.run_highest_price
        
        # 计算准确回撤
        if self.run_highest_price > 0:
            drawdown = (self.run_highest_price - latest_price) / self.run_highest_price * 100
        else:
            drawdown = 0.0
            
        return drawdown

    def calculate_add_position_qty(self, drawdown):
        """计算加仓数量 - v2.4.1修复版：从高层级往低层级检查"""
        # v2.5.0新增: 检查是否超出最高层级的极端回撤
        max_layer_threshold = self.drawdown_layers[-1]
        if drawdown > max_layer_threshold and drawdown >= self.extreme_drawdown_pct:
            if not hasattr(self, '_extreme_drawdown_warned'):
                print("🚨 极端回撤警告: 当前回撤{0:.1f}%超过第{1}层({2}%)".format(
                    drawdown, len(self.drawdown_layers), max_layer_threshold))
                print("📱 建议考虑VIP App的高级回撤管理功能")
                self._extreme_drawdown_warned = True
        
        # v2.4.1 修复: 从最高层级开始检查（从后往前遍历）
        for i in reversed(range(len(self.drawdown_layers))):
            threshold = self.drawdown_layers[i]
            if drawdown >= threshold:
                # 激进抄底策略 - 选择最适合的层级
                add_qty = int(self.effective_qty * self.drawdown_multipliers[i])
                
                print("🎯 回撤加仓触发: 第{0}层 ({1}%), 实际回撤{2:.1f}%, 数量={3}股".format(
                    i+1, threshold, drawdown, add_qty))
                print("💰 乘数详情: 基础{0}股 × {1:.1f}倍 = {2}股".format(
                    self.effective_qty, self.drawdown_multipliers[i], add_qty))
                
                # 显示VIP功能引导
                if i >= 1:  # 第2层及以上显示VIP升级提示
                    print("💡 VIP版本提供11层成本定投算法，在{0:.1f}%回撤时有更精细的加仓策略".format(drawdown))
                    print("👑 联系微信获取VIP完整版(¥500/年)，包含AI参数优化和多标的投资组合")
                
                return add_qty
        
        return 0

    def should_invest(self, current_time):
        """判断是否应该定投"""
        if self.last_investment_time is None:
            return True
        elapsed = (current_time - self.last_investment_time).total_seconds() / 60
        
        if not hasattr(self, 'interval_min') or self.interval_min is None:
            default_interval = 10080 if getattr(self, 'version_tier', 1) == 1 else 1440
            self.interval_min = default_interval
        
        should_invest_now = elapsed >= self.interval_min
        
        # 调试信息
        if elapsed > 0:
            print("⏰ 定投检查: 间隔{0:.0f}分钟 / 需要{1}分钟 = {2}".format(
                elapsed, self.interval_min, "✅可定投" if should_invest_now else "⏳等待中"))
        
        return should_invest_now

    def free_version_logic(self, current_time, latest_price, account_balance, drawdown):
        """免费版策略逻辑"""
        
        # 风险提醒功能
        if drawdown >= 20.0:
            print("⚠️ 免费版风险提醒: 当前回撤{0:.1f}%".format(drawdown))
        elif drawdown >= 10.0:
            print("📢 回撤监控: 当前回撤{0:.1f}%".format(drawdown))
            
        # 定投逻辑
        basic_only = bool(getattr(self, 'basic_invest_only', False))
        if basic_only or True:  # 免费版只做定投
            if self.should_invest(current_time):
                self.execute_investment(latest_price, account_balance, self.effective_qty, "基础定投")

    def advanced_version_logic(self, current_time, latest_price, account_balance, drawdown):
        """付费版策略逻辑"""
        
        if self.version_tier != 2:
            print("💡 智能加仓功能需要升级到付费版(¥35/月)")
            return self.free_version_logic(current_time, latest_price, account_balance, drawdown)
        
        # 极端回撤保护
        if drawdown >= self.extreme_drawdown_pct:
            print("🚨 极端回撤保护: {0:.1f}%，仅定投模式".format(drawdown))
            if self.should_invest(current_time):
                self.execute_investment(latest_price, account_balance, self.effective_qty, "极端回撤保护")
            return

        # 智能加仓系统
        add_qty = self.calculate_add_position_qty(drawdown)
        if add_qty > 0:
            self.execute_investment(latest_price, account_balance, add_qty, "付费版-智能加仓")
            return

        # 常规定投
        if self.should_invest(current_time):
            self.execute_investment(latest_price, account_balance, self.effective_qty, "付费版-定期定投")

    def execute_investment(self, latest_price, account_balance, quantity, trade_type="定投"):
        """执行投资"""
        
        # 参数检查
        if self.version_tier == 2:
            if quantity < 1 or quantity > 1000:
                print("⚠️ 付费版参数修正: 投资数量 {0} -> {1}股".format(quantity, self.effective_qty))
                quantity = self.effective_qty
        else:
            if quantity < 10 or quantity > 100 or quantity % 10 != 0:
                print("⚠️ 免费版参数修正: 投资数量 {0} -> 10股".format(quantity))
                quantity = 10

        if self.backtest:
            # 回测模式
            required_cash = quantity * latest_price
            
            if self.virtual_balance is None:
                self.virtual_balance = 10000.0
            
            if required_cash > self.virtual_balance:
                # 智能资金调整
                max_qty = int(self.virtual_balance // latest_price)
                if max_qty < 1:
                    print("💰 虚拟余额不足: ${0:.0f} < ${1:.0f}".format(self.virtual_balance, required_cash))
                    print("📊 建议: 增加initial_balance或减少投资频率")
                    return
                quantity = max_qty
                required_cash = quantity * latest_price
                print("⚠️ 智能资金调整: 原计划{0}股 → 实际{1}股 (剩余${2:.0f})".format(
                    int(self.effective_qty), quantity, self.virtual_balance))
            
            if quantity < 1:
                print("💰 调整后数量不足1股")
                return

            # 下单
            order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
            
            print("📊 {0}: {1}股 @ ${2:.2f}".format(trade_type, quantity, latest_price))
            
            # 更新账户
            self.virtual_balance -= required_cash
            self._total_cost += required_cash
            self._position += quantity
            
            print("💰 余额: ${0:.2f} | 持仓: {1}股".format(self.virtual_balance, self._position))
            
        else:
            # 实盘模式
            required_cash = quantity * latest_price
            if required_cash > account_balance:
                max_qty = int((account_balance // latest_price) // 10 * 10)
                if max_qty < 10:
                    print("💰 资金不足，无法投资")
                    return
                quantity = max_qty
                print("⚠️ 资金调整: 投资数量调整为 {0}股".format(quantity))

            try:
                order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
                print("✅ {0}订单: {1}股 @ 市价, 订单号: {2}".format(trade_type, quantity, order_id))
            except Exception as e:
                print("❌ 下单失败: {0}".format(str(e)))
                return

        self.last_investment_time = device_time(TimeZone.DEVICE_TIME_ZONE)

    def get_position(self):
        """获取持仓数量"""
        if self.backtest:
            return self._position
        try:
            return position_holding_qty(self.stock)
        except:
            return 0

    def get_total_cost(self):
        """获取总成本"""
        if self.backtest:
            return self._total_cost
        try:
            pos = position_holding_qty(self.stock)
            avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
            return pos * avg_cost
        except:
            return 0.0

    def get_avg_cost(self):
        """获取平均成本"""
        if self.backtest:
            return self._total_cost / self._position if self._position > 0 else 0.0
        try:
            return position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
        except:
            return 0.0