class Strategy(StrategyBase):
    """免费DCA定投策略 - Moomoo公开版
    
    专为解决Moomoo用户定投痛点设计的开源策略
    - 固定周期智能定投 (每周)
    - 基础回撤监控提醒
    - 完善的风险控制
    - 支持回测和实盘
    
    💡 付费版(¥35/月)特性:
    - 每日定投 (+4.1%收益优势)
    - 3层智能加仓系统
    - 自定义资金和周期
    - 专属客服支持
    """

    def initialize(self):
        """初始化策略"""
        try:
            self._version = "v1.0-Free-Stable"
            self._tier = "免费稳定版"
            self._description = (
                "🆓 免费DCA定投策略 - 稳定版本\n"
                "✅ 每周固定定投 (经验证的稳定策略)\n" 
                "✅ 基础回撤监控和风险提醒\n"
                "✅ 完善的资金保护机制\n"
                "✅ 简化参数，一键启用\n"
                "💡 付费版(¥35/月): 每日定投+智能加仓(+4.1%收益)\n"
                "🚀 未来APP: AI分析+组合管理+高级功能"
            )
            
            self.trigger_symbols()
            self.custom_indicator()
            self.global_variables()
            self.setup_presets()
            self.print_welcome()
            
            # 免费版固定参数
            self.version_tier = 1  # 固定免费版
            self.interval_min = 10080  # 固定每周 (7天 * 24小时 * 60分钟)
            self.drawdown_layers = [5.0, 10.0, 20.0]  # 3层回撤阈值
            self.extreme_drawdown_pct = 50.0  # 极端回撤保护
            
            # 核心状态变量
            self.last_investment_time = None
            self.highest_price = None
            self.last_valid_price = 100.0  # 默认价格
            self.strategy_start_price = None  # 策略启动价格
            
            # 回测支持
            import collections
            self.high_queue = collections.deque(maxlen=20)
            if self.backtest:
                self.initial_balance = total_cash(currency=Currency.USD)
                self.virtual_balance = self.initial_balance
            else:
                self.virtual_balance = None
            self._position = 0
            self._total_cost = 0.0
            
        except Exception as e:
            print(f"❌ 初始化失败: {str(e)}")

    def trigger_symbols(self):
        """设置交易标的"""
        try:
            self.stock = declare_trig_symbol()
            print(f"📈 交易标的: {self.stock}")
        except Exception as e:
            print(f"❌ 标的设置失败: {str(e)}")

    def custom_indicator(self):
        """注册自定义技术指标"""
        try:
            # 注册一个简单的移动平均线指标供参考
            self.register_indicator(
                indicator_name='MA',
                script='MA5:MA(CLOSE,5),COLORFF8D1E;',
                param_list=[]
            )
            print("📊 技术指标注册完成")
        except Exception as e:
            print(f"❌ 技术指标注册失败: {str(e)}")

    def global_variables(self):
        """全局变量设置 - 免费稳定版参数"""
        try:
            # === 核心参数 (简化配置) ===
            self.qty = show_variable(20, GlobalType.INT)  # 每次定投股数(10-50)
            self.backtest = show_variable(True, GlobalType.BOOL)  # 回测模式
            
            # === 风险控制开关 ===
            self.enable_risk_alerts = show_variable(True, GlobalType.BOOL)  # 风险提醒
            self.conservative_mode = show_variable(False, GlobalType.BOOL)  # 保守模式(仅10股)
            
            print(f"⚙️ 免费版参数配置完成")
            
        except Exception as e:
            print(f"❌ 参数设置失败: {str(e)}")

    def setup_presets(self):
        """设置固定配置 - 免费稳定版"""
        # 免费版固定配置，专注稳定性
        self.preset_name = "稳定每周定投"
        self.preset_desc = "经验证的稳定策略，每周定投"
        self.risk_level = "中低"
        
        # 参数验证和调整
        if self.conservative_mode:
            if self.qty != 10:
                print(f"💡 保守模式：投资数量调整为10股")
                self.qty = 10
        else:
            # 标准模式参数验证
            if self.qty < 10 or self.qty > 50 or self.qty % 10 != 0:
                print(f"⚠️ 参数调整：投资数量 {self.qty} → 20股 (必须是10的倍数，范围10-50)")
                self.qty = 20

    def print_welcome(self):
        """打印欢迎信息 - 免费稳定版"""
        print("\n" + "="*50)
        print(f"🚀 DCA定投策略 {self._version}")
        print("="*50)
        print(f"🆓 免费稳定版 - 专注稳定性")
        
        print("\n📊 当前配置:")
        print(f"   策略版本: 免费稳定版")
        print(f"   定投数量: {self.qty}股")
        print(f"   投资周期: 每周 (固定)")
        print(f"   风险级别: {self.risk_level}")
        if hasattr(self, 'virtual_balance') and self.virtual_balance:
            print(f"   管理资金: ${self.virtual_balance:,.0f}")
        print(f"   运行模式: {'回测' if self.backtest else '实盘'}")
        
        print("\n🎯 升级路径:")
        print("   💎 付费版(¥35/月): 每日定投+智能加仓 → +4.1%收益")
        print("   🚀 未来APP: AI分析+组合管理+社区功能")
        print("   📱 联系作者了解升级详情")
        
        print("="*50 + "\n")

    def handle_data(self):
        """主要交易逻辑 - 免费版"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            latest_price, highest_price, account_balance = self.get_market_data()
            
            # 计算回撤和持仓信息
            drawdown = self.calculate_drawdown(latest_price)
            position = self.get_position()
            
            print(f"📊 价格={latest_price:.2f}, 回撤={drawdown:.2f}%, 持仓={position}")

            # 免费版逻辑
            self.free_version_logic(current_time, latest_price, account_balance, drawdown)

        except Exception as e:
            import traceback
            error_msg = str(e) if str(e) else "未知错误"
            print(f"❌ 策略执行错误: {error_msg}")
            print(f"错误详情: {traceback.format_exc()}")

    def get_market_data(self):
        """获取市场数据"""
        if self.backtest:
            # 回测模式
            try:
                if not hasattr(self, 'bar_index'):
                    self.bar_index = 0
                self.bar_index += 1
                
                latest_price = bar_close(self.stock, bar_type=BarType.D1, select=1)
                if latest_price is None or latest_price <= 0:
                    latest_price = self.last_valid_price
                else:
                    self.last_valid_price = latest_price
                
                self.high_queue.append(latest_price)
                
                # 计算最近20日最高价
                available_days = self.bar_index if self.bar_index < 20 else 20
                high_list = list(self.high_queue)[-available_days:]
                if len(high_list) == 0:
                    highest_price = latest_price
                else:
                    highest_price = high_list[0]
                    for price in high_list[1:]:
                        if price > highest_price:
                            highest_price = price
                
                account_balance = self.virtual_balance
                return latest_price, highest_price, account_balance
            except Exception as e:
                print(f"回测数据获取错误: {str(e)}")
                return self.last_valid_price, self.last_valid_price, self.virtual_balance
        else:
            # 实盘模式
            latest_price = current_price(self.stock, price_type=THType.FTH)
            if latest_price is None or latest_price <= 0:
                latest_price = self.last_valid_price
            else:
                self.last_valid_price = latest_price
            
            high_list = [bar_high(self.stock, bar_type=BarType.D1, select=i) for i in range(1, 21)]
            valid_highs = [h for h in high_list if h is not None and h > 0]
            if len(valid_highs) == 0:
                highest_price = latest_price
            else:
                highest_price = valid_highs[0]
                for price in valid_highs[1:]:
                    if price > highest_price:
                        highest_price = price
            
            account_balance = total_cash(currency=Currency.USD)
            return latest_price, highest_price, account_balance

    def calculate_drawdown(self, latest_price):
        """计算回撤幅度"""
        # 初始化策略启动价格和最高价
        if self.strategy_start_price is None:
            self.strategy_start_price = latest_price
            self.highest_price = latest_price
            return 0.0
            
        # 更新最高价
        if latest_price > self.highest_price:
            self.highest_price = latest_price
        
        # 计算当前回撤
        if self.highest_price > 0:
            drawdown = (self.highest_price - latest_price) / self.highest_price * 100
        else:
            drawdown = 0.0
            
        return drawdown

    def should_invest(self, current_time):
        """判断是否应该定投"""
        if self.last_investment_time is None:
            return True
        elapsed = (current_time - self.last_investment_time).total_seconds() / 60
        return elapsed >= self.interval_min

    def free_version_logic(self, current_time, latest_price, account_balance, drawdown):
        """免费版策略逻辑 - 稳定定投 + 基础风险提醒"""
        
        # 简化的风险提醒 (仅在启用时)
        if self.enable_risk_alerts and drawdown >= 10.0:
            print(f"⚠️ 市场回撤{drawdown:.1f}% | 付费版可自动加仓保护")
            
        # 固定周期定投 (每周)
        if self.should_invest(current_time):
            trade_type = "保守定投" if self.conservative_mode else "稳定定投"
            self.execute_investment(latest_price, account_balance, self.qty, trade_type)

    def execute_investment(self, latest_price, account_balance, quantity, trade_type="定投"):
        """执行投资 - 免费版"""
        # 免费版参数检查: 必须是10的倍数
        if quantity < 10 or quantity > 100 or quantity % 10 != 0:
            print(f"⚠️ 免费版参数限制: 投资数量调整为20股 (必须是10的倍数，范围10-100)")
            quantity = 20

        if self.backtest:
            # 回测模式
            required_cash = quantity * latest_price
            if required_cash > self.virtual_balance:
                # 资金不足，自动调整投资数量
                original_qty = quantity
                max_qty = int(self.virtual_balance // latest_price)
                max_qty = (max_qty // 10) * 10  # 调整为10的倍数
                if max_qty < 10:
                    print(f"💰 虚拟余额不足，无法购买10股: 需要${required_cash:.2f}, 可用${self.virtual_balance:.2f}")
                    return
                quantity = max_qty
                required_cash = quantity * latest_price
                print(f"⚠️ 资金调整: 原计划买{original_qty}股，调整为{quantity}股")
            
            # 调用place_market产生GUI交易打点
            order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
            
            print(f"📊 {trade_type}: {quantity}股 @ ${latest_price:.2f} | 订单:{order_id}")
            
            # 更新虚拟账户
            self.virtual_balance -= required_cash
            self._total_cost += required_cash
            self._position += quantity
            
            print(f"💰 余额: ${self.virtual_balance:.2f} | 持仓: {self._position}股")
            
        else:
            # 实盘模式
            required_cash = quantity * latest_price
            if required_cash > account_balance:
                # 资金不足，按可用资金调整数量
                max_qty = int((account_balance // latest_price) // 10 * 10)
                if max_qty < 10:
                    print(f"💰 资金不足，无法投资")
                    return
                quantity = max_qty
                print(f"⚠️ 资金调整: 投资数量调整为 {quantity}股")

            try:
                # 使用市价买入确保成交
                order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
                print(f"✅ {trade_type}订单: {quantity}股 @ 市价, 订单号: {order_id}")
            except Exception as e:
                print(f"❌ 下单失败: {str(e)}")
                return

        self.last_investment_time = device_time(TimeZone.DEVICE_TIME_ZONE)

    def get_position(self):
        """获取持仓数量"""
        if self.backtest:
            return self._position
        try:
            return position_holding_qty(self.stock)
        except:
            return 0

    def get_total_cost(self):
        """获取总成本"""
        if self.backtest:
            return self._total_cost
        try:
            pos = position_holding_qty(self.stock)
            avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
            return pos * avg_cost
        except:
            return 0.0

    def get_avg_cost(self):
        """获取平均成本"""
        if self.backtest:
            return self._total_cost / self._position if self._position > 0 else 0.0
        try:
            return position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
        except:
            return 0.0