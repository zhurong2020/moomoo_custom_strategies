class Strategy(StrategyBase):
    """å…è´¹DCAå®šæŠ•ç­–ç•¥ - Moomooå…¬å¼€ç‰ˆ
    
    ä¸“ä¸ºè§£å†³Moomooç”¨æˆ·å®šæŠ•ç—›ç‚¹è®¾è®¡çš„å¼€æºç­–ç•¥
    - å›ºå®šå‘¨æœŸæ™ºèƒ½å®šæŠ• (æ¯å‘¨)
    - åŸºç¡€å›æ’¤ç›‘æ§æé†’
    - å®Œå–„çš„é£é™©æ§åˆ¶
    - æ”¯æŒå›æµ‹å’Œå®ç›˜
    
    ğŸ’¡ ä»˜è´¹ç‰ˆ(Â¥35/æœˆ)ç‰¹æ€§:
    - æ¯æ—¥å®šæŠ• (+4.1%æ”¶ç›Šä¼˜åŠ¿)
    - 3å±‚æ™ºèƒ½åŠ ä»“ç³»ç»Ÿ
    - è‡ªå®šä¹‰èµ„é‡‘å’Œå‘¨æœŸ
    - ä¸“å±å®¢æœæ”¯æŒ
    """

    def initialize(self):
        """åˆå§‹åŒ–ç­–ç•¥"""
        try:
            self._version = "v1.0-Free-Stable"
            self._tier = "å…è´¹ç¨³å®šç‰ˆ"
            self._description = (
                "ğŸ†“ å…è´¹DCAå®šæŠ•ç­–ç•¥ - ç¨³å®šç‰ˆæœ¬\n"
                "âœ… æ¯å‘¨å›ºå®šå®šæŠ• (ç»éªŒè¯çš„ç¨³å®šç­–ç•¥)\n" 
                "âœ… åŸºç¡€å›æ’¤ç›‘æ§å’Œé£é™©æé†’\n"
                "âœ… å®Œå–„çš„èµ„é‡‘ä¿æŠ¤æœºåˆ¶\n"
                "âœ… ç®€åŒ–å‚æ•°ï¼Œä¸€é”®å¯ç”¨\n"
                "ğŸ’¡ ä»˜è´¹ç‰ˆ(Â¥35/æœˆ): æ¯æ—¥å®šæŠ•+æ™ºèƒ½åŠ ä»“(+4.1%æ”¶ç›Š)\n"
                "ğŸš€ æœªæ¥APP: AIåˆ†æ+ç»„åˆç®¡ç†+é«˜çº§åŠŸèƒ½"
            )
            
            self.trigger_symbols()
            self.custom_indicator()
            self.global_variables()
            self.setup_presets()
            self.print_welcome()
            
            # å…è´¹ç‰ˆå›ºå®šå‚æ•°
            self.version_tier = 1  # å›ºå®šå…è´¹ç‰ˆ
            self.interval_min = 10080  # å›ºå®šæ¯å‘¨ (7å¤© * 24å°æ—¶ * 60åˆ†é’Ÿ)
            self.drawdown_layers = [5.0, 10.0, 20.0]  # 3å±‚å›æ’¤é˜ˆå€¼
            self.extreme_drawdown_pct = 50.0  # æç«¯å›æ’¤ä¿æŠ¤
            
            # æ ¸å¿ƒçŠ¶æ€å˜é‡
            self.last_investment_time = None
            self.highest_price = None
            self.last_valid_price = 100.0  # é»˜è®¤ä»·æ ¼
            self.strategy_start_price = None  # ç­–ç•¥å¯åŠ¨ä»·æ ¼
            
            # å›æµ‹æ”¯æŒ
            import collections
            self.high_queue = collections.deque(maxlen=20)
            if self.backtest:
                self.initial_balance = total_cash(currency=Currency.USD)
                self.virtual_balance = self.initial_balance
            else:
                self.virtual_balance = None
            self._position = 0
            self._total_cost = 0.0
            
        except Exception as e:
            print(f"âŒ åˆå§‹åŒ–å¤±è´¥: {str(e)}")

    def trigger_symbols(self):
        """è®¾ç½®äº¤æ˜“æ ‡çš„"""
        try:
            self.stock = declare_trig_symbol()
            print(f"ğŸ“ˆ äº¤æ˜“æ ‡çš„: {self.stock}")
        except Exception as e:
            print(f"âŒ æ ‡çš„è®¾ç½®å¤±è´¥: {str(e)}")

    def custom_indicator(self):
        """æ³¨å†Œè‡ªå®šä¹‰æŠ€æœ¯æŒ‡æ ‡"""
        try:
            # æ³¨å†Œä¸€ä¸ªç®€å•çš„ç§»åŠ¨å¹³å‡çº¿æŒ‡æ ‡ä¾›å‚è€ƒ
            self.register_indicator(
                indicator_name='MA',
                script='MA5:MA(CLOSE,5),COLORFF8D1E;',
                param_list=[]
            )
            print("ğŸ“Š æŠ€æœ¯æŒ‡æ ‡æ³¨å†Œå®Œæˆ")
        except Exception as e:
            print(f"âŒ æŠ€æœ¯æŒ‡æ ‡æ³¨å†Œå¤±è´¥: {str(e)}")

    def global_variables(self):
        """å…¨å±€å˜é‡è®¾ç½® - å…è´¹ç¨³å®šç‰ˆå‚æ•°"""
        try:
            # === æ ¸å¿ƒå‚æ•° (ç®€åŒ–é…ç½®) ===
            self.qty = show_variable(20, GlobalType.INT)  # æ¯æ¬¡å®šæŠ•è‚¡æ•°(10-50)
            self.backtest = show_variable(True, GlobalType.BOOL)  # å›æµ‹æ¨¡å¼
            
            # === é£é™©æ§åˆ¶å¼€å…³ ===
            self.enable_risk_alerts = show_variable(True, GlobalType.BOOL)  # é£é™©æé†’
            self.conservative_mode = show_variable(False, GlobalType.BOOL)  # ä¿å®ˆæ¨¡å¼(ä»…10è‚¡)
            
            print(f"âš™ï¸ å…è´¹ç‰ˆå‚æ•°é…ç½®å®Œæˆ")
            
        except Exception as e:
            print(f"âŒ å‚æ•°è®¾ç½®å¤±è´¥: {str(e)}")

    def setup_presets(self):
        """è®¾ç½®å›ºå®šé…ç½® - å…è´¹ç¨³å®šç‰ˆ"""
        # å…è´¹ç‰ˆå›ºå®šé…ç½®ï¼Œä¸“æ³¨ç¨³å®šæ€§
        self.preset_name = "ç¨³å®šæ¯å‘¨å®šæŠ•"
        self.preset_desc = "ç»éªŒè¯çš„ç¨³å®šç­–ç•¥ï¼Œæ¯å‘¨å®šæŠ•"
        self.risk_level = "ä¸­ä½"
        
        # å‚æ•°éªŒè¯å’Œè°ƒæ•´
        if self.conservative_mode:
            if self.qty != 10:
                print(f"ğŸ’¡ ä¿å®ˆæ¨¡å¼ï¼šæŠ•èµ„æ•°é‡è°ƒæ•´ä¸º10è‚¡")
                self.qty = 10
        else:
            # æ ‡å‡†æ¨¡å¼å‚æ•°éªŒè¯
            if self.qty < 10 or self.qty > 50 or self.qty % 10 != 0:
                print(f"âš ï¸ å‚æ•°è°ƒæ•´ï¼šæŠ•èµ„æ•°é‡ {self.qty} â†’ 20è‚¡ (å¿…é¡»æ˜¯10çš„å€æ•°ï¼ŒèŒƒå›´10-50)")
                self.qty = 20

    def print_welcome(self):
        """æ‰“å°æ¬¢è¿ä¿¡æ¯ - å…è´¹ç¨³å®šç‰ˆ"""
        print("\n" + "="*50)
        print(f"ğŸš€ DCAå®šæŠ•ç­–ç•¥ {self._version}")
        print("="*50)
        print(f"ğŸ†“ å…è´¹ç¨³å®šç‰ˆ - ä¸“æ³¨ç¨³å®šæ€§")
        
        print("\nğŸ“Š å½“å‰é…ç½®:")
        print(f"   ç­–ç•¥ç‰ˆæœ¬: å…è´¹ç¨³å®šç‰ˆ")
        print(f"   å®šæŠ•æ•°é‡: {self.qty}è‚¡")
        print(f"   æŠ•èµ„å‘¨æœŸ: æ¯å‘¨ (å›ºå®š)")
        print(f"   é£é™©çº§åˆ«: {self.risk_level}")
        if hasattr(self, 'virtual_balance') and self.virtual_balance:
            print(f"   ç®¡ç†èµ„é‡‘: ${self.virtual_balance:,.0f}")
        print(f"   è¿è¡Œæ¨¡å¼: {'å›æµ‹' if self.backtest else 'å®ç›˜'}")
        
        print("\nğŸ¯ å‡çº§è·¯å¾„:")
        print("   ğŸ’ ä»˜è´¹ç‰ˆ(Â¥35/æœˆ): æ¯æ—¥å®šæŠ•+æ™ºèƒ½åŠ ä»“ â†’ +4.1%æ”¶ç›Š")
        print("   ğŸš€ æœªæ¥APP: AIåˆ†æ+ç»„åˆç®¡ç†+ç¤¾åŒºåŠŸèƒ½")
        print("   ğŸ“± è”ç³»ä½œè€…äº†è§£å‡çº§è¯¦æƒ…")
        
        print("="*50 + "\n")

    def handle_data(self):
        """ä¸»è¦äº¤æ˜“é€»è¾‘ - å…è´¹ç‰ˆ"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            latest_price, highest_price, account_balance = self.get_market_data()
            
            # è®¡ç®—å›æ’¤å’ŒæŒä»“ä¿¡æ¯
            drawdown = self.calculate_drawdown(latest_price)
            position = self.get_position()
            
            print(f"ğŸ“Š ä»·æ ¼={latest_price:.2f}, å›æ’¤={drawdown:.2f}%, æŒä»“={position}")

            # å…è´¹ç‰ˆé€»è¾‘
            self.free_version_logic(current_time, latest_price, account_balance, drawdown)

        except Exception as e:
            import traceback
            error_msg = str(e) if str(e) else "æœªçŸ¥é”™è¯¯"
            print(f"âŒ ç­–ç•¥æ‰§è¡Œé”™è¯¯: {error_msg}")
            print(f"é”™è¯¯è¯¦æƒ…: {traceback.format_exc()}")

    def get_market_data(self):
        """è·å–å¸‚åœºæ•°æ®"""
        if self.backtest:
            # å›æµ‹æ¨¡å¼
            try:
                if not hasattr(self, 'bar_index'):
                    self.bar_index = 0
                self.bar_index += 1
                
                latest_price = bar_close(self.stock, bar_type=BarType.D1, select=1)
                if latest_price is None or latest_price <= 0:
                    latest_price = self.last_valid_price
                else:
                    self.last_valid_price = latest_price
                
                self.high_queue.append(latest_price)
                
                # è®¡ç®—æœ€è¿‘20æ—¥æœ€é«˜ä»·
                available_days = self.bar_index if self.bar_index < 20 else 20
                high_list = list(self.high_queue)[-available_days:]
                if len(high_list) == 0:
                    highest_price = latest_price
                else:
                    highest_price = high_list[0]
                    for price in high_list[1:]:
                        if price > highest_price:
                            highest_price = price
                
                account_balance = self.virtual_balance
                return latest_price, highest_price, account_balance
            except Exception as e:
                print(f"å›æµ‹æ•°æ®è·å–é”™è¯¯: {str(e)}")
                return self.last_valid_price, self.last_valid_price, self.virtual_balance
        else:
            # å®ç›˜æ¨¡å¼
            latest_price = current_price(self.stock, price_type=THType.FTH)
            if latest_price is None or latest_price <= 0:
                latest_price = self.last_valid_price
            else:
                self.last_valid_price = latest_price
            
            high_list = [bar_high(self.stock, bar_type=BarType.D1, select=i) for i in range(1, 21)]
            valid_highs = [h for h in high_list if h is not None and h > 0]
            if len(valid_highs) == 0:
                highest_price = latest_price
            else:
                highest_price = valid_highs[0]
                for price in valid_highs[1:]:
                    if price > highest_price:
                        highest_price = price
            
            account_balance = total_cash(currency=Currency.USD)
            return latest_price, highest_price, account_balance

    def calculate_drawdown(self, latest_price):
        """è®¡ç®—å›æ’¤å¹…åº¦"""
        # åˆå§‹åŒ–ç­–ç•¥å¯åŠ¨ä»·æ ¼å’Œæœ€é«˜ä»·
        if self.strategy_start_price is None:
            self.strategy_start_price = latest_price
            self.highest_price = latest_price
            return 0.0
            
        # æ›´æ–°æœ€é«˜ä»·
        if latest_price > self.highest_price:
            self.highest_price = latest_price
        
        # è®¡ç®—å½“å‰å›æ’¤
        if self.highest_price > 0:
            drawdown = (self.highest_price - latest_price) / self.highest_price * 100
        else:
            drawdown = 0.0
            
        return drawdown

    def should_invest(self, current_time):
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥å®šæŠ•"""
        if self.last_investment_time is None:
            return True
        elapsed = (current_time - self.last_investment_time).total_seconds() / 60
        return elapsed >= self.interval_min

    def free_version_logic(self, current_time, latest_price, account_balance, drawdown):
        """å…è´¹ç‰ˆç­–ç•¥é€»è¾‘ - ç¨³å®šå®šæŠ• + åŸºç¡€é£é™©æé†’"""
        
        # ç®€åŒ–çš„é£é™©æé†’ (ä»…åœ¨å¯ç”¨æ—¶)
        if self.enable_risk_alerts and drawdown >= 10.0:
            print(f"âš ï¸ å¸‚åœºå›æ’¤{drawdown:.1f}% | ä»˜è´¹ç‰ˆå¯è‡ªåŠ¨åŠ ä»“ä¿æŠ¤")
            
        # å›ºå®šå‘¨æœŸå®šæŠ• (æ¯å‘¨)
        if self.should_invest(current_time):
            trade_type = "ä¿å®ˆå®šæŠ•" if self.conservative_mode else "ç¨³å®šå®šæŠ•"
            self.execute_investment(latest_price, account_balance, self.qty, trade_type)

    def execute_investment(self, latest_price, account_balance, quantity, trade_type="å®šæŠ•"):
        """æ‰§è¡ŒæŠ•èµ„ - å…è´¹ç‰ˆ"""
        # å…è´¹ç‰ˆå‚æ•°æ£€æŸ¥: å¿…é¡»æ˜¯10çš„å€æ•°
        if quantity < 10 or quantity > 100 or quantity % 10 != 0:
            print(f"âš ï¸ å…è´¹ç‰ˆå‚æ•°é™åˆ¶: æŠ•èµ„æ•°é‡è°ƒæ•´ä¸º20è‚¡ (å¿…é¡»æ˜¯10çš„å€æ•°ï¼ŒèŒƒå›´10-100)")
            quantity = 20

        if self.backtest:
            # å›æµ‹æ¨¡å¼
            required_cash = quantity * latest_price
            if required_cash > self.virtual_balance:
                # èµ„é‡‘ä¸è¶³ï¼Œè‡ªåŠ¨è°ƒæ•´æŠ•èµ„æ•°é‡
                original_qty = quantity
                max_qty = int(self.virtual_balance // latest_price)
                max_qty = (max_qty // 10) * 10  # è°ƒæ•´ä¸º10çš„å€æ•°
                if max_qty < 10:
                    print(f"ğŸ’° è™šæ‹Ÿä½™é¢ä¸è¶³ï¼Œæ— æ³•è´­ä¹°10è‚¡: éœ€è¦${required_cash:.2f}, å¯ç”¨${self.virtual_balance:.2f}")
                    return
                quantity = max_qty
                required_cash = quantity * latest_price
                print(f"âš ï¸ èµ„é‡‘è°ƒæ•´: åŸè®¡åˆ’ä¹°{original_qty}è‚¡ï¼Œè°ƒæ•´ä¸º{quantity}è‚¡")
            
            # è°ƒç”¨place_marketäº§ç”ŸGUIäº¤æ˜“æ‰“ç‚¹
            order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
            
            print(f"ğŸ“Š {trade_type}: {quantity}è‚¡ @ ${latest_price:.2f} | è®¢å•:{order_id}")
            
            # æ›´æ–°è™šæ‹Ÿè´¦æˆ·
            self.virtual_balance -= required_cash
            self._total_cost += required_cash
            self._position += quantity
            
            print(f"ğŸ’° ä½™é¢: ${self.virtual_balance:.2f} | æŒä»“: {self._position}è‚¡")
            
        else:
            # å®ç›˜æ¨¡å¼
            required_cash = quantity * latest_price
            if required_cash > account_balance:
                # èµ„é‡‘ä¸è¶³ï¼ŒæŒ‰å¯ç”¨èµ„é‡‘è°ƒæ•´æ•°é‡
                max_qty = int((account_balance // latest_price) // 10 * 10)
                if max_qty < 10:
                    print(f"ğŸ’° èµ„é‡‘ä¸è¶³ï¼Œæ— æ³•æŠ•èµ„")
                    return
                quantity = max_qty
                print(f"âš ï¸ èµ„é‡‘è°ƒæ•´: æŠ•èµ„æ•°é‡è°ƒæ•´ä¸º {quantity}è‚¡")

            try:
                # ä½¿ç”¨å¸‚ä»·ä¹°å…¥ç¡®ä¿æˆäº¤
                order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
                print(f"âœ… {trade_type}è®¢å•: {quantity}è‚¡ @ å¸‚ä»·, è®¢å•å·: {order_id}")
            except Exception as e:
                print(f"âŒ ä¸‹å•å¤±è´¥: {str(e)}")
                return

        self.last_investment_time = device_time(TimeZone.DEVICE_TIME_ZONE)

    def get_position(self):
        """è·å–æŒä»“æ•°é‡"""
        if self.backtest:
            return self._position
        try:
            return position_holding_qty(self.stock)
        except:
            return 0

    def get_total_cost(self):
        """è·å–æ€»æˆæœ¬"""
        if self.backtest:
            return self._total_cost
        try:
            pos = position_holding_qty(self.stock)
            avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
            return pos * avg_cost
        except:
            return 0.0

    def get_avg_cost(self):
        """è·å–å¹³å‡æˆæœ¬"""
        if self.backtest:
            return self._total_cost / self._position if self._position > 0 else 0.0
        try:
            return position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
        except:
            return 0.0