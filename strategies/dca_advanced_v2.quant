class Strategy(StrategyBase):
    """ç¬¬äºŒå±‚ï¼šä»˜è´¹è¿›é˜¶å®šæŠ•ç­–ç•¥
    
    ä¸ºä»˜è´¹ç”¨æˆ·æä¾›çš„å¢å¼ºç‰ˆå®šæŠ•ç­–ç•¥
    - å®Œæ•´8å±‚å›æ’¤åŠ ä»“ç³»ç»Ÿ
    - åŸºç¡€æˆæœ¬å®šæŠ•ç®—æ³•
    - æ³¢åŠ¨ç‡æ„ŸçŸ¥è°ƒæ•´
    - é«˜çº§ç»Ÿè®¡åˆ†æ
    - è¯¦ç»†æ—¥å¿—å’Œç›‘æ§
    """

    def initialize(self):
        """åˆå§‹åŒ–ç­–ç•¥"""
        try:
            self._version = "v2.0.0-Advanced"
            self._tier = "ä»˜è´¹è¿›é˜¶ç‰ˆ"
            self._description = (
                "ğŸ’ ä»˜è´¹è¿›é˜¶å®šæŠ•ç­–ç•¥ - ä¸“ä¸šçº§å®šæŠ•è§£å†³æ–¹æ¡ˆ\n"
                "âœ… å®Œæ•´8å±‚å›æ’¤åŠ ä»“ (1x-4.5xå€æ•°)\n"
                "âœ… åŸºç¡€æˆæœ¬å®šæŠ•ç®—æ³•\n"  
                "âœ… æ³¢åŠ¨ç‡æ„ŸçŸ¥æ™ºèƒ½è°ƒæ•´\n"
                "âœ… é«˜çº§é£æ§å’Œç»Ÿè®¡åˆ†æ\n"
                "âœ… è¯¦ç»†ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ\n"
                "ğŸ”¥ VIPç‰ˆæ”¯æŒ11å±‚æˆæœ¬å®šæŠ•+å¤šæ ‡çš„ç»„åˆ"
            )
            
            self.trigger_symbols()
            self.global_variables()
            self.setup_advanced_features()
            self.print_welcome()
            
            # é«˜çº§çŠ¶æ€å˜é‡
            self.current_drawdown_layer = 0
            self.last_investment_time = None
            self.highest_price = None
            self.cost_base_price = None  # æˆæœ¬å®šæŠ•åŸºå‡†ä»·
            self.volatility_history = []
            
            # ç»Ÿè®¡å˜é‡
            self.total_investments = 0
            self.total_add_positions = 0
            self.layer_triggers = [0] * 8  # è®°å½•å„å±‚è§¦å‘æ¬¡æ•°
            
            # å›æµ‹æ”¯æŒ
            import collections
            self.high_queue = collections.deque(maxlen=50)  # å¢åŠ å†å²æ•°æ®
            self.price_queue = collections.deque(maxlen=20)  # ä»·æ ¼é˜Ÿåˆ—ç”¨äºæ³¢åŠ¨ç‡è®¡ç®—
            self.virtual_balance = 1e6 if self.backtest else None
            self._position = 0
            self._total_cost = 0.0
            
        except Exception as e:
            print(f"âŒ åˆå§‹åŒ–å¤±è´¥: {str(e)}")

    def trigger_symbols(self):
        """è®¾ç½®äº¤æ˜“æ ‡çš„"""
        try:
            self.stock = declare_trig_symbol()
            print(f"ğŸ“ˆ äº¤æ˜“æ ‡çš„: {self.stock}")
        except Exception as e:
            print(f"âŒ æ ‡çš„è®¾ç½®å¤±è´¥: {str(e)}")

    def global_variables(self):
        """é«˜çº§å‚æ•°é…ç½®"""
        try:
            # åŸºç¡€å®šæŠ•å‚æ•°
            self.qty = show_variable(20, GlobalType.INT)  # åŸºç¡€æŠ•èµ„æ•°é‡
            self.interval_min = show_variable(1440, GlobalType.INT)  # å®šæŠ•å‘¨æœŸ
            
            # é«˜çº§å®šæŠ•æ¨¡å¼é€‰æ‹©
            self.dca_mode = show_variable(1, GlobalType.INT)  # 1=å†å²æœ€é«˜ä»·å›æ’¤ 2=æˆæœ¬å®šæŠ•
            self.volatility_adjust = show_variable(True, GlobalType.BOOL)  # æ³¢åŠ¨ç‡è°ƒæ•´
            
            # å›æ’¤åŠ ä»“å‚æ•° (8å±‚å®Œæ•´ç‰ˆ)
            self.base_drawdown_pct = show_variable(5.0, GlobalType.FLOAT)  # åŸºç¡€å›æ’¤é˜ˆå€¼
            self.layer_interval = show_variable(5.0, GlobalType.FLOAT)  # å±‚çº§é—´éš”
            
            # é«˜çº§é£æ§å‚æ•°
            self.extreme_drawdown_pct = show_variable(60.0, GlobalType.FLOAT)  # æç«¯å›æ’¤ä¿æŠ¤
            self.max_position_limit = show_variable(10000, GlobalType.INT)  # æœ€å¤§æŒä»“é™åˆ¶
            self.daily_invest_limit = show_variable(5, GlobalType.INT)  # æ¯æ—¥æœ€å¤§æŠ•èµ„æ¬¡æ•°
            
            # åŠŸèƒ½å¼€å…³
            self.backtest = show_variable(True, GlobalType.BOOL)
            self.detailed_log = show_variable(True, GlobalType.BOOL)  # è¯¦ç»†æ—¥å¿—
            self.risk_alert = show_variable(True, GlobalType.BOOL)  # é£é™©é¢„è­¦
            
            # å›ºå®šé«˜çº§é…ç½®
            self.drawdown_layers = [5, 10, 15, 20, 30, 40, 50, 60]  # 8å±‚å›æ’¤é˜ˆå€¼
            self.drawdown_multipliers = [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5]  # å¯¹åº”å€æ•°
            self.daily_invest_count = 0
            self.last_reset_day = None
            
            print(f"âš™ï¸ é«˜çº§å‚æ•°é…ç½®å®Œæˆ")
            
        except Exception as e:
            print(f"âŒ å‚æ•°è®¾ç½®å¤±è´¥: {str(e)}")

    def setup_advanced_features(self):
        """è®¾ç½®é«˜çº§åŠŸèƒ½"""
        # æˆæœ¬å®šæŠ•æ¨¡å¼è¯´æ˜
        self.dca_modes = {
            1: {
                "name": "å†å²æœ€é«˜ä»·å›æ’¤æ¨¡å¼",
                "description": "åŸºäºå†å²æœ€é«˜ä»·è®¡ç®—å›æ’¤ï¼Œç»å…¸æ¨¡å¼"
            },
            2: {
                "name": "æŒä»“æˆæœ¬å®šæŠ•æ¨¡å¼", 
                "description": "åŸºäºæŒä»“æˆæœ¬è®¡ç®—ç›¸å¯¹æ¶¨è·Œï¼Œé™ä½é«˜ä½é£é™©"
            }
        }
        
        self.current_mode = self.dca_modes.get(self.dca_mode, self.dca_modes[1])

    def print_welcome(self):
        """æ‰“å°æ¬¢è¿ä¿¡æ¯"""
        print("\n" + "="*70)
        print(f"ğŸš€ {self._tier} {self._version}")
        print("="*70)
        print(self._description)
        print(f"\nğŸ“Š é«˜çº§é…ç½®:")
        print(f"   å®šæŠ•æ¨¡å¼: {self.current_mode['name']}")
        print(f"   åŸºç¡€æ•°é‡: {self.qty}è‚¡")
        print(f"   å®šæŠ•å‘¨æœŸ: {self.interval_min}åˆ†é’Ÿ")
        print(f"   å›æ’¤ç³»ç»Ÿ: {len(self.drawdown_layers)}å±‚ {self.drawdown_layers}%")
        print(f"   å€æ•°è®¾ç½®: {self.drawdown_multipliers}")
        print(f"   æ³¢åŠ¨ç‡è°ƒæ•´: {'å¼€å¯' if self.volatility_adjust else 'å…³é—­'}")
        print(f"   é£é™©é¢„è­¦: {'å¼€å¯' if self.risk_alert else 'å…³é—­'}")
        print(f"   è¯¦ç»†æ—¥å¿—: {'å¼€å¯' if self.detailed_log else 'å…³é—­'}")
        print(f"   è¿è¡Œæ¨¡å¼: {'å›æµ‹' if self.backtest else 'å®ç›˜'}")
        print("\nğŸ”¥ VIPç‰ˆæœ¬åŠŸèƒ½é¢„å‘Š:")
        print("   - 11å±‚ç²¾ç»†åŒ–æˆæœ¬å®šæŠ•ç®—æ³•")
        print("   - å¤šæ ‡çš„ç»„åˆå®šæŠ•")
        print("   - AIæ™ºèƒ½å‚æ•°ä¼˜åŒ–")
        print("   - VPSè‡ªåŠ¨åŒ–éƒ¨ç½²")
        print("="*70 + "\n")

    def handle_data(self):
        """ä¸»è¦äº¤æ˜“é€»è¾‘"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            latest_price, highest_price, account_balance = self.get_market_data()
            
            # é‡ç½®æ¯æ—¥è®¡æ•°å™¨
            self.reset_daily_counters(current_time)
            
            # æ›´æ–°ä»·æ ¼å†å²ç”¨äºæ³¢åŠ¨ç‡è®¡ç®—
            self.price_queue.append(latest_price)
            
            # è®¡ç®—å›æ’¤å’Œæˆæœ¬ç›¸å…³æ•°æ®
            drawdown = self.calculate_drawdown(latest_price)
            cost_deviation = self.calculate_cost_deviation(latest_price)
            volatility = self.calculate_volatility()
            
            # è·å–æŒä»“ä¿¡æ¯
            position = self.get_position()
            total_cost = self.get_total_cost()
            average_cost = self.get_avg_cost()
            market_value = position * latest_price
            profit = market_value - total_cost
            profit_pct = (profit / total_cost * 100) if total_cost > 0 else 0
            
            # è¯¦ç»†æ—¥å¿—
            if self.detailed_log:
                print(f"ğŸ“Š è¯¦ç»†æ•°æ®: ä»·æ ¼={latest_price:.2f}, å†å²æœ€é«˜={highest_price:.2f}")
                print(f"   å›æ’¤={drawdown:.2f}%, æˆæœ¬åç¦»={cost_deviation:.2f}%, æ³¢åŠ¨ç‡={volatility:.4f}")
                print(f"   æŒä»“={position}, æˆæœ¬=${average_cost:.2f}, å¸‚å€¼=${market_value:.2f}, ç›ˆäº={profit_pct:.2f}%")

            # æ£€æŸ¥æŠ•èµ„æ¬¡æ•°é™åˆ¶
            if self.daily_invest_count >= self.daily_invest_limit:
                if self.detailed_log:
                    print(f"â¸ï¸ ä»Šæ—¥æŠ•èµ„æ¬¡æ•°å·²è¾¾ä¸Šé™ ({self.daily_invest_limit}æ¬¡)")
                return

            # é£é™©é¢„è­¦æ£€æŸ¥
            if self.risk_alert:
                self.check_risk_alerts(drawdown, profit_pct, position)

            # æç«¯å›æ’¤ä¿æŠ¤
            if drawdown >= self.extreme_drawdown_pct:
                print(f"ğŸ›¡ï¸ æç«¯å›æ’¤ä¿æŠ¤: {drawdown:.2f}% >= {self.extreme_drawdown_pct}%")
                if self.should_invest(current_time):
                    self.execute_investment(latest_price, account_balance, self.qty, "æç«¯å›æ’¤ä¿æŠ¤-ä»…å®šæŠ•", volatility)
                return

            # é€‰æ‹©å®šæŠ•æ¨¡å¼
            if self.dca_mode == 2:
                # æˆæœ¬å®šæŠ•æ¨¡å¼
                add_qty = self.calculate_cost_based_qty(cost_deviation, volatility)
            else:
                # å†å²æœ€é«˜ä»·å›æ’¤æ¨¡å¼
                add_qty = self.calculate_drawdown_based_qty(drawdown, volatility)

            # æ‰§è¡ŒåŠ ä»“é€»è¾‘
            if add_qty > 0:
                self.execute_investment(latest_price, account_balance, add_qty, "æ™ºèƒ½åŠ ä»“", volatility)
                return

            # å¸¸è§„å®šæŠ•
            if self.should_invest(current_time):
                final_qty = self.apply_volatility_adjustment(self.qty, volatility) if self.volatility_adjust else self.qty
                self.execute_investment(latest_price, account_balance, final_qty, "å®šæœŸå®šæŠ•", volatility)

        except Exception as e:
            print(f"âŒ ç­–ç•¥æ‰§è¡Œé”™è¯¯: {str(e)}")

    def get_market_data(self):
        """è·å–å¸‚åœºæ•°æ® - å¢å¼ºç‰ˆ"""
        if self.backtest:
            # å›æµ‹æ¨¡å¼ - æ›´å¤šå†å²æ•°æ®
            if not hasattr(self, 'bar_index'):
                self.bar_index = 1
            else:
                self.bar_index += 1
                
            latest_price = bar_close(self.stock, bar_type=BarType.D1, select=1)
            self.high_queue.append(latest_price)
            
            available_days = min(self.bar_index, 50)
            high_list = list(self.high_queue)[-available_days:]
            highest_price = max(high_list) if high_list else latest_price
            
            account_balance = self.virtual_balance
            return latest_price, highest_price, account_balance
        else:
            # å®ç›˜æ¨¡å¼ - è·å–æ›´é•¿å†å²
            latest_price = current_price(self.stock, price_type=THType.FTH)
            high_list = [bar_high(self.stock, bar_type=BarType.D1, select=i) for i in range(1, 51)]
            highest_price = max([h for h in high_list if h is not None]) if high_list else latest_price
            account_balance = total_cash(currency=Currency.USD)
            return latest_price, highest_price, account_balance

    def calculate_drawdown(self, latest_price):
        """è®¡ç®—å›æ’¤å¹…åº¦"""
        if self.highest_price is None:
            self.highest_price = latest_price
        self.highest_price = max(self.highest_price, latest_price)
        return (self.highest_price - latest_price) / self.highest_price * 100

    def calculate_cost_deviation(self, latest_price):
        """è®¡ç®—ç›¸å¯¹æŒä»“æˆæœ¬çš„åç¦»åº¦ - æˆæœ¬å®šæŠ•æ ¸å¿ƒ"""
        avg_cost = self.get_avg_cost()
        if avg_cost <= 0:
            return 0
        return (latest_price - avg_cost) / avg_cost * 100

    def calculate_volatility(self):
        """è®¡ç®—æ³¢åŠ¨ç‡"""
        if len(self.price_queue) < 5:
            return 0.02  # é»˜è®¤æ³¢åŠ¨ç‡
            
        prices = list(self.price_queue)
        returns = [(prices[i] - prices[i-1]) / prices[i-1] for i in range(1, len(prices))]
        
        if not returns:
            return 0.02
            
        # è®¡ç®—æ ‡å‡†å·®ä½œä¸ºæ³¢åŠ¨ç‡
        mean_return = sum(returns) / len(returns)
        variance = sum([(r - mean_return) ** 2 for r in returns]) / len(returns)
        volatility = variance ** 0.5
        
        # è®°å½•æ³¢åŠ¨ç‡å†å²
        self.volatility_history.append(volatility)
        if len(self.volatility_history) > 20:
            self.volatility_history.pop(0)
            
        return volatility

    def calculate_drawdown_based_qty(self, drawdown, volatility):
        """åŸºäºå†å²æœ€é«˜ä»·å›æ’¤çš„åŠ ä»“è®¡ç®— - 8å±‚å®Œæ•´ç‰ˆ"""
        for i, threshold in enumerate(self.drawdown_layers):
            if drawdown >= threshold:
                # æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨è¿™ä¸ªå±‚çº§åŠ è¿‡ä»“
                if i <= self.current_drawdown_layer:
                    continue
                    
                # è§¦å‘æ–°çš„åŠ ä»“å±‚çº§
                self.current_drawdown_layer = i
                base_multiplier = self.drawdown_multipliers[i]
                
                # æ³¢åŠ¨ç‡è°ƒæ•´
                vol_multiplier = 1.0
                if self.volatility_adjust and volatility > 0.03:  # é«˜æ³¢åŠ¨æ—¶å‡å°‘æŠ•èµ„
                    vol_multiplier = max(0.5, 1.0 - (volatility - 0.03) * 10)
                
                final_qty = int(self.qty * base_multiplier * vol_multiplier)
                
                # è®°å½•å±‚çº§è§¦å‘
                self.layer_triggers[i] += 1
                
                if self.detailed_log:
                    print(f"ğŸ¯ å›æ’¤åŠ ä»“: ç¬¬{i+1}å±‚({threshold}%), åŸºç¡€å€æ•°={base_multiplier}, æ³¢åŠ¨ç‡è°ƒæ•´={vol_multiplier:.2f}, æœ€ç»ˆ={final_qty}è‚¡")
                
                return final_qty
        
        return 0

    def calculate_cost_based_qty(self, cost_deviation, volatility):
        """åŸºäºæˆæœ¬çš„å®šæŠ•è®¡ç®— - åŸºç¡€ç‰ˆæˆæœ¬å®šæŠ•ç®—æ³•"""
        if cost_deviation >= 20:  # é«˜äºæˆæœ¬20%ä»¥ä¸Šï¼Œå‡å°‘æŠ•èµ„
            return 0
        elif cost_deviation >= 10:  # é«˜äºæˆæœ¬10-20%ï¼Œå‡å°‘æŠ•èµ„
            multiplier = 0.5
        elif cost_deviation >= 0:  # ç•¥é«˜äºæˆæœ¬ï¼Œæ­£å¸¸æŠ•èµ„
            multiplier = 1.0
        elif cost_deviation >= -10:  # ç•¥ä½äºæˆæœ¬ï¼Œé€‚åº¦åŠ ä»“
            multiplier = 1.5
        elif cost_deviation >= -20:  # æ˜æ˜¾ä½äºæˆæœ¬ï¼ŒåŠ å¤§æŠ•èµ„
            multiplier = 2.0
        else:  # è¿œä½äºæˆæœ¬ï¼Œå¤§å¹…åŠ ä»“
            multiplier = 3.0
        
        # æ³¢åŠ¨ç‡è°ƒæ•´
        if self.volatility_adjust and volatility > 0.03:
            vol_multiplier = max(0.5, 1.0 - (volatility - 0.03) * 10)
            multiplier *= vol_multiplier
        
        final_qty = int(self.qty * multiplier)
        
        if final_qty > self.qty:  # åªæœ‰åŠ ä»“æ—¶æ‰è®°å½•
            if self.detailed_log:
                print(f"ğŸ’° æˆæœ¬å®šæŠ•: åç¦»={cost_deviation:.2f}%, å€æ•°={multiplier:.2f}, æ•°é‡={final_qty}è‚¡")
            return final_qty
            
        return 0

    def apply_volatility_adjustment(self, base_qty, volatility):
        """åº”ç”¨æ³¢åŠ¨ç‡è°ƒæ•´"""
        if volatility > 0.05:  # è¶…é«˜æ³¢åŠ¨
            return int(base_qty * 0.5)
        elif volatility > 0.03:  # é«˜æ³¢åŠ¨
            return int(base_qty * 0.8)
        elif volatility < 0.01:  # ä½æ³¢åŠ¨
            return int(base_qty * 1.2)
        else:
            return base_qty

    def check_risk_alerts(self, drawdown, profit_pct, position):
        """é£é™©é¢„è­¦æ£€æŸ¥"""
        alerts = []
        
        if drawdown > 40:
            alerts.append(f"é«˜å›æ’¤é£é™©: {drawdown:.2f}%")
        if profit_pct < -30:
            alerts.append(f"é«˜äºæŸé£é™©: {profit_pct:.2f}%")
        if position > self.max_position_limit:
            alerts.append(f"æŒä»“è¿‡å¤§: {position}è‚¡ > {self.max_position_limit}è‚¡")
        
        if alerts:
            print(f"âš ï¸ é£é™©é¢„è­¦: {', '.join(alerts)}")

    def reset_daily_counters(self, current_time):
        """é‡ç½®æ¯æ—¥è®¡æ•°å™¨"""
        current_day = current_time.date()
        if self.last_reset_day != current_day:
            self.daily_invest_count = 0
            self.last_reset_day = current_day

    def should_invest(self, current_time):
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥å®šæŠ•"""
        if self.last_investment_time is None:
            return True
        elapsed = (current_time - self.last_investment_time).total_seconds() / 60
        return elapsed >= self.interval_min

    def execute_investment(self, latest_price, account_balance, quantity, trade_type="å®šæŠ•", volatility=0.02):
        """æ‰§è¡ŒæŠ•èµ„ - å¢å¼ºç‰ˆ"""
        # å‚æ•°åˆæ³•æ€§æ£€æŸ¥
        if quantity < 10 or quantity > 2000:
            print(f"âš ï¸ æ•°é‡è°ƒæ•´: {quantity} -> {max(10, min(quantity, 200))}è‚¡")
            quantity = max(10, min(quantity, 200))

        if self.backtest:
            # å›æµ‹æ¨¡å¼
            required_cash = quantity * latest_price
            if required_cash > self.virtual_balance:
                print(f"ğŸ’° è™šæ‹Ÿä½™é¢ä¸è¶³: éœ€è¦${required_cash:.2f}, å¯ç”¨${self.virtual_balance:.2f}")
                return

            order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
            self.virtual_balance -= required_cash
            self._total_cost += required_cash
            self._position += quantity
            
            # æ›´æ–°ç»Ÿè®¡
            if trade_type == "å®šæœŸå®šæŠ•":
                self.total_investments += 1
            else:
                self.total_add_positions += 1
            
            if self.detailed_log:
                print(f"âœ… {trade_type}: {quantity}è‚¡ @ ${latest_price:.2f}")
                print(f"   æ³¢åŠ¨ç‡={volatility:.4f}, ä½™é¢=${self.virtual_balance:.2f}")
                print(f"   ç´¯è®¡å®šæŠ•={self.total_investments}æ¬¡, ç´¯è®¡åŠ ä»“={self.total_add_positions}æ¬¡")
            else:
                print(f"âœ… {trade_type}: {quantity}è‚¡ @ ${latest_price:.2f}")
            
        else:
            # å®ç›˜æ¨¡å¼
            required_cash = quantity * latest_price
            if required_cash > account_balance:
                max_qty = int((account_balance // latest_price) // 10 * 10)
                if max_qty < 10:
                    print(f"ğŸ’° èµ„é‡‘ä¸è¶³ï¼Œè·³è¿‡æœ¬æ¬¡æŠ•èµ„")
                    return
                quantity = max_qty
                print(f"âš ï¸ èµ„é‡‘è°ƒæ•´: æŠ•èµ„æ•°é‡è°ƒæ•´ä¸º {quantity}è‚¡")

            order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
            print(f"âœ… {trade_type}è®¢å•: {quantity}è‚¡ @ å¸‚ä»·, è®¢å•å·: {order_id}")

        # æ›´æ–°çŠ¶æ€
        self.last_investment_time = device_time(TimeZone.DEVICE_TIME_ZONE)
        self.daily_invest_count += 1

    def get_position(self):
        """è·å–æŒä»“æ•°é‡"""
        if self.backtest:
            return self._position
        try:
            return position_holding_qty(self.stock)
        except:
            return 0

    def get_total_cost(self):
        """è·å–æ€»æˆæœ¬"""
        if self.backtest:
            return self._total_cost
        try:
            pos = position_holding_qty(self.stock)
            avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
            return pos * avg_cost
        except:
            return 0.0

    def get_avg_cost(self):
        """è·å–å¹³å‡æˆæœ¬"""
        if self.backtest:
            return self._total_cost / self._position if self._position > 0 else 0.0
        try:
            return position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
        except:
            return 0.0