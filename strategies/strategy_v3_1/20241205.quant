class Strategy(StrategyBase):
    """网格交易策略V7 - 精简输出"""
    
    def initialize(self):
        """初始化策略（精简日志输出）"""
        try:
            # 初始化基本数据结构
            self.grid_prices = []
            self.positions = {}
            self.position_records = {}
            self.total_position = 0
            self.is_initialized = False
            self.last_sync_time = None
            self.last_trade_time = None
            self.pending_orders = set()
            self.order_records = {}
            self.current_period_trades = {
                'period': '',
                'buy_count': 0,
                'sell_count': 0,
                'grids': set()
            }
            self.last_trade_date = None
            self.daily_trade_count = 0

            # 标的、指标和变量
            self.trigger_symbols()
            self.custom_indicator()
            self.global_variables()

            # 尝试恢复持仓
            actual_position = self._get_position_qty(self.stock)
            if actual_position > 0:
                if self._recover_positions():
                    pass
                else:
                    return

            self.is_initialized = True
            print("策略初始化完成")
        except Exception as e:
            print(f"策略初始化发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())

    def trigger_symbols(self):
        """定义交易标的"""
        try:
            self.stock = declare_trig_symbol()
            print("交易标的设置完成")
        except Exception as e:
            print(f"设置交易标的时发生错误: {str(e)}")

    def custom_indicator(self):
        """设置技术指标"""
        try:
            self.register_indicator(
                indicator_name='MA',
                script='MA5:MA(CLOSE,5),COLORFF8D1E;',
                param_list=[]
            )
            print("技术指标设置完成")
        except Exception as e:
            print(f"设置技术指标时发生错误: {str(e)}")

    def global_variables(self):
        """定义全局变量"""
        try:
            # 移除 initial_capital 和 time_interval
            # 保留必要的用户配置参数
            self.max_total_position = show_variable(500, GlobalType.INT, "最大总持仓")
            self.min_order_quantity = show_variable(20, GlobalType.INT, "单次交易数量")
            self.position_limit = show_variable(80, GlobalType.INT, "单个网格持仓上限")
            self.enable_non_intraday_mode = show_variable(False, GlobalType.BOOL, "启用非日内模式(每天仅一次交易)")
            self.grid_percentage = show_variable(0.03, GlobalType.FLOAT, "网格间距/盈利标准")
            self.grid_num = show_variable(10, GlobalType.INT, "网格数量")
            self.max_capital_usage = show_variable(0.9, GlobalType.FLOAT, "最大资金使用率")
            self.max_order_timeout = show_variable(300, GlobalType.INT, "订单超时时间(秒)")
            self.use_trade_records = show_variable(True, GlobalType.BOOL, "使用成交记录恢复持仓")
            self.trade_record_days = show_variable(31, GlobalType.INT, "成交记录查询天数(1-31)")
            self.position_sync_retry = show_variable(3, GlobalType.INT, "持仓同步重试次数")
            
            print("全局变量设置完成")
                
        except Exception as e:
            print(f"设置全局变量时发生错误: {str(e)}")

    def _get_position_qty(self, symbol):
        """获取持仓数量,带标准错误处理"""
        try:
            return position_holding_qty(symbol)
        except APIException as ex:
            if ex.err_code == ErrCode.NoDataAvailable:
                print("无持仓数据")
                return 0
            else:
                print(f"获取持仓失败: {str(ex)}")
                return 0
        except Exception as e:
            print(f"获取持仓时发生未知错误: {str(e)}")
            return 0

    def _get_latest_price(self, symbol):
        """获取最新价格,带标准错误处理"""
        try:
            for _ in range(3):  # 最多重试3次
                try:
                    price = current_price(symbol)
                    if price:
                        return price
                except APIException as ex:
                    if ex.err_code == ErrCode.ExceedReqLimit:
                        print("请求过于频繁，等待重试")
                    elif ex.err_code == ErrCode.ReqTimeout:
                        print("获取价格超时，等待重试")
                    else:
                        print(f"获取价格失败: {str(ex)}")
                    time.sleep(0.1)
                    continue
                    
            print("获取价格重试次数达到上限")
            return None
                
        except Exception as e:
            print(f"获取价格时发生未知错误: {str(e)}")
            return None

    def handle_data(self):
        """主要策略逻辑"""
        try:
            # 获取当前时间和价格
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            latest_price = self._get_latest_price(self.stock)
            if not latest_price:
                return
                    
            print(f"\n当前时间: {current_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"当前价格: {latest_price:.1f}")
            
            # 定期同步持仓状态
            if not self.last_sync_time or (current_time - self.last_sync_time).total_seconds() > 300:  # 5分钟同步一次
                if self._sync_positions():
                    self.last_sync_time = current_time
                
            # 检查是否新周期
            if not self._is_new_period(current_time):
                print(f"当前周期已执行交易, 等待下一周期")
                return
                
            # 检查网格状态和交易机会
            if not self.is_initialized or self._should_reset_grid(latest_price):
                self._initialize_grids(latest_price)
                return
                
            # 检查是否有交易机会
            if self._check_trading_opportunity(latest_price):
                self.current_period_trades['last_update'] = current_time
                
        except Exception as e:
            print(f"策略运行时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())

    def _check_trading_opportunity(self, current_price):
        """检查交易机会（精简日志）"""
        try:
            sell_price = bid(self.stock, level=1) or current_price
            profitable_grids = []
            for grid_price, pos in self.positions.items():
                if pos <= 0:
                    continue
                record = self.position_records[grid_price]
                buy_price = record['buy_price']
                price_diff = (sell_price - buy_price) / buy_price
                min_profit = max(self.grid_percentage, 0.02)
                if price_diff >= min_profit:
                    profit_amount = (sell_price - buy_price) * pos
                    profitable_grids.append({
                        'grid_price': grid_price,
                        'quantity': pos,
                        'profit_pct': price_diff,
                        'profit_amount': profit_amount
                    })

            profitable_grids.sort(key=lambda x: x['profit_amount'], reverse=True)

            did_sell = False
            if profitable_grids and self._can_trade_in_period(is_buy=False):
                if self._execute_batch_sell([(g['grid_price'], g['quantity'], self.position_records[g['grid_price']]['buy_price'])
                                            for g in profitable_grids], current_price):
                    did_sell = True
                    print(f"已平仓盈利网格，总持仓:{self.total_position}")

                    if self.enable_non_intraday_mode and self._has_traded_today():
                        print("非日内模式当日已交易，停止开仓。")
                        return True

            # 若卖出成功且未启用非日内当日限制，则尝试买入
            if did_sell and not (self.enable_non_intraday_mode and self._has_traded_today()):
                if self._can_trade_in_period(is_buy=True) and self.total_position < self.max_total_position:
                    potential_grids = self._find_buy_opportunities(current_price)
                    if potential_grids:
                        grid_price = potential_grids[0]
                        if self._should_execute_trade(grid_price, current_price):
                            if self._place_buy_order(grid_price, current_price):
                                print(f"盈利平仓后开仓成功: 网格={grid_price}")
                                return True

            # 若没有盈利机会则尝试买入新仓
            if not did_sell and self._can_trade_in_period(is_buy=True) and self.total_position < self.max_total_position:
                potential_grids = self._find_buy_opportunities(current_price)
                if potential_grids:
                    grid_price = potential_grids[0]
                    if self._should_execute_trade(grid_price, current_price):
                        if self._place_buy_order(grid_price, current_price):
                            print(f"开仓成功: 网格={grid_price}, 当前总持仓:{self.total_position}")
                            return True

            return did_sell
        except Exception as e:
            print(f"检查交易机会时发生错误: {str(e)}")
            return False

    def _can_trade_in_period(self, is_buy=True):
        """检查是否可以在当前周期交易"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            current_period = current_time.strftime('%Y%m%d_%H%M')
            
            # 检查是否为新周期
            if current_period != self.current_period_trades['period']:
                return True
                
            # 检查距离上次更新是否已经超过一定时间（例如30秒）
            if 'last_update' in self.current_period_trades:
                elapsed = (current_time - self.current_period_trades['last_update']).total_seconds()
                if elapsed > 30:  # 如果超过30秒，允许新的交易
                    return True
                    
            # 检查交易次数限制
            if is_buy:
                max_trades = 2  # 每周期最多买入2次
                return self.current_period_trades['buy_count'] < max_trades
            else:
                max_trades = 2  # 每周期最多卖出2次
                return self.current_period_trades['sell_count'] < max_trades
                
        except Exception as e:
            print(f"检查交易周期失败: {str(e)}")
            return False

    def _is_new_period(self, current_time):
        """判断是否是新的交易周期"""
        current_period = current_time.strftime('%Y%m%d_%H%M')
        if current_period != self.current_period_trades['period']:
            self.current_period_trades = {
                'period': current_period,
                'buy_count': 0,
                'sell_count': 0,
                'grids': set()
            }
            return True
        return False

    def _update_period_trade_status(self, is_buy=True):
        """更新周期交易状态"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            current_period = current_time.strftime('%Y%m%d_%H%M')
            
            # 如果是新周期，重置状态
            if current_period != self.current_period_trades['period']:
                self.current_period_trades = {
                    'period': current_period,
                    'buy_count': 0,
                    'sell_count': 0,
                    'grids': set(),
                    'last_update': current_time
                }
            
            # 更新交易计数
            if is_buy:
                self.current_period_trades['buy_count'] += 1
            else:
                self.current_period_trades['sell_count'] += 1
                
            self.current_period_trades['last_update'] = current_time
            
            # 打印当前周期状态
            print(f"当前周期{current_period}状态: 买入次数={self.current_period_trades['buy_count']}, "
                f"卖出次数={self.current_period_trades['sell_count']}")
                
        except Exception as e:
            print(f"更新周期状态失败: {str(e)}")

    def _execute_batch_sell(self, profitable_grids, current_price):
        """批量卖出（精简日志）"""
        try:
            if not profitable_grids:
                return False

            if not self._sync_positions():
                print("持仓同步失败，取消卖出")
                return False

            sell_order_id = place_market(
                symbol=self.stock,
                qty=sum(g[1] for g in profitable_grids),
                side=OrderSide.SELL,
                time_in_force=TimeInForce.DAY
            )

            if not sell_order_id:
                print("批量卖出订单创建失败")
                return False

            self.order_records[sell_order_id] = {
                'side': OrderSide.SELL,
                'grid_prices': [g[0] for g in profitable_grids],
                'qty': sum(g[1] for g in profitable_grids)
            }
            self.pending_orders.add(sell_order_id)

            try:
                exec_info = self._check_order_status(sell_order_id)
                if exec_info:
                    # 更新持仓
                    for grid_price, qty, buy_price in profitable_grids:
                        if grid_price in self.positions:
                            ded_qty = min(qty, self.positions[grid_price])
                            self.positions[grid_price] -= ded_qty
                            self.total_position -= ded_qty
                            if self.positions[grid_price] == 0:
                                del self.positions[grid_price]
                                del self.position_records[grid_price]

                    if self._verify_positions():
                        print(f"批量卖出成功，当前总持仓:{self.total_position}")
                        self._update_period_trade_status(is_buy=False)
                        if self.enable_non_intraday_mode:
                            self._mark_traded_today()
                        return True
                else:
                    print("无法获取成交信息，放弃交易数据更新")
                    return False
            finally:
                self.pending_orders.discard(sell_order_id)
        except Exception as e:
            print(f"执行批量卖出时发生错误: {str(e)}")
            return False

    def _place_buy_order(self, grid_price, current_price):
        """执行买入订单（精简日志）"""
        try:
            if not self._sync_positions():
                print("持仓同步失败，取消买入")
                return False

            current_pos = self.positions.get(grid_price, 0)
            available_position = self.max_total_position - self.total_position
            order_quantity = min(self.min_order_quantity,
                                self.position_limit - current_pos,
                                available_position)
            if order_quantity <= 0:
                return False

            buy_order_id = place_market(
                symbol=self.stock,
                qty=order_quantity,
                side=OrderSide.BUY,
                time_in_force=TimeInForce.DAY
            )

            if not buy_order_id:
                print("买入订单创建失败")
                return False

            self.order_records[buy_order_id] = {
                'side': OrderSide.BUY,
                'grid_price': grid_price,
                'qty': order_quantity
            }
            self.pending_orders.add(buy_order_id)

            try:
                exec_info = self._check_order_status(buy_order_id)
                if exec_info:
                    updates = [{
                        'grid_price': grid_price,
                        'qty': order_quantity,
                        'price': exec_info['avg_price'],
                        'is_buy': True,
                        'time': exec_info['last_time'].strftime('%Y/%m/%d %H:%M:%S')
                    }]
                    if self._batch_update_positions(updates):
                        self._update_period_trade_status(is_buy=True)
                        if self.enable_non_intraday_mode:
                            self._mark_traded_today()
                        print(f"买入成功: 网格={grid_price}, 持仓更新后总持仓:{self.total_position}")
                        return True
                return False
            finally:
                self.pending_orders.discard(buy_order_id)
        except Exception as e:
            print(f"执行买入订单时发生错误: {str(e)}")
            return False

    def _check_order_status(self, order_id, max_retries=120, retry_interval=0.5):
        """检查订单状态（精简日志，只打印最终结果）"""
        if not order_id:
            return None
        try:
            start_time = time.time()
            while True:
                try:
                    status = order_status(order_id)
                except:
                    time.sleep(retry_interval)
                    continue

                if status == "FILLED_ALL":
                    exec_info = self._get_execution_info(order_id, self.stock)
                    if exec_info and exec_info['total_qty'] > 0:
                        # 简化，不打印多余信息
                        return exec_info
                    # fallback
                    return self._fallback_exec_info(order_id)

                if status in ["CANCELLED_ALL", "FAILED", "DISABLED", "DELETED"]:
                    return None

                elapsed_time = time.time() - start_time
                if elapsed_time >= self.max_order_timeout or max_retries <= 0:
                    return self._fallback_exec_info(order_id)

                max_retries -= 1
                time.sleep(retry_interval)
        except Exception as e:
            return self._fallback_exec_info(order_id)

    def _get_execution_info(self, order_id, symbol):
        """
        获取指定订单的成交详情，包括价格、数量和时间。
        :param order_id: str, 订单ID
        :param symbol: Contract, 交易标的
        :return: dict, 包括 avg_price (加权平均成交价), total_qty (总成交数量), last_time (最近成交时间)
        """
        try:
            # Step 1: 获取 execution_id 列表
            execution_ids = request_executionid(symbol=symbol)

            # Step 2: 筛选属于指定 order_id 的 execution_id
            valid_executions = [
                execution_id for execution_id in execution_ids
                if execution_orderid(execution_id) == order_id
            ]

            if not valid_executions:
                raise ValueError(f"No execution found for order_id: {order_id}")

            # Step 3: 汇总成交详情
            total_qty = 0
            total_value = 0
            last_time = None

            for execution_id in valid_executions:
                qty = execution_qty(execution_id)
                price = execution_price(execution_id)
                exec_time = execution_time(execution_id, time_zone=TimeZone.MARKET_TIME_ZONE)

                total_qty += qty
                total_value += price * qty
                if not last_time or exec_time > last_time:
                    last_time = exec_time

            avg_price = total_value / total_qty if total_qty > 0 else 0
            return {
                "avg_price": avg_price,
                "total_qty": total_qty,
                "last_time": last_time,
            }

        except Exception as e:
            print(f"Error in _get_execution_info: {str(e)}")
            return {
                "avg_price": 0,
                "total_qty": 0,
                "last_time": None,
            }

    def _fallback_exec_info(self, order_id):
        """无法获取实际成交详情时的fallback逻辑。
        使用下单记录或当前价格作为参考，返回一个模拟的exec_info。"""
        record = self.order_records.get(order_id, {})
        fallback_qty = record.get('qty', 0)

        if fallback_qty <= 0:
            print("fallback失败: 无法从订单记录获取有效数量信息")
            return None

        current_p = self._get_latest_price(self.stock)
        if not current_p:
            current_p = 1.0

        fallback_time = device_time(TimeZone.DEVICE_TIME_ZONE)
        exec_info = {
            'order_id': order_id,
            'avg_price': current_p,
            'total_qty': fallback_qty,
            'last_time': fallback_time
        }
        print(f"使用fallback信息更新订单{order_id}: 数量={fallback_qty}, 价格={current_p}")
        return exec_info

    def _cancel_and_verify_order(self, order_id):
        """撤单并验证结果"""
        try:
            if not order_id:
                return False
                
            # 尝试撤单
            try:
                cancel_order_by_orderid(order_id)
                print(f"已发送撤单请求: {order_id}")
            except Exception as e:
                print(f"撤单请求失败: {str(e)}")
                return False
                
            # 等待撤单结果
            max_wait = 10  # 最多等待10秒
            start_time = time.time()
            
            while True:
                try:
                    status = order_status(order_id)
                    if status in ["CANCELLED_ALL", "FAILED", "DISABLED", "DELETED"]:
                        print(f"订单{order_id}已成功撤销")
                        return True
                        
                    if status == "FILLED_ALL":
                        print(f"订单{order_id}已完全成交，无需撤单")
                        return True
                        
                    if time.time() - start_time > max_wait:
                        print(f"等待撤单结果超时: {order_id}")
                        return False
                        
                    time.sleep(0.5)
                        
                except Exception as e:
                    print(f"检查撤单状态失败: {str(e)}")
                    return False
                    
        except Exception as e:
            print(f"撤单过程发生错误: {str(e)}")
            return False

    def _batch_update_positions(self, updates):
        """批量更新持仓信息"""
        try:
            # 记录更新前的状态
            old_positions = self.positions.copy()
            old_records = {k: v.copy() for k, v in self.position_records.items()}
            old_total = self.total_position
            
            # 预检查更新是否会导致超限
            for update in updates:
                grid_price = update['grid_price']
                qty = update['qty']
                is_buy = update['is_buy']
                
                current_pos = self.positions.get(grid_price, 0)
                if is_buy:
                    new_qty = current_pos + qty
                    if new_qty > self.position_limit:
                        print(f"更新将导致网格{grid_price}超出限制:{new_qty}>{self.position_limit}")
                        return False
                        
            # 执行所有更新
            for update in updates:
                try:
                    grid_price = update['grid_price']
                    qty = update['qty']
                    price = update['price']
                    is_buy = update['is_buy']
                    
                    if is_buy:
                        # 买入更新
                        current_pos = self.positions.get(grid_price, 0)
                        current_cost = self.position_records.get(grid_price, {}).get('buy_price', 0)
                        new_qty = current_pos + qty
                        
                        # 计算加权平均成本(保持1位小数)
                        if current_pos > 0:
                            total_value = current_pos * current_cost + qty * price
                            new_cost = int(total_value / new_qty * 10) / 10
                        else:
                            new_cost = int(price * 10) / 10
                        
                        self.positions[grid_price] = new_qty
                        self.position_records[grid_price] = {
                            'buy_price': new_cost,
                            'quantity': new_qty,
                            'update_time': time.time()
                        }
                    else:
                        # 卖出更新
                        if grid_price in self.positions:
                            current_pos = self.positions[grid_price]
                            if current_pos <= qty:
                                del self.positions[grid_price]
                                self.position_records[grid_price] = {
                                    'buy_price': 0,
                                    'quantity': 0,
                                    'update_time': time.time()
                                }
                            else:
                                new_qty = current_pos - qty
                                self.positions[grid_price] = new_qty
                                self.position_records[grid_price].update({
                                    'quantity': new_qty,
                                    'update_time': time.time()
                                })
                    
                    # 更新总持仓
                    self.total_position = sum(qty for qty in self.positions.values() if qty > 0)
                    
                    # 每次更新后立即验证
                    if not self._verify_positions():
                        raise Exception(f"网格{grid_price}更新后验证失败")
                        
                except Exception as e:
                    if str(e):  # 只在有实际错误信息时打印
                        print(f"更新失败: {str(e)}")
                    self.positions = old_positions
                    self.position_records = old_records
                    self.total_position = old_total
                    return False
                    
            print(f"批量更新持仓成功 - 总持仓:{self.total_position}")
            self._print_grid_status(show_all=False)
            return True
                
        except Exception as e:
            if str(e):  # 只在有实际错误信息时打印
                print(f"批量更新持仓失败: {str(e)}")
            return False

    def _initialize_grids(self, base_price):
        """初始化或重置网格（精简日志）"""
        try:
            # 不打印过多细节，只给出关键信息
            if not base_price or base_price <= 0:
                print("无效的基准价格，无法初始化网格")
                return False

            if not self._sync_positions():
                print("持仓同步失败，初始化网格中止")
                return False

            actual_position = self.total_position

            # 如有持仓，先检查盈利机会
            if actual_position > 0:
                if self._check_profit_before_reset(base_price):
                    if not self._sync_positions():
                        print("持仓同步失败")
                        return False
                    actual_position = self.total_position

            # 生成新网格价格（不打印中间细节）
            grid_spacing = base_price * (self.grid_percentage * 0.8)
            half_grids = self.grid_num // 2
            new_grid_prices = []
            base_grid = int(base_price * 10) / 10

            new_grid_prices.append(base_grid)
            for i in range(1, half_grids + 1):
                up_price = int((base_grid + i * grid_spacing) * 10) / 10
                down_price = int((base_grid - i * grid_spacing) * 10) / 10
                if abs(up_price - base_price) < abs(down_price - base_price):
                    new_grid_prices.append(up_price)
                    new_grid_prices.append(down_price)
                else:
                    new_grid_prices.append(down_price)
                    new_grid_prices.append(up_price)

            new_grid_prices.sort()

            # 持仓迁移/初始化
            if actual_position > 0:
                if not self._migrate_positions(actual_position, new_grid_prices, base_price):
                    print("持仓迁移失败")
                    return False
            else:
                self.grid_prices = new_grid_prices
                self.positions = {}
                self.position_records = {
                    price: {
                        'buy_price': 0,
                        'quantity': 0,
                        'update_time': time.time()
                    }
                    for price in new_grid_prices
                }
                self.total_position = 0

            print("网格初始化完成")

            # 非日内模式，今天已有交易则不建仓
            if self.enable_non_intraday_mode and self._has_traded_today():
                print("非日内模式生效，今日已交易，不立即建仓")
                return True

            # 尝试一次建仓
            if actual_position < self.max_total_position:
                buy_opportunities = self._find_buy_opportunities(base_price)
                if buy_opportunities:
                    grid_price = buy_opportunities[0]
                    if self._can_trade_in_period(is_buy=True):
                        if self._place_buy_order(grid_price, base_price):
                            print(f"首次建仓成功: 网格={grid_price:.1f}")
                            self._sync_positions()

            return True

        except Exception as e:
            print(f"初始化网格时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return False

    def _check_reset_safety(self, latest_price):
        """检查是否可以安全重置网格"""
        try:
            # 获取所有持仓的成本信息
            positions_info = []
            for grid_price, qty in self.positions.items():
                if qty <= 0:
                    continue
                    
                record = self.position_records[grid_price]
                buy_price = record['buy_price']
                price_diff = (latest_price - buy_price) / buy_price
                positions_info.append((grid_price, qty, buy_price, price_diff))
                
            # 如果所有持仓都是盈利的，可以重置
            if all(info[3] >= 0 for info in positions_info):
                return True
                
            # 计算总亏损金额
            total_loss = sum((info[2] - latest_price) * info[1] 
                            for info in positions_info if info[3] < 0)
                            
            # 如果亏损超过一定限度，不建议重置
            max_allowed_loss = latest_price * self.total_position * 0.02  # 2%作为示例
            if total_loss > max_allowed_loss:
                print(f"当前亏损({total_loss:.2f})超过允许限度({max_allowed_loss:.2f})")
                return False
                
            return True
                
        except Exception as e:
            print(f"检查网格重置安全性时发生错误: {str(e)}")
            return False

    def _verify_positions(self):
        """验证持仓数据一致性（精简日志）"""
        try:
            actual_position = self._get_position_qty(self.stock)
            calculated_position = sum(qty for qty in self.positions.values() if qty > 0)

            if abs(calculated_position - actual_position) > 0.01:
                print("持仓验证失败: 实际持仓与记录不一致")
                return False

            # 简化检查，不详细打印
            if calculated_position > self.max_total_position:
                print("持仓验证失败: 超出最大持仓限制")
                return False

            self.total_position = calculated_position
            return True
        except Exception as e:
            print(f"验证持仓失败: {str(e)}")
            return False

    def _print_grid_status(self, show_all=True):
        """打印网格状态（精简日志）"""
        try:
            latest_price = self._get_latest_price(self.stock)
            if latest_price:
                total_value = latest_price * self.total_position
                print(f"当前总持仓:{self.total_position}, 估值:{total_value:.2f}")
            else:
                print(f"当前总持仓:{self.total_position}")
        except Exception as e:
            print(f"打印网格状态时发生错误: {str(e)}")

    def _migrate_positions(self, actual_position, new_grid_prices, current_price):
        """迁移持仓到新网格"""
        try:
            print("\n开始迁移持仓到新网格...")
            # 先尝试从成交记录恢复
            if self.use_trade_records:
                positions_from_trades = self._get_positions_from_trades()
                if positions_from_trades:
                    print("从成交记录恢复持仓分布")
                    self.positions = positions_from_trades['positions']
                    self.position_records = positions_from_trades['records']
                    self.total_position = positions_from_trades['total']
                    self.grid_prices = new_grid_prices
                    
                    # 验证持仓状态
                    if self._verify_positions():
                        print("持仓恢复验证成功")
                        return True
                    print("持仓恢复验证失败,尝试网格迁移")
            
            # 使用网格迁移
            print("执行网格迁移")
            
            # 保存当前状态用于回滚
            old_positions = self.positions.copy()
            old_records = {k: v.copy() for k, v in self.position_records.items()}
            old_total = self.total_position
            
            # 初始化新状态
            new_positions = {}
            new_records = {}
            
            # 计算最高价网格
            highest_grid = new_grid_prices[0]
            for price in new_grid_prices[1:]:
                if price > highest_grid:
                    highest_grid = price
            print(f"新网格最高价格: {highest_grid:.1f}")
            
            # 处理现有持仓
            for grid_price, qty in old_positions.items():
                if qty <= 0:
                    continue
                    
                record = old_records[grid_price]
                buy_price = record['buy_price']
                
                # 保留高位网格
                if grid_price > highest_grid:
                    print(f"保留高位网格 {grid_price:.1f} 的持仓 {qty}股")
                    new_positions[grid_price] = qty
                    new_records[grid_price] = record.copy()
                    continue
                    
                # 合并到新网格
                new_grid = self._find_nearest_grid_price(grid_price, new_grid_prices)
                if new_grid in new_positions:
                    old_qty = new_positions[new_grid]
                    old_cost = new_records[new_grid]['buy_price']
                    total_qty = old_qty + qty
                    
                    if total_qty <= self.position_limit:
                        new_positions[new_grid] = total_qty
                        total_value = old_qty * old_cost + qty * buy_price
                        weighted_cost = int(total_value / total_qty * 10) / 10
                        new_records[new_grid] = {
                            'buy_price': weighted_cost,
                            'quantity': total_qty,
                            'update_time': time.time()
                        }
                        print(f"合并至网格 {new_grid:.1f}: +{qty}股 => {total_qty}股")
                    else:
                        print(f"网格 {new_grid:.1f} 将超出限制，保持原网格")
                        new_positions[grid_price] = qty
                        new_records[grid_price] = record.copy()
                else:
                    new_positions[new_grid] = qty
                    new_records[new_grid] = {
                        'buy_price': buy_price,
                        'quantity': qty,
                        'update_time': time.time()
                    }
                    print(f"迁移至网格 {new_grid:.1f}: {qty}股")
                    
            # 更新状态
            self.grid_prices = new_grid_prices
            self.positions = new_positions
            self.position_records = new_records
            self.total_position = sum(qty for qty in self.positions.values() if qty > 0)
            
            # 验证迁移结果
            if self._verify_positions():
                print("网格迁移成功")
                return True
                
            # 验证失败时回滚
            print("网格迁移验证失败，回滚并尝试强制同步")
            self.positions = old_positions
            self.position_records = old_records
            self.total_position = old_total
            
            retry_count = 0
            while retry_count < self.position_sync_retry:
                print(f"尝试强制同步 ({retry_count + 1}/{self.position_sync_retry})")
                if self._sync_positions(force_mode=True):
                    print("强制同步成功")
                    # 使用同步后的状态初始化新网格
                    self.grid_prices = new_grid_prices
                    return True
                
                retry_count += 1
                if retry_count < self.position_sync_retry:
                    print("强制同步失败，等待重试...")
                    time.sleep(0.5)  # 添加短暂延迟
                    
            print("同步重试次数达到上限")
            return False
                
        except Exception as e:
            if str(e):  # 只在有实际错误信息时打印
                print(f"网格迁移失败: {str(e)}")
            return False

    def _find_nearest_grid_price(self, target_price, grid_prices):
        """在给定的价格列表中找到最接近的网格价格"""
        try:
            if not grid_prices:
                return None
                
            target_price = int(target_price * 10) / 10  # 保持1位小数
            
            nearest_price = grid_prices[0]
            min_distance = abs(target_price - nearest_price)
            
            for price in grid_prices[1:]:
                distance = abs(target_price - price)
                if distance < min_distance:
                    min_distance = distance
                    nearest_price = price
                    
            return nearest_price
            
        except Exception as e:
            print(f"查找最近网格价格失败: {str(e)}")
            return None

    def _find_buy_opportunities(self, latest_price):
        """寻找合适的买入机会"""
        try:
            potential_grids = []
            
            # 根据当前价格查找附近的网格
            for grid_price in sorted(self.grid_prices):
                # 检查价格偏差
                price_diff = abs(latest_price - grid_price) / grid_price
                max_deviation = self.grid_percentage * 0.75  # 允许更大的价格偏差
                
                if price_diff <= max_deviation:
                    current_pos = self.positions.get(grid_price, 0)
                    # 检查是否有空间建仓
                    if current_pos < self.position_limit:
                        potential_grids.append(grid_price)
                        
            return potential_grids
                
        except Exception as e:
            print(f"查找买入机会时发生错误: {str(e)}")
            return []

    def _find_nearest_grid(self, target_price):
        """在当前网格中找到最接近的价格"""
        return self._find_nearest_grid_price(target_price, self.grid_prices)

    def _should_reset_grid(self, latest_price):
        """判断是否需要重置网格"""
        try:
            if not self.grid_prices:
                return True
                    
            closest_grid = self._find_nearest_grid(latest_price)
            if not closest_grid:
                return True
                
            deviation = abs(latest_price - closest_grid) / closest_grid
            return deviation > self.grid_percentage
                
        except Exception as e:
            print(f"检查网格重置时发生错误: {str(e)}")
            return False

    def _recover_positions(self):
        """恢复已有持仓状态"""
        try:
            # 基础验证
            required_params = ['grid_percentage', 'grid_num', 'position_limit']
            for param in required_params:
                if not hasattr(self, param):
                    print(f"错误：参数 {param} 未初始化")
                    return False

            # 同步当前持仓状态
            if not self._sync_positions():
                print("持仓同步失败")
                return False
                
            actual_position = self.total_position
            if actual_position == 0:
                return True

            latest_price = self._get_latest_price(self.stock)
            if not latest_price:
                print("无法获取当前价格，恢复失败")
                return False

            print(f"当前持仓: {actual_position}股")
            
            # 从成交记录恢复持仓分布已由_sync_positions完成
            # 直接使用同步后的状态初始化网格
            
            # 初始化网格价格
            grid_spacing = latest_price * self.grid_percentage
            base_grid = int(latest_price * 10) / 10
            half_grids = self.grid_num // 2
            
            # 生成网格价格
            self.grid_prices = []
            for i in range(half_grids + 1):
                if i == 0:
                    self.grid_prices.append(base_grid)
                else:
                    up_price = int((base_grid + i * grid_spacing) * 10) / 10
                    down_price = int((base_grid - i * grid_spacing) * 10) / 10
                    self.grid_prices.extend([up_price, down_price])
            self.grid_prices.sort()
            
            print("\n恢复后的网格状态:")
            self._print_grid_status(show_all=True)
            
            # 验证恢复结果
            if not self._verify_positions():
                print("持仓验证失败")
                return False
                
            print("持仓恢复成功")
            return True
                
        except Exception as e:
            print(f"恢复持仓状态时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return False

    def _check_profit_before_reset(self, current_price):
        """重置网格前检查盈利机会（精简日志）"""
        try:
            if not self._sync_positions():
                print("持仓同步失败，无法检查重置前盈利")
                return False

            sell_price = bid(self.stock, level=1) or current_price
            profitable_grids = []

            for grid_price, qty in self.positions.items():
                if qty <= 0:
                    continue
                buy_price = self.position_records[grid_price]['buy_price']
                price_diff = (sell_price - buy_price) / buy_price
                if price_diff >= self.grid_percentage:
                    profitable_grids.append((grid_price, qty, buy_price))

            if profitable_grids:
                if self._execute_batch_sell(profitable_grids, current_price):
                    print("完成盈利了结")
                    return True
            else:
                print("无盈利可平仓")

            return False

        except Exception as e:
            print(f"检查重置前盈利失败: {str(e)}")
            return False

    def _get_positions_from_trades(self):
        """从历史成交记录中恢复持仓（精简日志）"""
        try:
            actual_position = self._get_position_qty(self.stock)
            if actual_position == 0:
                return None

            execution_ids = request_executionid(symbol=self.stock)
            if not execution_ids:
                print("无法获取成交记录")
                return None

            trades = []
            for eid in execution_ids:
                if execution_status(eid) != "OK":
                    continue
                trades.append({
                    'price': execution_price(eid),
                    'quantity': execution_qty(eid),
                    'side': execution_side(eid),
                    'time': execution_time(eid)
                })

            trades.sort(key=lambda x: x['time'])

            positions = {}
            records = {}
            total_position = 0

            # 不打印详细买卖过程，仅计算结果
            for trade in trades:
                price = int(trade['price'] * 10) / 10
                qty = trade['quantity']
                if trade['side'] == OrderSide.BUY:
                    if price not in positions:
                        positions[price] = 0
                        records[price] = {
                            'buy_price': price,
                            'quantity': 0,
                            'update_time': time.time()
                        }
                    positions[price] += qty
                    records[price]['quantity'] = positions[price]
                    total_position += qty
                else:
                    remaining_qty = qty
                    for p in sorted(positions.keys(), reverse=True):
                        if remaining_qty <= 0:
                            break
                        if positions[p] > 0:
                            deduct = min(positions[p], remaining_qty)
                            positions[p] -= deduct
                            records[p]['quantity'] = positions[p]
                            remaining_qty -= deduct
                            total_position -= deduct
                            if positions[p] == 0:
                                del positions[p]
                                del records[p]

            # 清理空持仓
            for price in list(positions.keys()):
                if positions[price] <= 0:
                    del positions[price]
                    del records[price]

            calculated_position = sum(positions.values())
            if abs(calculated_position - actual_position) > 0.01:
                print("从成交记录恢复持仓失败: 持仓不一致")
                return None

            # 成功不详细打印价格列表
            print("从成交记录成功恢复持仓分布")
            return {
                'positions': positions,
                'records': records,
                'total': calculated_position
            }

        except Exception as e:
            print(f"从成交记录恢复持仓失败: {str(e)}")
            return None

    def _is_price_within_grid(self, price, grid_price):
        """判断价格是否在网格允许范围内"""
        try:
            if not price or not grid_price:
                return False
                
            price_diff = abs(price - grid_price) / grid_price
            max_deviation = self.grid_percentage * 0.5  # 允许最大偏差为网格间距的一半
            return price_diff <= max_deviation
                
        except Exception as e:
            print(f"检查价格偏差失败: {str(e)}")
            return False

    def _should_execute_trade(self, grid_price, latest_price):
        """判断是否应该执行交易"""
        try:
            # 放宽价格偏差限制
            price_diff = abs(latest_price - grid_price) / grid_price
            max_deviation = self.grid_percentage * 0.8  # 允许更大的价格偏差
            
            if price_diff > max_deviation:
                print(f"当前价格{latest_price:.1f}超出网格{grid_price:.1f}允许范围")
                return False
                
            # 检查网格容量
            current_pos = self.positions.get(grid_price, 0)
            if current_pos >= self.position_limit:
                print(f"网格{grid_price:.1f}持仓{current_pos}已达上限{self.position_limit}")
                return False
                
            # 检查总持仓
            available_position = self.max_total_position - self.total_position
            if available_position < self.min_order_quantity:
                print(f"剩余可用持仓{available_position}小于最小交易数量{self.min_order_quantity}")
                return False
                
            # 获取实时买价进行二次验证
            ask_price = ask(self.stock, level=1)
            if ask_price:
                price_diff = abs(ask_price - grid_price) / grid_price
                if price_diff > max_deviation:
                    print(f"实时买价{ask_price:.1f}超出网格{grid_price:.1f}允许范围")
                    return False
                    
            return True
                
        except Exception as e:
            print(f"交易前检查失败: {str(e)}")
            return False

    def _sync_positions(self, force_mode=False):
        """同步持仓状态（精简日志）"""
        try:
            actual_position = self._get_position_qty(self.stock)
            if actual_position == 0:
                self.positions.clear()
                self.position_records.clear()
                self.total_position = 0
                # 移除详细日志，仅保留必要信息
                return True

            if force_mode:
                return self._force_sync_position_internal(actual_position)

            # 正常流程获取成交记录
            trades = self._get_recent_trades()
            if not trades:
                # 无成交记录时尝试强制同步
                return self._force_sync_position_internal(actual_position)

            # 计算持仓分布（不打印中间过程，只进行计算）
            new_positions = {}
            new_records = {}
            total_position = 0

            for trade in trades:
                price = int(trade['price'] * 10) / 10
                qty = trade['quantity']
                is_buy = trade['is_buy']

                if is_buy:
                    if price not in new_positions:
                        new_positions[price] = {
                            'quantity': 0,
                            'buy_price': price
                        }
                    new_positions[price]['quantity'] += qty
                    total_position += qty
                else:
                    remaining_qty = qty
                    # 从高价到低价扣减
                    for p in sorted(new_positions.keys(), reverse=True):
                        if remaining_qty <= 0:
                            break
                        pos = new_positions[p]
                        if pos['quantity'] > 0:
                            deduct = min(pos['quantity'], remaining_qty)
                            pos['quantity'] -= deduct
                            total_position -= deduct
                            remaining_qty -= deduct

            # 清理并更新记录
            for price in list(new_positions.keys()):
                pos = new_positions[price]
                if pos['quantity'] <= 0:
                    del new_positions[price]
                    continue
                new_records[price] = {
                    'buy_price': pos['buy_price'],
                    'quantity': pos['quantity'],
                    'update_time': time.time()
                }

            calculated_position = sum(pos['quantity'] for pos in new_positions.values())
            if abs(calculated_position - actual_position) > 0.01:
                # 若不一致，尝试强制同步，不打印详细说明
                return self._force_sync_position_internal(actual_position)

            # 更新状态
            self.positions = {k: v['quantity'] for k, v in new_positions.items()}
            self.position_records = new_records
            self.total_position = calculated_position
            # 同步成功不打印繁杂信息
            return True

        except Exception as e:
            print(f"同步持仓状态失败: {str(e)}")
            return False

    def _force_sync_position_internal(self, actual_position):
        """内部强制同步方法"""
        try:
            print("执行强制持仓同步...")
            latest_price = self._get_latest_price(self.stock)
            if not latest_price:
                return False
                
            # 获取平均成本
            avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
            if not avg_cost:
                avg_cost = latest_price
                
            # 保存旧状态用于回滚
            old_positions = self.positions.copy()
            old_records = self.position_records.copy()
            old_total = self.total_position
            
            # 寻找合适的网格
            target_grid = None
            cost_grid = self._find_nearest_grid(avg_cost)
            price_grid = self._find_nearest_grid(latest_price)
            
            if cost_grid and self._is_price_within_grid(avg_cost, cost_grid):
                target_grid = cost_grid
            elif price_grid and self._is_price_within_grid(latest_price, price_grid):
                target_grid = price_grid
                
            if not target_grid:
                print("无法找到合适的网格")
                return False
                
            # 更新持仓记录
            self.positions = {target_grid: actual_position}
            self.position_records = {
                target_grid: {
                    'buy_price': int(avg_cost * 10) / 10,
                    'quantity': actual_position,
                    'update_time': time.time()
                }
            }
            self.total_position = actual_position
            
            # 更新并验证
            if self._verify_positions():
                print(f"强制同步完成 - 网格:{target_grid:.1f}, 持仓:{actual_position}, 成本:{avg_cost:.1f}")
                self._print_grid_status(show_all=False)
                return True
                
            # 验证失败时回滚
            print("强制同步验证失败，执行回滚")
            self.positions = old_positions
            self.position_records = old_records
            self.total_position = old_total
            return False
                
        except Exception as e:
            if str(e):
                print(f"强制同步失败: {str(e)}")
            return False

    def _get_recent_trades(self):
        """获取最近的成交记录"""
        try:
            trades = []
            exec_ids = request_executionid(symbol=self.stock)
            if not exec_ids:
                return None
                
            for eid in exec_ids:
                try:
                    status = execution_status(eid)
                    if status != "OK":
                        continue
                        
                    qty = execution_qty(eid)
                    price = execution_price(eid)
                    side = execution_side(eid)
                    time_str = execution_time(eid) or device_time(TimeZone.DEVICE_TIME_ZONE).strftime('%Y/%m/%d %H:%M:%S')
                    
                    trades.append({
                        'price': price,
                        'quantity': qty,
                        'is_buy': side == OrderSide.BUY,
                        'time': time_str
                    })
                        
                except Exception as e:
                    print(f"获取成交记录{eid}失败: {str(e)}")
                    continue
                    
            # 按时间排序
            trades.sort(key=lambda x: x['time'])
            return trades
                
        except Exception as e:
            print(f"获取成交记录失败: {str(e)}")
            return None

    def _has_traded_today(self):
        current_day = device_time(TimeZone.DEVICE_TIME_ZONE).strftime('%Y-%m-%d')
        if self.last_trade_date == current_day and self.daily_trade_count > 0:
            return True
        return False

    def _mark_traded_today(self):
        current_day = device_time(TimeZone.DEVICE_TIME_ZONE).strftime('%Y-%m-%d')
        if self.last_trade_date != current_day:
            self.last_trade_date = current_day
            self.daily_trade_count = 0
        self.daily_trade_count += 1
