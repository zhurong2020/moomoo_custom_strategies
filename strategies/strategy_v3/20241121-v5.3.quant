class Strategy(StrategyBase):
    """网格交易策略V5.3.8 -  添加隔离模式（默认为真），启动时打印用户参数，修订价格区间、持仓统计等错误。
    关于如何使用Moomoo中的量化交易，可以关注"有心言者"微信公众号中的介绍。
    完整的Moomoo量化交易指南请移步我的博客"https://zhurong2020.github.io/"。
    需要下载Moomoo量化策略的，请查看以上相关文章链接，或直接到我的Github仓库："https://github.com/znhskzj/moomoo_custom_strategies"。
    量化交易有风险，投资需谨慎，请务必结合个人风险承受能力做出决策。
    风险提示：使用本策略进行交易，风险自担。请仔细阅读README文件中的详细风险说明。
    """

    def initialize(self):
        """初始化策略20250208"""
        import threading
        STRATEGY_VERSION = "v5.3.8"
        try:
            self._position_lock = threading.RLock()
            # self._order_lock = threading.RLock()

            # 初始化基本数据结构
            self.positions = {}          # 记录每个网格的持仓
            self.grid_prices = []        # 存储网格价格
            self.position_records = {}   # 记录每个网格的交易详情
            self.high_positions = {}     # 记录高位网格的持仓
            self.high_records = {}       # 记录高位网格的交易详情
            self.manual_positions = {}   # 记录手动持仓(隔离模式)
            self.total_position = 0      # 总持仓数量
            self.is_initialized = False  # 网格是否已初始化
            self.start_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            # self.last_trade_time = None  # 上次交易时间
            
            # 20250311: 添加订单记录和待处理订单集合
            self.order_records = {}      # 订单记录字典
            self.pending_orders = set()  # 待处理订单集合
            
            # 20250311: 添加策略启动标志，用于持仓同步逻辑
            self.strategy_started = False
            
            # 20250311: 初始化周期交易状态
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            self.current_period_trades = {
                'period': current_time.strftime('%Y%m%d_%H%M'),
                'buy_count': 0,
                'sell_count': 0,
                'grids': set()
            }
            
            # 调用约定函数，注意这里把ignore_isolation的初始化移到global_variables之后
            self.trigger_symbols()
            self.custom_indicator()
            self.global_variables()
            
            # 20250311: 根据全局变量设置隔离模式
            self.ignore_isolation = self.use_isolation
            if self.ignore_isolation:
                print("[初始化完成] 策略运行在隔离模式下")
            
            # 输出关键参数设置 - 无论是否调试模式都显示
            print("\n[策略参数设置]")
            print(f"策略版本: {STRATEGY_VERSION}")
            print(f"交易标的: {self.stock}")
            print(f"最大总持仓: {self.max_total_position}股")
            print(f"单次交易数量: {self.min_order_quantity}股")
            print(f"单个网格持仓上限: {self.position_limit}股")
            print(f"网格间距/盈利标准: {self.grid_percentage:.2%}")
            print(f"网格数量: {self.grid_num}")
            print(f"价格区间: [{self.min_price_range:.2f}-{self.max_price_range:.2f}]")
            print(f"隔离模式: {'开启' if self.use_isolation else '关闭'}")
            print(f"金字塔加仓: {'开启' if self.use_pyramid else '关闭'}")
            print(f"网格重置后立即尝试买入: {'是' if self.buy_after_reset else '否'}")
            
            print("[初始化完成]，网格交易策略v5.3.8已启动，完成所有必要设置")
            print("[初始化完成] 网格交易策略v5.3.8已准备就绪，开始运行")
            
        except Exception as e:
            print(f"初始化策略时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())

    def trigger_symbols(self):
        """定义交易标的20250208"""
        try:
            self.stock = declare_trig_symbol()
            print(f"[标的设置完成] 当前交易标的为：{self.stock}")
        except Exception as e:
            print(f"设置交易标的时发生错误: {str(e)}")

    def custom_indicator(self):
        """设置技术指标20250208"""
        try:
            self.register_indicator(
                indicator_name='MA',
                script='MA5:MA(CLOSE,5),COLORFF8D1E;',
                param_list=[]
            )
            print("[技术指标初始化完成] 已成功加载自定义技术指标")
        except Exception as e:
            print(f"设置技术指标时发生错误: {str(e)}")

    def global_variables(self):
        """定义全局变量20250208"""
        try:
            # 用户可配置参数
            self.max_total_position = show_variable(500, GlobalType.INT, "最大总持仓")
            self.min_order_quantity = show_variable(20, GlobalType.INT, "单次交易数量")
            self.position_limit = show_variable(80, GlobalType.INT, "单个网格持仓上限")

            self.grid_percentage = show_variable(0.03, GlobalType.FLOAT, "网格间距/盈利标准")
            self.grid_num = show_variable(10, GlobalType.INT, "网格数量")
            
            self.max_capital_usage = show_variable(0.9, GlobalType.FLOAT, "最大资金使用率")

            self.use_trade_records = show_variable(True, GlobalType.BOOL, "使用成交记录恢复持仓")
            self.trade_record_days = show_variable(31, GlobalType.INT, "成交记录查询天数(1-31)")
            self.position_sync_retry = show_variable(3, GlobalType.INT, "持仓同步重试次数")
            self.is_backtest = show_variable(False, GlobalType.BOOL, "是否回测环境")
        
            # 20250117：增加开关，"网格重置后是否立即尝试买入" ，默认"是"
            self.buy_after_reset = show_variable(True, GlobalType.BOOL, "网格重置后立即尝试开仓")
            # 20250117：增加开关，"减少日志冗余"，默认"否"
            self.verbose_log = show_variable(False, GlobalType.BOOL, "是否输出详细调试日志（仅调试时打开）")
            # 20250208：增加开关，"金字塔加仓"，默认"否"
            self.use_pyramid = show_variable(False, GlobalType.BOOL, "是否启用金字塔加仓")

            # 20250310：增加价格区间限制功能
            self.use_price_range = show_variable(True, GlobalType.BOOL, "启用价格区间限制")
            self.min_price_range = show_variable(0.0, GlobalType.FLOAT, "价格区间下限")
            self.max_price_range = show_variable(999999.0, GlobalType.FLOAT, "价格区间上限")
            
            # 20250311：增加隔离模式开关，默认开启
            self.use_isolation = show_variable(True, GlobalType.BOOL, "启用隔离模式")

            print("全局变量设置完成")
            
        except Exception as e:
            print(f"设置全局变量时发生错误: {str(e)}")

    def check_strategy_status(self):
        """
        20250305 添加价格区间检查
        检查策略运行状态20250208
        1. 对比 actual_position 与 self.total_position，如不一致，则先做一次"从成交查询"校准
        2. 如果仍不一致，就告警并返回False
        """
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            running_hours = (current_time - self.start_time).total_seconds() / 3600
            
            # 使用新的API获取实际持仓
            position_symbols = get_position_symbol()
            actual_position = 0
            if position_symbols and self.stock in position_symbols:
                actual_position = available_qty(self.stock)
                
            if abs(actual_position - self.total_position) > 0.001:
                # 再尝试一次从成交记录拉取并更新持仓
                if self.verbose_log:
                    print(f"检测到持仓不一致，尝试再次从成交记录核对...")
                if not self._verify_and_fix_positions():
                    self.send_alert(
                        f"警告:策略运行{running_hours:.1f}小时后仍发现持仓不一致, "
                        f"实际持仓={actual_position}, 策略记录={self.total_position}"
                    )
                    return False

            # 检查网络或行情数据
            if not current_price(self.stock):
                self.send_alert(f"警告:无法获取行情数据,请检查网络连接")
                return False
                
            # 检查价格是否在允许区间内20250305
            latest_price = current_price(self.stock)
            if not self._is_price_in_range(latest_price):
                # 这里我们只打印警告，不返回False，因为在handle_data中会再次检查
                if self.verbose_log:
                    print(f"警告: 当前价格 {latest_price:.2f} 超出设定区间 [{self.min_price_range:.2f}-{self.max_price_range:.2f}]")
                    
            return True
            
        except Exception as e:
            print(f"检查策略状态时发生错误: {str(e)}")
            return False

    def send_alert(self, message):
        """发送策略告警20250208"""
        try:
            print(f"策略告警: {message}")
        except Exception as e:
            print(f"发送告警时发生错误: {str(e)}")

    def _recover_positions(self):
        """
        恢复已有持仓状态，在策略重启时直接执行手动隔离模式20250208。
        """
        try:
            # 使用新的API获取实际持仓
            position_symbols = get_position_symbol()
            actual_position = 0
            if position_symbols and self.stock in position_symbols:
                actual_position = available_qty(self.stock)
                
            if actual_position == 0:
                return True

            print(f"检测到已有持仓{actual_position}股，执行手动隔离模式。")
            print("[隔离模式] 所有现有持仓已转移至手动隔离区域，不参与策略操作")

            # 尝试通过成交记录获取持仓详细信息用于隔离显示
            positions_from_trades = self._get_positions_from_trades()
            if positions_from_trades:
                self.manual_positions = positions_from_trades['positions'].copy()
                self.manual_records = positions_from_trades['records'].copy()
            else:
                # 若无法从成交记录恢复，则以当前价格和实际持仓简单记录
                current_px = current_price(self.stock)
                avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
                if not avg_cost:
                    avg_cost = current_px
                self.manual_positions = {current_px: actual_position}
                self.manual_records = {
                    current_px: {
                        'buy_price': avg_cost,
                        'quantity': actual_position,
                        'update_time': time.time()
                    }
                }

            # 清空策略自身的网格持仓相关数据
            self.positions = {}
            self.position_records = {}
            self.high_positions = {}
            self.high_records = {}
            self.total_position = 0

            print("[隔离模式] 已清空策略持仓记录，重新开始运行")
            self._print_manual_positions()

            self.ignore_isolation = True
            print("已开启[隔离模式]，本周期内将不再试图校准持仓。")

            self.is_initialized = True
            return True

        except Exception as e:
            print(f"恢复持仓状态时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return False
        
    def _print_manual_positions(self):
        """打印手动/隔离仓位分布20250208"""
        if not self.manual_positions:
            print("\n当前没有被隔离的手动仓位。")
            return
        
        total_manual = sum(self.manual_positions.values())
        print("\n手动/隔离仓位分布:")
        for price in sorted(self.manual_positions.keys()):
            qty = self.manual_positions[price]
            if qty <= 0:
                continue
            record = self.manual_records.get(price, {})
            cost = record.get('buy_price', price)
            print(f"  价格={price:.2f}, 数量={qty}, 成本={cost:.2f}")
        print(f"手动/隔离仓位总数: {total_manual}")
    
    def _check_profit_before_reset(self, current_price):
        """
        20250209在网格重置前检查是否有盈利机会，如果有就卖出。
        现在只保留轻量逻辑，直接调用 _check_profit_and_execute_sell(...)
        """
        print("[_check_profit_before_reset] -> 调用通用检查, skip_period_check=True")
        return self._check_profit_and_execute_sell(
            current_price=current_price,
            skip_period_check=True,
            reason='reset'
        )

    def _migrate_positions_to_new_grids(self, actual_position, old_positions, old_records, new_grid_prices):
        """
        将持仓迁移到新网格,保留高位网格信息20250208
        """
        try:
            new_positions = {}
            new_records = {}
            new_high_positions = {}
            new_high_records = {}
                
            # 获取新网格的最高价格
            highest_new_grid = new_grid_prices[0]
            for price in new_grid_prices[1:]:
                if price > highest_new_grid:
                    highest_new_grid = price
            print(f"\n开始迁移持仓（新网格最高价格: {highest_new_grid:.1f}）")
            
            # 1. 先处理原有的高位网格持仓
            if self.high_positions:
                print("\n处理原有高位网格持仓:")
                for price, qty in sorted(self.high_positions.items()):
                    if qty <= 0:
                        continue
                        
                    record = self.high_records[price]
                    # 判断是否可以进入新网格
                    if price <= highest_new_grid:
                        nearest_grid = self._find_nearest_value(price, price_list=new_grid_prices)
                        if nearest_grid:
                            print(f"高位网格 {price:.1f} 的 {qty}股可以迁移到新网格 {nearest_grid:.1f}")
                            current_qty = new_positions.get(nearest_grid, 0)
                            if current_qty + qty <= self.position_limit:
                                new_positions[nearest_grid] = current_qty + qty
                                new_records[nearest_grid] = record.copy()
                                new_records[nearest_grid]['quantity'] = current_qty + qty
                            else:
                                # 超出新网格容量，保持为高位网格
                                print(f"因超出网格容量限制，保持为高位网格")
                                new_high_positions[price] = qty
                                new_high_records[price] = record.copy()
                    else:
                        print(f"保持高位网格 {price:.1f} 的 {qty}股")
                        new_high_positions[price] = qty
                        new_high_records[price] = record.copy()
            
            # 2. 处理现有持仓
            print("\n处理当前活动网格持仓:")
            for old_price, qty in sorted(old_positions.items()):
                if qty <= 0:
                    continue
                    
                record = old_records[old_price]
                
                # 判断是否应该成为高位网格
                if old_price > highest_new_grid:
                    print(f"网格 {old_price:.1f} 的 {qty}股 高于新网格范围，转为高位网格")
                    new_high_positions[old_price] = qty
                    new_high_records[old_price] = record.copy()
                    continue
                    
                # 在新网格范围内的持仓正常迁移
                nearest_grid = self._find_nearest_value(old_price, price_list=new_grid_prices)
                if nearest_grid:
                    print(f"迁移 {old_price:.1f} 的 {qty}股 到网格 {nearest_grid:.1f}")
                    current_qty = new_positions.get(nearest_grid, 0)
                    if current_qty + qty <= self.position_limit:
                        new_positions[nearest_grid] = current_qty + qty
                        new_records[nearest_grid] = record.copy()
                        new_records[nearest_grid]['quantity'] = current_qty + qty
                    else:
                        print(f"超出网格 {nearest_grid:.1f} 容量限制，转为高位网格")
                        new_high_positions[old_price] = qty
                        new_high_records[old_price] = record.copy()
                else:
                    print(f"无法为价格 {old_price:.1f} 找到合适的网格")
                    return False
            
            # 验证迁移结果
            total_active = sum(new_positions.values())
            total_high = sum(new_high_positions.values())
            print("\n迁移结果验证:")
            print(f"活动网格持仓: {total_active}股")
            print(f"高位网格持仓: {total_high}股")
            print(f"持仓总数: {total_active + total_high}股")
            
            # 使用新的API再次获取实际持仓
            position_symbols = get_position_symbol()
            actual_position = 0
            if position_symbols and self.stock in position_symbols:
                actual_position = available_qty(self.stock)
            print(f"实际持仓: {actual_position}股")
            
            if total_active + total_high != actual_position:
                print(f"警告: 持仓不一致 - 活动网格:{total_active} + 高位网格:{total_high} != 实际持仓:{actual_position}")
                return False
                    
            # 更新网格信息
            self.grid_prices = new_grid_prices
            self.positions = new_positions
            self.position_records = new_records
            self.high_positions = new_high_positions
            self.high_records = new_high_records
            self.total_position = total_active + total_high
            
            print("\n迁移后网格状态:")
            self._print_grid_status(show_all=True)
            
            return self._verify_positions()
                
        except Exception as e:
            print(f"迁移持仓到新网格时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return False

    def _force_sync_position(self, actual_position, avg_cost=None, grid_price=None):
        """
        强制同步持仓到实际状态20250208
        Args:
            actual_position: int, 实际持仓数量
            avg_cost: float, 可选的成本价
            grid_price: float, 可选的网格价格
        Returns:
            bool: 同步是否成功
        """
        try:
            if actual_position == 0:
                self.positions = {}
                self.position_records = {}
                self.total_position = 0
                if self.verbose_log:
                    print("强制同步: 清空所有持仓记录")
                return True
                
            # 如果未提供成本价，获取平均成本价
            if avg_cost is None:
                avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
                if not avg_cost:
                    avg_cost = current_price(self.stock)
            
            # 如果未提供网格价格，找到最近的网格
            if grid_price is None:
                grid_price = self._find_nearest_value(avg_cost)
                
            if not grid_price:
                print("无法找到合适的网格来分配持仓")
                return False
                
            # 强制更新持仓记录
            self.positions = {grid_price: actual_position}
            self.position_records = {
                grid_price: {
                    'buy_price': avg_cost,
                    'quantity': actual_position,
                    'update_time': time.time()
                }
            }
            self.total_position = actual_position
            
            print(f"强制同步持仓完成 - 网格:{grid_price}, 持仓:{actual_position}, 成本:{avg_cost}")
            return True
            
        except Exception as e:
            print(f"强制同步持仓失败: {str(e)}")
            return False

    def _verify_and_fix_positions(self):
        """验证并修正持仓数据，如果仍无法修正，则返回False"""
        # 如果忽略隔离，则直接pass
        if self.ignore_isolation:
            if self.verbose_log:
                print("检测到隔离模式，跳过持仓修正流程，让策略单独运行。")
            return True
            
        try:
            # 使用新的API获取实际持仓
            position_symbols = get_position_symbol()
            actual_position = 0
            if position_symbols and self.stock in position_symbols:
                actual_position = available_qty(self.stock)
            
            if self.verbose_log:
                print(f"当前实际持仓: {actual_position}股")

            # 如果是策略首次运行，且实际持仓为0，则清空记录
            if actual_position == 0:
                if not hasattr(self, 'strategy_started'):
                    # 无实际持仓，则清空记录
                    self.positions = {}
                    self.position_records = {}
                    self.high_positions = {}
                    self.high_records = {}
                    self.total_position = 0
                    if self.verbose_log:
                        print("实际持仓为0，已清空所有持仓记录")
                    # 标记策略已启动
                    self.strategy_started = True
                    return True
                elif self.total_position > 0:
                    # 策略已启动且有记录，保留记录
                    print(f"警告: 实际持仓为0，但策略记录持仓为{self.total_position}股")
                    print("保留策略持仓记录，等待下次交易")
                    return True
            
            # 如果持仓不一致，需要修正
            if abs(self.total_position - actual_position) > 0.001:
                print(f"持仓不一致 - 策略记录:{self.total_position}, 实际:{actual_position}")
                # 优先从成交记录恢复
                positions_from_trades = self._get_positions_from_trades()
                if positions_from_trades:
                    if self.verbose_log:
                        print("从成交记录恢复持仓分布成功，进行二次验证")
                    self.positions = positions_from_trades['positions']
                    self.position_records = positions_from_trades['records']
                    self.total_position = positions_from_trades['total']
                    # 验证
                    return self._verify_positions()

                # 如果无法从成交记录恢复，使用平均成本价方式
                avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
                if not avg_cost:
                    avg_cost = current_price(self.stock)

                # 找到最适合的网格
                nearest_grid = self._find_nearest_value(avg_cost)
                if not nearest_grid:
                    print("无法找到合适的网格，需要重新初始化网格")
                    return False
                
                self._force_sync_position(actual_position, avg_cost, nearest_grid)
                return self._verify_positions()

            # 标记策略已启动
            self.strategy_started = True
            return self._verify_positions()
                
        except Exception as e:
            print(f"验证和修正持仓时发生错误: {str(e)}")
            return False

    def _verify_positions(self):
        """验证持仓数据一致性20250208"""
        try:
            # 使用新的API获取实际持仓
            position_symbols = get_position_symbol()
            actual_position = 0
            if position_symbols and self.stock in position_symbols:
                actual_position = available_qty(self.stock)
            
            # 在隔离模式下计算虚拟持仓
            if self.ignore_isolation:
                # 计算手动仓位总数
                manual_total = sum(self.manual_positions.values())
                # 如果 manual_total>actual_position，就设成0，防止负数
                virtual_position = max(0, actual_position - manual_total)
                if self.verbose_log:
                    print(f"[隔离模式] 实际持仓={actual_position}, 手动={manual_total}, 虚拟持仓={virtual_position}")
            else:
                virtual_position = actual_position
                if self.verbose_log:
                    print(f"[非隔离模式] 实际持仓={actual_position}")
            
            # 计算策略记录的总持仓
            total_active = sum(qty for qty in self.positions.values() if qty > 0)
            total_high = sum(qty for qty in self.high_positions.values() if qty > 0)
            total_positions = total_active + total_high
            
            if self.verbose_log:
                print(f"\n[持仓验证]")
                print(f"活动网格持仓: {total_active}股")
                print(f"高位网格持仓: {total_high}股")
                print(f"持仓总数: {total_positions}股")
                print(f"实际持仓: {actual_position}股 (虚拟持仓: {virtual_position}股)")
            
            # 使用虚拟持仓进行验证
            if abs(total_positions - virtual_position) > 0.01:
                print(f"持仓不一致 - 虚拟:{virtual_position} != 策略记录:{total_positions}")
                if self.verbose_log:
                    print(f"[持仓不一致详情]")
                    print(f"差异: {total_positions - virtual_position}股")
                    print(f"隔离模式: {self.ignore_isolation}")
                    if self.ignore_isolation:
                        print(f"手动/隔离持仓: {sum(self.manual_positions.values())}股")
                        print(f"手动/隔离持仓详情:")
                        for price, qty in sorted(self.manual_positions.items()):
                            if qty > 0:
                                print(f"  价格={price:.2f}, 数量={qty}")
                return False
            
            self.total_position = total_positions
            return True
            
        except Exception as e:
            print(f"验证持仓失败: {str(e)}")
            return False

    def _should_reset_grid(self, latest_price):
        """判断是否需要重置网格20250208"""
        try:
            if not self.grid_prices:
                return True
                    
            closest_grid = self._find_nearest_value(latest_price)
            if closest_grid:
                deviation = abs(latest_price - closest_grid) / closest_grid
                if deviation > self.grid_percentage:
                    # 检查活动网格中是否存在高于当前价格的持仓
                    high_position = sum(qty for grid, qty in self.positions.items() 
                                    if grid > latest_price)
                    if high_position > 0:
                        print(f"价格偏离网格过大: {deviation:.2%}, 但当前网格存在高位持仓{high_position}, 执行网格保存")
                        return True
                    else:
                        print(f"价格偏离网格过大: {deviation:.2%}, 且无高位持仓, 执行网格重置")
                        return True
            return False
                
        except Exception as e:
            print(f"检查网格重置时发生错误: {str(e)}")
            return False

    def _find_nearest_value(self, target_price, price_list=None):
        """在给定的价格列表中查找最接近目标价格的值20250208"""
        try:
            if price_list is None:
                price_list = self.grid_prices
            if not price_list:
                return None
            target_price = int(target_price * 10) / 10  # 保持1位小数
            nearest = price_list[0]
            min_distance = abs(target_price - nearest)
            for price in price_list[1:]:
                distance = abs(target_price - price)
                if distance < min_distance:
                    min_distance = distance
                    nearest = price
            return nearest
        except Exception as e:
            print(f"查找最近价格失败: {str(e)}")
            return None        

    def _is_new_period(self, current_time):
        """判断是否是新的交易周期20250208"""
        current_period = current_time.strftime('%Y%m%d_%H%M')
        if current_period != self.current_period_trades['period']:
            # 新周期，重置交易状态
            self.current_period_trades = {
                'period': current_period,
                'buy_count': 0,
                'sell_count': 0,
                'grids': set()
            }
            return True
        return False

    def _can_trade_in_period(self, grid_price, is_buy=True):
        """检查是否可以在当前周期交易20250208"""
        if is_buy and self.current_period_trades['buy_count'] > 0:
            print(f"当前周期已执行过买入操作")
            return False
        if not is_buy and self.current_period_trades['sell_count'] > 0:
            print(f"当前周期已执行过卖出操作")
            return False
        if grid_price in self.current_period_trades['grids']:
            print(f"当前周期已在网格{grid_price:.1f}执行过交易")
            return False
        return True

    def _update_period_trade_status(self, grid_price, is_buy=True):
        """更新周期交易状态20250208"""
        if is_buy:
            self.current_period_trades['buy_count'] += 1
        else:
            self.current_period_trades['sell_count'] += 1
        if grid_price is not None:
            self.current_period_trades['grids'].add(grid_price)

    def handle_data(self):
        """主要策略逻辑20250305"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            
            # 定期检查策略状态
            if not self.check_strategy_status():
                print("策略状态异常，跳过本次交易")
                return
                
            # 获取当前价格
            latest_price = current_price(self.stock)
            if not latest_price:
                return
                    
            print(f"\n当前时间: {current_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"当前价格: {latest_price:.1f}")

            # 检查价格是否在允许区间内
            if not self._is_price_in_range(latest_price):
                return
            
            # 检查是否新周期
            if not self._is_new_period(current_time):
                print(f"当前周期已执行交易, 等待下一周期...")
                return
                
            # 先检查高位网格是否有盈利机会
            high_grid_profit = self._check_high_grid_profit(latest_price)
            
            # 检查是否需要重置网格
            if not self.is_initialized or self._should_reset_grid(latest_price):
                self._initialize_grids(latest_price)
                self.is_initialized = True
                return
                
            # 再检查普通网格是否有盈利机会
            if not high_grid_profit and self._check_and_execute_sell(latest_price):
                self.last_trade_time = current_time
                return
                
            # 找到当前价格所属网格
            current_grid = self._find_nearest_value(latest_price)
            if not current_grid:
                return
                    
            print(f"当前所属网格: {current_grid:.1f}")
            
            # 检查是否可以买入
            if not self._can_trade_in_period(current_grid, is_buy=True):
                return
                
            # 执行买入
            if self._place_buy_order(current_grid, latest_price):
                self._update_period_trade_status(current_grid, is_buy=True)
                self.last_trade_time = current_time
                
        except Exception as e:
            print(f"策略运行时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())

    def _place_order(self, qty, side=OrderSide.BUY, is_market=True, limit_price=None):
        """
        20250208，新增统一下单接口，无论回测还是实盘/模拟，都先调用 place_market/place_limit 下单，返回 order_id。
        """
        try:
            order_id = None
            if is_market:
                order_id = place_market(
                    symbol=self.stock,
                    qty=qty,
                    side=side,
                    time_in_force=TimeInForce.DAY
                )
            else:
                # 若需要做限价单，在此调用 place_limit
                if not limit_price:
                    limit_price = current_price(self.stock)
                order_id = place_limit(
                    symbol=self.stock,
                    price=limit_price,
                    qty=qty,
                    side=side,
                    time_in_force=TimeInForce.DAY
                )

            if not order_id:
                print("订单创建失败")
                return None
            
            return order_id
        except Exception as e:
            print(f"下单异常: {str(e)}")
            return None

    def _place_buy_order(self, grid_price, latest_price):
        """
        20250305 增加订单前再次检查价格区间，20250208统一逻辑: 
        1) 先计算要买多少, 以及网格上限多少
        2) 检查当前网格与总持仓限制
        3) 调用 _place_order(...) 提交订单
        4) 统一使用 _confirm_order，注意回测和实盘的参数区别
        5) 若成交成功, 更新本地持仓
        """
        import time
        try:

            # 再次检查价格是否在允许区间内
            if not self._is_price_in_range(latest_price):
                return False

            # 1) 计算下单数量 & 网格上限
            trade_qty, grid_limit = self._calculate_trade_quantity(grid_price)
            if trade_qty <= 0:
                print("买入数量<=0，跳过")
                return False

            current_pos = self.positions.get(grid_price, 0)
            # 2) 检查单网格上限
            if current_pos + trade_qty > grid_limit:
                allowed = grid_limit - current_pos
                if allowed <= 0:
                    print(f"网格{grid_price:.1f}已达上限{grid_limit}，跳过本次买入")
                    return False
                else:
                    print(f"原本需买{trade_qty}股，但超出网格上限，截断为{allowed}股")
                    trade_qty = allowed

            # 检查总持仓上限
            if self.total_position + trade_qty > self.max_total_position:
                can_buy = self.max_total_position - self.total_position
                if can_buy <= 0:
                    print(f"总持仓{self.total_position}已达上限{self.max_total_position}，放弃买单")
                    return False
                else:
                    print(f"下单数量{trade_qty}将使总持仓超上限，截断为{can_buy}")
                    trade_qty = can_buy

            if trade_qty <= 0:
                return False

            # 3) 计算一个大致买价, 仅用于日志 or 限价单
            price_offset = 0.01
            adjusted_price = latest_price - price_offset
            ask_price = ask(self.stock, level=1)
            if not ask_price:
                ask_price = adjusted_price

            print(f"[订单提交] 尝试买入 {self.stock}：网格={grid_price:.2f}, 数量={trade_qty}股, "
                f"预期价格={ask_price:.2f}")

            # 4) 调用 _place_order(...) 下单 (默认市价单)
            start_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            order_id = self._place_order(trade_qty, side=OrderSide.BUY, is_market=True, limit_price=None)
            if not order_id:
                print("买入订单创建失败")
                return False

            self.order_records[order_id] = {
                'side': OrderSide.BUY,
                'grid_price': grid_price,
                'qty': trade_qty
            }
            self.pending_orders.add(order_id)

            # 5) 等待成交 (回测 or 实盘)
            success, avg_price = self._confirm_order(
                order_id=order_id,
                side=OrderSide.BUY,
                expected_qty=trade_qty,
                start_time=start_time,
                timeout=60,       # 或者加 if self.is_backtest 切换
                interval=2
            )

            self.pending_orders.discard(order_id)

            # 6) 若成功成交, 更新持仓
            if success:
                used_price = float(f"{avg_price:.2f}") if avg_price else float(f"{ask_price:.2f}")
                self._update_position(grid_price, trade_qty, used_price, is_buy=True)
                return True
            else:
                print(f"[订单提交] 买入订单{order_id}未在预期时间内确认成交")
                return False

        except Exception as e:
            print(f"执行买入订单时发生错误: {str(e)}")
            return False

    def _get_positions_from_trades(self):
        """
        主入口：从历史成交记录中恢复持仓分布20250208
        若恢复成功，返回 {'positions':..., 'records':..., 'total':...}，否则返回 None
        """
        try:
            print("\n=== 从成交记录恢复持仓状态 ===")
            
            # 使用新的API获取实际持仓
            position_symbols = get_position_symbol()
            actual_position = 0
            if position_symbols and self.stock in position_symbols:
                actual_position = available_qty(self.stock)
                
            if actual_position == 0:
                print("当前无持仓，跳过恢复")
                return None
            print(f"当前实际持仓: {actual_position}股")

            # ============= 1. 获取历史成交列表 =============
            trades = self._fetch_trades()
            if not trades:
                print("无法获取有效的成交记录")
                return None
            
            # ============= 2. 构建 position_map =============
            position_map = self._build_position_map(trades, actual_position)
            if not position_map:
                # 说明构建不成功，或跟实际持仓对不上
                return None
            
            # ============= 3. 分配到网格 / 高位网格 =============
            assign_result = self._assign_positions_to_grid(position_map, actual_position)
            if not assign_result:
                print("警告：网格分配失败，可能与实际持仓不符")
                return None
            
            # 将高位网格信息赋值给策略对象
            self.high_positions = assign_result['high_positions']
            self.high_records = assign_result['high_records']
            
            return {
                'positions': assign_result['grid_positions'],
                'records': assign_result['grid_records'],
                'total': assign_result['total_position']
            }
        
        except Exception as e:
            print(f"从成交记录恢复持仓时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return None

    def _fetch_trades(self):
        """
        子函数：查询并返回按时间排序的有效成交列表20250208
        """
        import datetime
        # 1. 动态计算查询区间
        today = device_time(TimeZone.DEVICE_TIME_ZONE).date()
        start_date = today - datetime.timedelta(days=self.trade_record_days)
        end_date = today  # 或者再 +1 天
        
        start_str = start_date.strftime("%Y-%m-%d")
        end_str = end_date.strftime("%Y-%m-%d")
        
        print(f"查询区间: {start_str} ~ {end_str} (共{self.trade_record_days}天)")
        
        # 2. 获取 execution_id
        execution_ids = request_executionid(symbol=self.stock, start=start_str, end=end_str)
        if not execution_ids:
            print("无法获取成交记录")
            return None
        print(f"获取到 {len(execution_ids)} 条成交记录")
        
        # 3. 遍历 execution_id 调用 execution_* 接口，构造 trades
        trades = []
        for eid in execution_ids:
            status = execution_status(eid)
            if status == "OK":
                price = execution_price(eid)
                qty = execution_qty(eid)
                side = execution_side(eid)
                trade_time = execution_time(eid)
                trades.append({
                    'time': trade_time,
                    'price': price,
                    'quantity': qty,
                    'side': side
                })
        
        if not trades:
            print("没有有效的成交信息")
            return None
        
        # 4. 排序
        trades.sort(key=lambda x: x['time'])
        
        # 5. 打印买卖合计
        buy_total = sum(t['quantity'] for t in trades if t['side'] == OrderSide.BUY)
        sell_total = sum(t['quantity'] for t in trades if t['side'] == OrderSide.SELL)
        print(f"总买入:{buy_total}股, 总卖出:{sell_total}股, 净持仓:{buy_total - sell_total}股")
        
        return trades

    def _build_position_map(self, trades, actual_position):
        """
        子函数：将交易记录聚合成一个 position_map (价位 -> 数量)，并验证与实际持仓是否匹配20250208
        """
        # 构建价位持仓
        position_map = {}
        
        for t in trades:
            # 统一保留一位小数
            trade_price = int(t['price'] * 10) / 10
            qty = t['quantity']
            
            if t['side'] == OrderSide.BUY:
                position_map.setdefault(trade_price, 0)
                position_map[trade_price] += qty
            else:
                # 从高价往下扣减
                remaining = qty
                for p in sorted(position_map.keys(), reverse=True):
                    if remaining <= 0:
                        break
                    if position_map[p] > 0:
                        deduct = min(position_map[p], remaining)
                        position_map[p] -= deduct
                        remaining -= deduct
                        if position_map[p] == 0:
                            position_map.pop(p)
        
        # 验证计算结果
        calc_sum = sum(position_map.values())
        if abs(calc_sum - actual_position) > 0.001:
            print(f"警告: position_map计算的持仓({calc_sum}) 与实际持仓({actual_position}) 不匹配")
            return None
        
        return position_map

    def _assign_positions_to_grid(self, position_map, actual_position):
        """
        将 position_map 分配到网格/高位网格，并验证总数20250208
        返回{
            'grid_positions': ...,
            'grid_records': ...,
            'high_positions': ...,
            'high_records': ...,
            'total_position': ...
        }
        """
        latest_price = current_price(self.stock)
        if not latest_price:
            print("无法获取当前价格，跳过网格分配")
            return None

        grid_prices = self._generate_grid_prices(
            base_price=latest_price,
            grid_num=self.grid_num,
            grid_percentage=self.grid_percentage,
            keep_digit=1
        )
        if not grid_prices:
            print("网格生成失败，跳过分配")
            return None

        # 2. 初始化 grid_positions, grid_records
        grid_positions = {p: 0 for p in grid_prices}
        grid_records = {
            p: {'buy_price': 0, 'quantity': 0, 'update_time': time.time()}
            for p in grid_prices
        }
        high_positions = {}
        high_records = {}

        # 3. 找到最高网格价格 —— 直接取 grid_prices 列表最后一个元素
        highest_grid = grid_prices[-1]

        # 4. 遍历 position_map 分配到网格或高位
        for p, qty in sorted(position_map.items()):
            if qty <= 0:
                continue
            if p > highest_grid:
                # 高位网格
                high_positions[p] = qty
                high_records[p] = {
                    'buy_price': p,
                    'quantity': qty,
                    'update_time': time.time()
                }
            else:
                nearest_g = self._find_nearest_value(p, grid_prices)
                if nearest_g:
                    current_qty = grid_positions[nearest_g]
                    new_qty = current_qty + qty
                    grid_positions[nearest_g] = new_qty

                    if current_qty == 0:
                        grid_records[nearest_g] = {
                            'buy_price': p,
                            'quantity': new_qty,
                            'update_time': time.time()
                        }
                    else:
                        # 加权平均成本
                        old_cost = grid_records[nearest_g]['buy_price']
                        new_cost = (old_cost * current_qty + p * qty) / new_qty
                        grid_records[nearest_g]['buy_price'] = new_cost
                        grid_records[nearest_g]['quantity'] = new_qty
                        grid_records[nearest_g]['update_time'] = time.time()
                else:
                    # 连最近网格都找不到，也视为高位
                    high_positions[p] = qty
                    high_records[p] = {
                        'buy_price': p,
                        'quantity': qty,
                        'update_time': time.time()
                    }

        total_grid_position = sum(grid_positions.values())
        total_high_position = sum(high_positions.values())
        total_position = total_grid_position + total_high_position

        # 验证恢复后的持仓是否与实际持仓相符
        if abs(total_position - actual_position) > 0.001:
            print("警告：恢复后的持仓总数与实际不符")
            return None

        return {
            'grid_positions': grid_positions,
            'grid_records': grid_records,
            'high_positions': high_positions,
            'high_records': high_records,
            'total_position': total_position
        }
            
    def _check_high_grid_profit(self, current_price):
        """检查高位网格是否有盈利机会20250208：
        1. 遍历 self.high_positions，如果当前价较其买入价涨幅 >= grid_percentage，则纳入可卖列表。
        2. 若 profitable_grids 非空，调用 _execute_high_grid_sell(...) 执行卖单。
        """
        try:
            if not self.high_positions:
                return False
                
            profitable_grids = []
            total_sell_quantity = 0
            
            for grid_price, qty in self.high_positions.items():
                if qty <= 0:
                    continue
                record = self.high_records.get(grid_price, {})
                buy_price = record.get('buy_price', grid_price)
                price_diff = (current_price - buy_price) / buy_price
                if price_diff >= self.grid_percentage:
                    print(f"高位网格 {grid_price:.1f} 符合盈利条件: 成本={buy_price:.1f}, 盈利={price_diff:.1%}")
                    profitable_grids.append((grid_price, qty, buy_price))
                    total_sell_quantity += qty
            
            if profitable_grids:
                return self._execute_high_grid_sell(profitable_grids, current_price)
                
            return False
        except Exception as e:
            print(f"检查高位网格盈利失败: {str(e)}")
            return False
    
    def _clean_empty_high_grids(self):
        """清理空仓的高位网格记录20250208"""
        try:
            empty_grids = [grid for grid, qty in self.high_positions.items() 
                           if qty <= 0 or grid in self.positions]
            for grid in empty_grids:
                if grid in self.high_positions:
                    print(f"清理高位网格: {grid}")
                    self.high_positions.pop(grid)
                    self.high_records.pop(grid)
        except Exception as e:
            print(f"清理高位网格时发生错误: {str(e)}")

    def _initialize_grids(self, base_price):
        """
        20250305 初始化网格需要考虑价格区间
        初始化或重置网格20250208
        """
        try:
            if self.verbose_log:
                print(f"\n初始化网格 - 基准价格: {base_price}")
            if not base_price or base_price <= 0:
                print("无效的基准价格")
                return False
            if not self.grid_percentage or self.grid_percentage <= 0:
                print("无效的网格间距")
                return False

            # 检查价格是否在允许区间内20250305
            if not self._is_price_in_range(base_price):
                print("基准价格超出允许区间，跳过网格初始化")
                return False

            with self._position_lock:
                # 使用新的API获取实际持仓
                position_symbols = get_position_symbol()
                actual_position = 0
                if position_symbols and self.stock in position_symbols:
                    actual_position = available_qty(self.stock)
                if self.verbose_log:
                    print(f"当前实际持仓: {actual_position}股")

                # 计算网格价格列表
                new_grid_prices = self._generate_grid_prices(
                    base_price=base_price,
                    grid_num=self.grid_num,
                    grid_percentage=self.grid_percentage,
                    keep_digit=1
                )

                if not new_grid_prices:
                    print("网格生成失败，跳过。")
                    return False

                self.base_grid = int(base_price * 10 + 0.5)/10.0

                # 保存当前所有持仓信息（包括普通网格和高位网格）
                old_positions = {k: v for k, v in self.positions.items() if v > 0}
                old_records = {k: v.copy() for k, v in self.position_records.items() if v.get('quantity', 0) > 0}
                old_high_positions = {k: v for k, v in self.high_positions.items() if v > 0}
                old_high_records = {k: v.copy() for k, v in self.high_records.items() if v > 0}

                # 找到新网格的最高价格
                highest_new_grid = new_grid_prices[0]
                for price in new_grid_prices[1:]:
                    if price > highest_new_grid:
                        highest_new_grid = price
                if self.verbose_log:
                    print(f"新网格最高价格: {highest_new_grid:.1f}")

                # 所有高于新网格最高价格的持仓都应该转为高位持仓
                new_high_positions = {}
                new_high_records = {}

                # 1. 处理原有高位网格 - 全部保留
                for price, qty in old_high_positions.items():
                    if qty > 0:
                        new_high_positions[price] = qty
                        new_high_records[price] = old_high_records[price].copy()
                        if self.verbose_log:
                            print(f"保留原有高位网格: {price:.1f}的{qty}股")

                # 2. 处理原有普通网格 - 高于新网格最高价的转为高位网格
                for price, qty in old_positions.items():
                    if qty > 0:
                        if price > highest_new_grid:
                            # 转为高位网格
                            new_high_positions[price] = qty
                            new_high_records[price] = old_records[price].copy()
                            if self.verbose_log:
                                print(f"普通网格 {price:.1f} 的 {qty}股转为高位网格")

                # 初始化新的普通网格
                self.grid_prices = new_grid_prices
                self.positions = {}
                self.position_records = {
                    p: {'buy_price': 0, 'quantity': 0, 'update_time': time.time()}
                    for p in new_grid_prices
                }

                # 3. 尝试将原有普通网格中的持仓迁移到新网格
                for price, qty in old_positions.items():
                    if qty > 0 and price <= highest_new_grid:
                        nearest_grid = self._find_nearest_value(price, new_grid_prices)
                        if nearest_grid:
                            if self.verbose_log:
                                print(f"迁移持仓: 从{price:.1f}到{nearest_grid:.1f}, {qty}股")
                            self.positions[nearest_grid] = qty
                            self.position_records[nearest_grid] = old_records[price].copy()

                # 更新高位网格信息
                self.high_positions = new_high_positions
                self.high_records = new_high_records

                # 更新总持仓
                self.total_position = sum(self.positions.values()) + sum(new_high_positions.values())

                if self.verbose_log:
                    print(f"\n网格重置后状态:")
                    print(f"普通网格持仓: {sum(self.positions.values())}股")
                    print(f"高位网格持仓: {sum(new_high_positions.values())}股")
                    print(f"总持仓: {self.total_position}股")
                    for price, qty in sorted(new_high_positions.items()):
                        if qty > 0:
                            print(f"  高位网格={price:.1f}, 数量={qty}")

                # 显示网格状态
                self._print_grid_status(show_all=True, show_time=False)

                # 如果希望重置后立即开仓
                if self.buy_after_reset:
                    if actual_position < self.max_total_position:
                        current_grid = self._find_nearest_value(base_price, self.grid_prices)
                        if current_grid and self.positions.get(current_grid, 0) == 0:
                            if self.verbose_log:
                                print(f"网格重置后检查到开仓机会: {current_grid:.1f}")
                            self._place_buy_order(current_grid, base_price)

                return True

        except Exception as e:
            print(f"初始化网格时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return False

    def _print_grid_status(self, show_all=True, show_time=False):
        """20250305添加价格区间，打印网格状态20250208"""
        try:
            if not self.verbose_log and not show_all:
                # 非详细模式下只打印关键信息
                print(f"\n总持仓: {self.total_position}股")
                if self.total_position > 0:
                    print("持仓分布:")
                    for grid_price, qty in sorted(self.positions.items()):
                        if qty > 0:
                            record = self.position_records.get(grid_price, {})
                            print(f"  网格 {grid_price:.1f}: {qty}股, 成本={record.get('buy_price', 0):.1f}")
                return

            print("\n[网格状态更新]")

            # 获取最新价格
            latest_price = current_price(self.stock)

            # 显示价格区间信息
            if self.use_price_range:
                in_range = self._is_price_in_range(latest_price)
                range_status = "正常" if in_range else "超出区间"
                print(f"[价格区间]: {self.min_price_range:.2f} - {self.max_price_range:.2f}, 当前: {latest_price:.2f} ({range_status})")

            # 打印活动网格状态
            print("[活动网格状态]:")
            if show_all:
                # 遍历所有网格，包括无持仓网格
                for grid in sorted(self.grid_prices):
                    pos = self.positions.get(grid, 0)
                    record = self.position_records.get(grid, {})
                    status_str = self._format_grid_status(grid, pos, record, latest_price, show_time)
                    print(status_str)
            else:
                # 仅打印有持仓的网格
                for grid_price, qty in sorted(self.positions.items()):
                    if qty > 0:
                        record = self.position_records.get(grid_price, {})
                        status_str = self._format_grid_status(grid_price, qty, record, latest_price, show_time)
                        print(status_str)

            # 打印高位网格状态
            if self.high_positions:
                print("\n[高位网格状态]:")
                for grid, qty in sorted(self.high_positions.items()):
                    if qty > 0 or show_all:
                        record = self.high_records.get(grid, {})
                        status_str = self._format_grid_status(grid, qty, record, latest_price, show_time, high_position=True)
                        print(status_str)

            # 打印总持仓和市值
            total_value = latest_price * self.total_position if latest_price else 0
            print(f"\n[总持仓]: {self.total_position}股 [总市值]: {total_value:.2f} USD")

        except Exception as e:
            print(f"打印网格状态时发生错误: {str(e)}")

    def _format_grid_status(self, grid, pos, record, latest_price, show_time, high_position=False):
        """
        格式化网格状态字符串20250208
        Args:
            grid (float): 网格价格
            pos (int): 持仓数量
            record (dict): 网格的交易记录
            latest_price (float): 当前价格
            show_time (bool): 是否显示更新时间
            high_position (bool): 是否为高位网格
        Returns:
            str: 格式化后的网格状态
        """
        # 基础信息
        status_str = f"网格 {grid:.1f}: 持仓={pos}, 成本={record.get('buy_price', 0):.1f}"
        
        # 盈亏计算
        if pos > 0 and latest_price:
            profit = (latest_price - record.get('buy_price', 0)) * pos
            profit_pct = ((latest_price - record.get('buy_price', 0)) 
                        / record.get('buy_price', 0) * 100 if record.get('buy_price', 0) else 0)
            status_str += f", 盈亏={profit:.2f}({profit_pct:.1f}%)"

        # 更新时间
        if show_time and pos > 0:
            update_time = record.get('update_time', 0)
            if update_time:
                time_str = time.strftime('%H:%M:%S', time.localtime(update_time))
                status_str += f", 更新时间={time_str}"

        # 标注高位网格
        if high_position:
            status_str = "[高位] " + status_str

        return status_str

    def _execute_high_grid_sell(self, profitable_grids, current_price):
        """
        20250208现在只做简单包装，调用通用卖出逻辑 (from_high=True)
        """
        print("[_execute_high_grid_sell] -> 调用通用卖出 _execute_sell_order(..., from_high=True)")
        return self._execute_sell_order(profitable_grids, current_price, from_high=True)

    def _execute_batch_sell(self, profitable_grids, current_price):
        """
        20250208现在只做简单包装，调用通用卖出逻辑 (from_high=False)
        """
        print("[_execute_batch_sell] -> 调用通用卖出 _execute_sell_order(..., from_high=False)")
        return self._execute_sell_order(profitable_grids, current_price, from_high=False)

    def _check_and_execute_sell(self, current_price):
        """
        20250209在常规策略运行时，检查并执行卖出
        """
        print("[_check_and_execute_sell] -> 调用通用检查, skip_period_check=False (默认)")
        return self._check_profit_and_execute_sell(
            current_price=current_price,
            skip_period_check=False,
            reason='normal'
        )

    def _update_position(self, grid_price, qty, price, is_buy=True, batch_mode=False):
        """
        20250209更新本地持仓记录
        :param batch_mode: bool, 表示是否来自批量更新场景。
                        如果 True，则可减少日志输出，或跳过一些立即校验等操作
        """
        try:
            with self._position_lock:
                grid_price = float(f"{grid_price:.2f}")
                price = float(f"{price:.2f}")
                
                if self.verbose_log and not batch_mode:
                    print(f"\n[更新持仓] 网格={grid_price}, 数量={qty}, 操作={'买入' if is_buy else '卖出'}, 价格={price}")
                    print(f"更新前总持仓: {self.total_position}股")
                    print(f"普通网格持仓: {sum(self.positions.values())}股")
                    print(f"高位网格持仓: {sum(self.high_positions.values())}股")

                if is_buy:
                    # 买入合并逻辑
                    current_pos = self.positions.get(grid_price, 0)
                    current_cost = self.position_records.get(grid_price, {}).get('buy_price', 0.0)
                    new_qty = current_pos + qty

                    if current_pos > 0:
                        new_cost = (current_pos * current_cost + qty * price) / new_qty
                    else:
                        new_cost = price

                    self.positions[grid_price] = new_qty
                    self.position_records[grid_price] = {
                        'buy_price': new_cost,
                        'quantity': new_qty,
                        'update_time': time.time()
                    }

                else:
                    # 卖出逻辑
                    if grid_price in self.positions:
                        current_pos = self.positions[grid_price]
                        new_qty = current_pos - qty
                        if new_qty <= 0:
                            self.positions.pop(grid_price, None)
                            self.position_records[grid_price] = {
                                'buy_price': 0.0,
                                'quantity': 0,
                                'update_time': time.time()
                            }
                        else:
                            self.positions[grid_price] = new_qty
                            self.position_records[grid_price].update({
                                'quantity': new_qty,
                                'update_time': time.time()
                            })

                # 修改这一行，确保包含高位网格的持仓
                old_total = self.total_position
                self.total_position = sum(self.positions.values()) + sum(self.high_positions.values())
                
                if self.verbose_log and not batch_mode:
                    print(f"更新后总持仓: {self.total_position}股")
                    print(f"普通网格持仓: {sum(self.positions.values())}股")
                    print(f"高位网格持仓: {sum(self.high_positions.values())}股")
                    print(f"持仓变化: {self.total_position - old_total}股")

                # 在批量模式下，日志可以少打一些
                if not batch_mode:
                    print(f"持仓更新 - 网格:{grid_price:.2f}, 操作:{'买入' if is_buy else '卖出'}, "
                        f"数量:{qty}, 价格:{price:.2f}, 总持仓:{self.total_position}")
                    self._print_grid_status(show_all=False, show_time=True)

                return True

        except Exception as e:
            print(f"_update_position失败: {str(e)}")
            return False

    def _batch_update_positions(self, updates):
        """
        20250209批量更新多个网格的持仓
        :param updates: List of (grid_price, qty, is_buy, price)
        """
        with self._position_lock:
            try:
                # 1. 备份旧状态，用于出错时回滚
                old_positions = self.positions.copy()
                old_records = {k: v.copy() for k, v in self.position_records.items()}
                old_total = self.total_position
                
                if self.verbose_log:
                    print("\n[批量更新前状态]")
                    print(f"总持仓: {self.total_position}股")
                    print(f"普通网格持仓: {sum(self.positions.values())}股")
                    print(f"高位网格持仓: {sum(self.high_positions.values())}股")
                    print(f"更新项数: {len(updates)}")

                # 2. 循环逐条调用 _update_position
                for grid_price, qty, is_buy, price in updates:
                    # 做与 _update_position 里相同的小数保留即可
                    grid_price = float(f"{grid_price:.2f}")
                    price = float(f"{price:.2f}")
                    
                    if self.verbose_log:
                        print(f"更新: 网格={grid_price}, 数量={qty}, 操作={'买入' if is_buy else '卖出'}, 价格={price}")

                    success = self._update_position(
                        grid_price=grid_price,
                        qty=qty,
                        price=price,
                        is_buy=is_buy,
                        batch_mode=True   # 这里传 True，减少日志干扰
                    )
                    if not success:
                        # 如果单次更新失败，就进行回滚
                        print("[_batch_update_positions] 单条更新失败，尝试回滚")
                        self.positions = old_positions
                        self.position_records = old_records
                        self.total_position = old_total
                        return False

                # 3. 全部更新完成后做一次验证
                if not self.ignore_isolation:
                    if not self._verify_positions():
                        print("[_batch_update_positions] 批量更新后持仓验证失败，尝试强制同步...")
                        if not self._force_sync_position(position_holding_qty(self.stock)):
                            print("强制同步失败，执行回滚")
                            self.positions = old_positions
                            self.position_records = old_records
                            self.total_position = old_total
                            return False

                # 4. 如果需要，也可在此打印一次最终网格状态 (可选)
                print(f"批量更新完成，总持仓:{self.total_position}")
                
                if self.verbose_log:
                    print("\n[批量更新后状态]")
                    print(f"总持仓: {self.total_position}股")
                    print(f"普通网格持仓: {sum(self.positions.values())}股")
                    print(f"高位网格持仓: {sum(self.high_positions.values())}股")
                    
                self._print_grid_status(show_all=False, show_time=True)

                return True

            except Exception as e:
                print(f"批量更新持仓失败: {str(e)}")
                # 回滚
                self.positions = old_positions
                self.position_records = old_records
                self.total_position = old_total
                return False

    def _calculate_trade_quantity(self, grid_price):
        """
        20250208根据 use_pyramid 参数，决定买入数量：
        - 若 use_pyramid=False:  固定 min_order_quantity 并严格遵守 position_limit
        - 若 use_pyramid=True :  金字塔加仓(自定义倍数) 并可动态放大单网格上限

        返回: (trade_qty, grid_limit)
            trade_qty   -> 本次应下单数量
            grid_limit  -> 本次允许的单网格上限(可能=position_limit或放大)
        """
        base_qty = self.min_order_quantity

        if not self.use_pyramid:
            # 传统模式: 直接用 min_order_quantity
            trade_qty = base_qty
            grid_limit = self.position_limit  # 固定单网格上限
            if self.verbose_log:
                print(f"[传统模式] 单次买入={trade_qty}, 网格上限={grid_limit}")
            return trade_qty, grid_limit

        else:
            # 金字塔模式: 举例使用简易序列
            pyramid_sequence = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]

            # 若尚未设定 base_grid, 就以中间网格或当前grid_price当做基准
            if not hasattr(self, 'base_grid') or not self.base_grid:
                if self.grid_prices:
                    mid_idx = len(self.grid_prices) // 2
                    self.base_grid = self.grid_prices[mid_idx]
                else:
                    self.base_grid = grid_price

            try:
                base_index = self.grid_prices.index(self.base_grid)
            except ValueError:
                base_index = 0

            try:
                this_index = self.grid_prices.index(grid_price)
            except ValueError:
                this_index = base_index

            down_level = base_index - this_index
            if down_level < 0:
                down_level = 0
            if down_level >= len(pyramid_sequence):
                down_level = len(pyramid_sequence) - 1

            multiplier = pyramid_sequence[down_level]
            trade_qty = base_qty * multiplier

            # 若想在金字塔模式下对单网格上限也做相应放宽:
            grid_limit = self.position_limit * multiplier

            if self.verbose_log:
                print(f"[金字塔模式] 网格={grid_price:.2f}, 下沉层数={down_level}, 倍数={multiplier}, "
                    f"买入数量={trade_qty}, 动态上限={grid_limit}")
            return trade_qty, grid_limit

    def _execute_sell_order(self, profitable_grids, current_price, from_high=False):
        """
        20250305 卖出订单执行前检查价格区间，20250208通用卖出逻辑，统一处理：
        1. 计算总卖出数量 total_quantity
        2. 判断周期交易限制
        3. 下单 -> 等待成交 (区分回测/实盘)
        4. 成功后更新持仓 (高位网格 or 普通网格)
        5. 更新周期交易信息 & 打印状态
        """
        import time
        try:
            # 检查价格是否在允许区间内20250305
            # 注意：卖出时我们可以选择即使价格超出区间也允许卖出，以控制风险
            # 目前执行严格遵循区间限制，如果希望价格超出也可卖，请注释下面的代码
            if not self._is_price_in_range(current_price):
                return False
            
            # 1. 计算总卖出数量
            total_quantity = sum(item[1] for item in profitable_grids)
            if total_quantity <= 0:
                return False

            # 2. 同周期交易限制
            if not self._can_trade_in_period(None, is_buy=False):
                print("当前周期已执行过卖出操作，跳过。")
                return False

            print(f"[通用卖出] 即将卖出 {total_quantity} 股, from_high={from_high}")

            # 调试信息：打印当前持仓状态
            if self.verbose_log:
                print("\n[卖出前持仓状态]")
                print(f"总持仓: {self.total_position}股")
                print(f"普通网格持仓: {sum(self.positions.values())}股")
                print(f"高位网格持仓: {sum(self.high_positions.values())}股")
                if self.ignore_isolation:
                    print(f"手动/隔离持仓: {sum(self.manual_positions.values())}股")

            # 3. 下单 (依然使用 _place_order; 如果想要严格限价，可以改 is_market=False 再传入 limit_price)
            sell_order_id = self._place_order(
                qty=total_quantity,
                side=OrderSide.SELL,
                is_market=True
            )
            if not sell_order_id:
                print("[通用卖出] 下单失败")
                return False

            # 记录订单信息
            self.order_records[sell_order_id] = {
                'side': OrderSide.SELL,
                'grid_prices': [x[0] for x in profitable_grids],
                'qty': total_quantity
            }
            self.pending_orders.add(sell_order_id)

            start_time = device_time(TimeZone.DEVICE_TIME_ZONE)

            # 4. 回测 or 实盘/模拟盘 - 等待成交确认
            time.sleep(1 if self.is_backtest else 5)  # 给撮合一点反应时间
            ok, avg_price = self._confirm_order(
                order_id=sell_order_id,
                side=OrderSide.SELL,
                expected_qty=total_quantity,
                start_time=start_time,
                timeout=30 if self.is_backtest else 300,
                interval=2
            )

            self.pending_orders.discard(sell_order_id)

            if ok:
                used_price = float(f"{avg_price:.2f}") if avg_price else float(f"{current_price:.2f}")
                print(f"卖出成交成功，总数量={total_quantity}, 均价={used_price}")

                # 验证实际成交
                position_symbols = get_position_symbol()
                actual_position = 0
                if position_symbols and self.stock in position_symbols:
                    actual_position = available_qty(self.stock)
                
                # 调试信息：打印实际持仓
                if self.verbose_log:
                    print(f"[卖出后实际持仓] API返回: {actual_position}股")
                
                # 在隔离模式下计算虚拟持仓
                if self.ignore_isolation:
                    # 计算手动仓位总数
                    manual_total = sum(self.manual_positions.values())
                    # 如果 manual_total>actual_position，就设成0，防止负数
                    virtual_position = max(0, actual_position - manual_total)
                    if self.verbose_log:
                        print(f"[隔离模式] 实际持仓={actual_position}, 手动={manual_total}, 虚拟持仓={virtual_position}")
                    # 使用虚拟持仓进行验证
                    actual_position = virtual_position
                
                expected_position = self.total_position - total_quantity
                
                # 在回测环境中，API可能返回0，即使实际上应该有持仓
                # 这里我们特别处理回测环境的情况
                if self.is_backtest and actual_position == 0 and expected_position > 0:
                    if self.verbose_log:
                        print(f"[回测环境] 忽略API返回的持仓0，使用预期持仓: {expected_position}")
                    # 在回测环境中，我们信任我们的计算而不是API返回
                    actual_position = expected_position
                
                if abs(actual_position - expected_position) > 0.001:
                    print(f"警告: 卖出后持仓异常 - 预期:{expected_position}, 实际:{actual_position}")
                    # 调试信息：打印更多详细信息
                    if self.verbose_log:
                        print(f"[持仓异常详情]")
                        print(f"卖出前总持仓: {self.total_position}股")
                        print(f"卖出数量: {total_quantity}股")
                        print(f"预期剩余: {expected_position}股")
                        print(f"实际剩余: {actual_position}股")
                        print(f"差异: {actual_position - expected_position}股")
                        print(f"隔离模式: {self.ignore_isolation}")
                        if self.ignore_isolation:
                            print(f"手动/隔离持仓: {sum(self.manual_positions.values())}股")
                    print("继续更新策略记录，但请注意检查持仓状态")

                # 更新策略记录
                if from_high:
                    # 高位网格更新逻辑
                    for grid_price, qty, _ in profitable_grids:
                        self.high_positions[grid_price] = 0
                        self.high_records[grid_price] = {
                            'buy_price': 0,
                            'quantity': 0,
                            'update_time': time.time()
                        }
                        print(f"高位网格平仓: 网格={grid_price:.1f}, 数量={qty}")
                    self.total_position = sum(self.positions.values()) + sum(self.high_positions.values())
                    self._clean_empty_high_grids()
                else:
                    # 普通网格批量更新
                    updates = [(grid_price, qty, False, used_price) 
                             for grid_price, qty, _ in profitable_grids]
                    if not self._batch_update_positions(updates):
                        print("批量更新网格持仓失败！")
                        return False

                # 更新周期交易状态
                self._update_period_trade_status(None, is_buy=False)
                
                # 根据verbose_log决定是否显示详细网格状态
                if self.verbose_log:
                    self._print_grid_status(show_all=True, show_time=True)
                else:
                    print(f"更新后总持仓: {self.total_position}股")
                
                # 卖出成功后，立即检查当前价格所在网格是否可以买入
                try:
                    # 获取最新价格 - 修复：避免与参数名current_price冲突
                    # 使用传入的current_price参数作为当前价格
                    latest_price = current_price  # 使用传入的参数
                    if latest_price and self._is_price_in_range(latest_price):
                        # 找到当前价格所属网格
                        current_grid = self._find_nearest_value(latest_price)
                        if current_grid:
                            print(f"[卖出后立即检查] 当前价格 {latest_price:.2f} 所属网格: {current_grid:.1f}")
                            
                            # 检查是否可以在当前网格买入
                            current_pos = self.positions.get(current_grid, 0)
                            if current_pos < self.position_limit and self.total_position < self.max_total_position:
                                # 特殊处理：重置当前周期的买入计数，允许卖出后立即买入
                                # 这是网格交易的特性，允许在同一周期内先卖出再买入
                                self.current_period_trades['buy_count'] = 0
                                
                                print(f"[卖出后立即买入] 尝试在网格 {current_grid:.1f} 买入")
                                # 执行买入
                                if self._place_buy_order(current_grid, latest_price):
                                    # 更新周期交易状态
                                    self._update_period_trade_status(current_grid, is_buy=True)
                                    print(f"[卖出后立即买入] 成功在网格 {current_grid:.1f} 买入")
                except Exception as e:
                    print(f"卖出后检查买入时发生错误: {str(e)}")
                
                return True
            else:
                print("卖出订单未能完全成交")
                return False

        except Exception as e:
            print(f"执行卖出时异常: {str(e)}")
            return False

    def _confirm_order(self,
                    order_id,
                    side,
                    expected_qty,
                    start_time=None,
                    timeout=60,
                    interval=3):
        """
        统一的订单成交确认方法。
        根据 self.is_backtest 选择回测或实盘/模拟逻辑，最后返回 (是否成功, 成交均价)。

        :param order_id: str, 下单后得到的订单ID
        :param side: OrderSide, 在实盘/模拟查询时需要判断买卖方向
        :param expected_qty: int, 期望成交数量
        :param start_time: datetime, 下单时刻(实盘/模拟需要查询范围; 回测可用于打印)
        :param timeout: int, 最大等待秒数
        :param interval: int, 每次循环查询的间隔秒数
        :return: (bool, float or None), 是否成交完毕 + 成交均价
        """
        import time
        import datetime
        
        # 如果你想在回测里用到 start_str/end_str，就保留以下逻辑：
        if self.is_backtest:
            print("[_confirm_order] 使用回测模式确认订单。")
            if start_time is not None:
                start_str = start_time.strftime("%Y-%m-%d")
                end_str   = (start_time + datetime.timedelta(days=1)).strftime("%Y-%m-%d")
                print(f"[回测查询] start_str={start_str}, end_str={end_str}")

            end_time_val = time.time() + timeout
            while time.time() < end_time_val:
                status = order_status(order_id)
                if status == OrderStatus.FILLED_ALL:
                    filled_qty = order_filled_qty(order_id)
                    if filled_qty >= expected_qty:
                        avg_px = order_filled_avg_price(order_id)
                        if avg_px is None:
                            avg_px = 0.0
                        return True, avg_px
                time.sleep(interval)

            return False, None
        else:
            # === 实盘/模拟模式 ===
            print("[_confirm_order] 使用实盘/模拟模式确认订单。")
            if start_time is None:
                # 如果必需start_time，但又没传，可以自己做一次默认值
                start_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            
            query_start_time = (start_time - datetime.timedelta(minutes=2)).strftime('%Y-%m-%d %H:%M:%S')

            accumulated_qty = 0
            total_weighted_price = 0.0
            total_qty_collected = 0.0
            end_time_val = time.time() + timeout
            attempt = 0
            
            # 20250311: 增加初始等待时间，避免订单刚提交就开始查询
            # 等待5秒，让订单有足够时间成交
            time.sleep(5)

            while time.time() < end_time_val:
                attempt += 1
                # 获取执行ID
                execution_ids = request_executionid(
                    symbol=self.stock,
                    start=query_start_time,
                    end=datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                )
                if execution_ids:
                    # 每次循环都重置统计，这样就获取当下最新成交数据
                    accumulated_qty = 0
                    total_weighted_price = 0.0
                    total_qty_collected = 0.0

                    # 遍历
                    for eid in execution_ids:
                        if execution_status(eid) == "OK":
                            deal_side = execution_side(eid)
                            if deal_side == side:
                                qty = execution_qty(eid)
                                price = execution_price(eid)
                                accumulated_qty += qty
                                total_weighted_price += price * qty
                                total_qty_collected += qty

                if attempt % 5 == 0:
                    # 例: 每 5次 打印一次日志
                    print(f"[_confirm_order] 实盘检查次数: {attempt}, 累计成交量: {accumulated_qty}")

                if accumulated_qty >= expected_qty:
                    avg_price = (total_weighted_price / total_qty_collected) if total_qty_collected > 0 else None
                    return True, avg_price

                time.sleep(interval)

            return False, None

    def _generate_grid_prices(self, base_price, grid_num, grid_percentage, keep_digit=1):
        """
        根据给定的基准价格 base_price、网格数量 grid_num 和网格间距比例 grid_percentage，
        生成一组对称分布的网格价格列表(向上/向下各 grid_num//2 个)。
        并对每个价格做相应保留小数 (默认为1位小数，也可根据需求调节 keep_digit)。

        :param base_price: float, 基准价格
        :param grid_num: int, 网格总数(一般是偶数，如 10，表示向上5格、向下5格)
        :param grid_percentage: float, 相对 base_price 的网格间距比例，如 0.03
        :param keep_digit: int, 生成网格的保留小数位数，默认1
        :return: list，排序后的网格价格列表
        """
        import math
        
        # 基本检查
        if not base_price or base_price <= 0:
            print("[_generate_grid_prices] base_price无效，返回空列表")
            return []
        if not grid_percentage or grid_percentage <= 0:
            print("[_generate_grid_prices] grid_percentage无效，返回空列表")
            return []

        # 保留小数的小工具函数
        def round_price(p, digits=keep_digit):
            factor = 10 ** digits
            # 这里采用"四舍五入"的逻辑，可根据需要也可以改成 math.floor / ceil
            return float(int(p * factor + 0.5) / factor)

        base_grid = round_price(base_price, keep_digit)
        grid_spacing = base_price * grid_percentage
        half = grid_num // 2

        # 生成向上/向下的网格价格
        prices = [base_grid]
        for i in range(half):
            up_raw = base_grid + (i + 1) * grid_spacing
            down_raw = base_grid - (i + 1) * grid_spacing
            up_price = round_price(up_raw, keep_digit)
            down_price = round_price(down_raw, keep_digit)
            prices.extend([up_price, down_price])

        # 排序
        prices.sort()
        return prices

    def _check_profit_and_execute_sell(self,
                                   current_price,
                                   skip_period_check=False,
                                   reason=None):
        """
        20250305 检查盈利时也考虑价格区间
        通用的"检查网格中是否达到盈利阈值并执行卖出"的方法。
        
        :param current_price: float, 当前价格
        :param skip_period_check: bool, 是否跳过当前周期检查 (True 表示不限制周期卖出)
        :param reason: str, 用于打印或日志记录 (比如 'reset' / 'normal' / 'handle_data' 等)
        :return: bool, 表示是否执行了卖出操作
        """
        try:
            if current_price <= 0:
                print(f"[_check_profit_and_execute_sell] 无效的 current_price={current_price}")
                return False

            # 检查价格是否在允许区间内
            # 注意：卖出时我们可以选择即使价格超出区间也允许卖出，以控制风险
            # 执行严格遵循区间限制，如果希望超出区间可以卖出，请注释下面的代码
            if not self._is_price_in_range(current_price):
                return False

            # 如果不跳过周期检查，则看一下能不能在当前周期卖出
            if not skip_period_check and not self._can_trade_in_period(None, is_buy=False):
                print(f"当前周期已执行过卖出操作，跳过 (reason={reason})")
                return False

            # ========== 筛选盈利网格 ==========
            profitable_grids = []
            total_sell_quantity = 0

            # 可以仿照你原先 _check_and_execute_sell 里的排序逻辑
            position_items = sorted(
                [(g, q, self.position_records.get(g, {}).get('buy_price', 0))
                for g, q in self.positions.items() if q > 0],
                key=lambda x: x[2]  # 按买入价格排序，低成本网格先卖出
            )

            for grid_price, qty, buy_price in position_items:
                if qty <= 0 or buy_price <= 0:
                    continue
                price_diff = (current_price - buy_price) / buy_price
                if price_diff >= self.grid_percentage:
                    profitable_grids.append((grid_price, qty, buy_price))
                    total_sell_quantity += qty

            if not profitable_grids:
                print(f"未发现满足盈利阈值的网格 (reason={reason})")
                return False

            # ========== 执行批量卖出 ==========
            print(f"[{reason}] 检测到 {len(profitable_grids)} 个盈利网格，总数量={total_sell_quantity}，准备卖出")
            success = self._execute_batch_sell(profitable_grids, current_price)
            return success

        except Exception as e:
            print(f"[_check_profit_and_execute_sell] 出现异常: {str(e)}")
            return False

    def _is_price_in_range(self, price):
        """
        20250305检查价格是否在设定的区间内
        
        Args:
            price (float): 需要检查的价格
            
        Returns:
            bool: 如果价格在区间内或未启用区间限制，返回True；否则返回False
        """
        if not self.use_price_range:
            return True
            
        if price < self.min_price_range:
            print(f"当前价格 {price:.2f} 低于设定区间下限 {self.min_price_range:.2f}，暂停交易")
            return False
            
        if price > self.max_price_range:
            print(f"当前价格 {price:.2f} 高于设定区间上限 {self.max_price_range:.2f}，暂停交易")
            return False
            
        return True