class Strategy(StrategyBase):
    """网格交易策略V5 - 修订持仓成本统计和盈利计算问题"""

    def initialize(self):
        """初始化策略"""
        import threading
        try:
            self._position_lock = threading.RLock()
            self._order_lock = threading.RLock()

            # 初始化基本数据结构
            self.positions = {}          # 记录每个网格的持仓
            self.grid_prices = []        # 存储网格价格
            self.position_records = {}   # 记录每个网格的交易详情
            self.total_position = 0      # 总持仓跟踪

            # 新增高位网格记录结构
            self.high_positions = {}     # 记录高位网格的持仓
            self.high_records = {}       # 记录高位网格的交易详情
           
            self.is_initialized = False
            self.last_trade_time = None  # 上次交易时间记录
            self.pending_orders = set()  # 跟踪待处理订单
            self.order_records = {}      # 记录本策略的所有订单信息
            self.start_time = device_time(TimeZone.DEVICE_TIME_ZONE)  # 记录策略启动时间
            
            # 记录当前周期的交易状态
            self.current_period_trades = {
                'period': '',            # 当前周期标识
                'buy_count': 0,          # 买入次数
                'sell_count': 0,         # 卖出次数
                'grids': set()           # 已操作的网格
            }

            # 先执行标准初始化流程，确保所有参数都已设置
            print("开始执行标准初始化流程...")
            self.trigger_symbols()
            self.custom_indicator()
            self.global_variables()
            print("标准初始化完成")
            
            # 检查是否有未处理的持仓
            actual_position = position_holding_qty(self.stock)
            if actual_position > 0:
                print(f"检测到已有持仓{actual_position}股，尝试恢复持仓状态")
                if self._recover_positions():
                    print("持仓状态恢复成功，继续执行策略")
                else:
                    print("持仓状态恢复失败，停止策略")
                    return

            print("策略初始化完成")
            
        except Exception as e:
            print(f"策略初始化发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())

    def trigger_symbols(self):
        """定义交易标的"""
        try:
            self.stock = declare_trig_symbol()
            print("交易标的设置完成")
        except Exception as e:
            print(f"设置交易标的时发生错误: {str(e)}")

    def custom_indicator(self):
        """设置技术指标"""
        try:
            self.register_indicator(
                indicator_name='MA',
                script='MA5:MA(CLOSE,5),COLORFF8D1E;',
                param_list=[]
            )
            print("技术指标设置完成")
        except Exception as e:
            print(f"设置技术指标时发生错误: {str(e)}")

    def global_variables(self):
        """定义全局变量"""
        try:
            # 用户可配置参数
            self.initial_capital = show_variable(10000, GlobalType.FLOAT, "初始资金")
            self.max_total_position = show_variable(500, GlobalType.INT, "最大总持仓")
            self.min_order_quantity = show_variable(20, GlobalType.INT, "单次交易数量")
            self.position_limit = show_variable(80, GlobalType.INT, "单个网格持仓上限")
            self.time_interval = show_variable(60, GlobalType.INT, "交易间隔(分钟)")
            
            # 统一网格间距和盈利标准
            self.grid_percentage = show_variable(0.03, GlobalType.FLOAT, "网格间距/盈利标准")
            self.grid_num = show_variable(10, GlobalType.INT, "网格数量")
            
            # 其他配置参数
            self.max_capital_usage = show_variable(0.9, GlobalType.FLOAT, "最大资金使用率")
            self.max_order_timeout = show_variable(300, GlobalType.INT, "订单超时时间(秒)")

            # 20241130新增配置参数
            self.use_trade_records = show_variable(True, GlobalType.BOOL, "使用成交记录恢复持仓")
            self.trade_record_days = show_variable(31, GlobalType.INT, "成交记录查询天数(1-31)")
            self.position_sync_retry = show_variable(3, GlobalType.INT, "持仓同步重试次数")
        
            print("全局变量设置完成")
            
        except Exception as e:
            print(f"设置全局变量时发生错误: {str(e)}")

    def check_strategy_status(self):
        """检查策略运行状态"""
        try:
            # 检查策略运行时长
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            running_hours = (current_time - self.start_time).total_seconds() / 3600
            
            # 检查持仓一致性
            actual_position = position_holding_qty(self.stock)
            if actual_position != self.total_position:
                self.send_alert(f"警告:策略运行{running_hours:.1f}小时后发现持仓不一致")
                return False
            
            # 检查网络连接
            if not current_price(self.stock):
                self.send_alert(f"警告:无法获取行情数据,请检查网络连接")
                return False
                
            return True
            
        except Exception as e:
            print(f"检查策略状态时发生错误: {str(e)}")
            return False

    def send_alert(self, message):
        """发送策略告警"""
        try:
            print(f"策略告警: {message}")
            # 这里可以根据实际情况添加其他通知方式
        except Exception as e:
            print(f"发送告警时发生错误: {str(e)}")

    def _recover_positions(self):
        """恢复已有持仓状态"""
        try:
            # 基础验证
            required_params = ['grid_percentage', 'grid_num', 'position_limit']
            for param in required_params:
                if not hasattr(self, param):
                    print(f"错误：参数 {param} 未初始化")
                    return False

            actual_position = position_holding_qty(self.stock)
            if actual_position == 0:
                return True

            # 获取当前价格
            latest_price = current_price(self.stock)
            if not latest_price:
                print("无法获取当前价格，恢复失败")
                return False

            print(f"当前持仓: {actual_position}股")
            
            # 优先尝试从成交记录恢复持仓分布
            positions_from_trades = self._get_positions_from_trades()
            
            if positions_from_trades:
                print("从成交记录中恢复持仓分布成功")
                self.positions = positions_from_trades['positions']
                self.position_records = positions_from_trades['records']
                self.total_position = positions_from_trades['total']
                
                # 打印恢复后的网格状态
                print("\n恢复后的网格状态:")
                self._print_grid_status(show_all=False, show_time=True)
                
                # 验证恢复结果
                if self._verify_positions():
                    print("持仓验证成功")
                    self.is_initialized = True
                    return True
            
            # 如果从成交记录恢复失败，使用新的算法基于当前价格重新分配
            grid_spacing = latest_price * self.grid_percentage
            base_grid = int(latest_price * 10) / 10
            half_grids = self.grid_num // 2
            
            # 生成网格价格
            self.grid_prices = [base_grid]
            for i in range(half_grids):
                up_price = int((base_grid + (i + 1) * grid_spacing) * 10) / 10
                down_price = int((base_grid - (i + 1) * grid_spacing) * 10) / 10
                self.grid_prices.extend([up_price, down_price])
            self.grid_prices.sort()

            # 获取成交记录用于计算各价位的持仓成本
            trades = []
            execution_ids = request_executionid(symbol=self.stock)
            for eid in execution_ids:
                if execution_status(eid) == "OK":
                    trades.append({
                        'price': execution_price(eid),
                        'quantity': execution_qty(eid),
                        'side': execution_side(eid),
                        'time': execution_time(eid)
                    })
            
            # 按时间排序
            trades.sort(key=lambda x: x['time'])
            
            # 根据成交记录计算每个价位的持仓和成本
            position_costs = {}  # 记录每个价位的持仓和成本
            remaining_position = actual_position
            
            with self._position_lock:
                # 初始化新的持仓记录
                self.positions = {}
                self.position_records = {}
                
                # 遍历网格价格，从最接近当前价格的网格开始分配
                sorted_grids = sorted(self.grid_prices, 
                                    key=lambda x: abs(x - latest_price))
                
                for grid_price in sorted_grids:
                    if remaining_position <= 0:
                        break
                        
                    # 确定分配到当前网格的数量
                    allocation = min(self.position_limit, remaining_position)
                    
                    # 计算该网格的加权平均成本
                    grid_trades = [t for t in trades 
                                if abs(t['price'] - grid_price) / grid_price <= self.grid_percentage]
                    if grid_trades:
                        total_cost = sum(t['price'] * t['quantity'] 
                                    for t in grid_trades if t['side'] == OrderSide.BUY)
                        total_qty = sum(t['quantity'] 
                                    for t in grid_trades if t['side'] == OrderSide.BUY)
                        grid_cost = total_cost / total_qty if total_qty > 0 else grid_price
                    else:
                        grid_cost = grid_price
                    
                    # 更新持仓记录
                    self.positions[grid_price] = allocation
                    self.position_records[grid_price] = {
                        'buy_price': grid_cost,
                        'quantity': allocation,
                        'update_time': time.time()
                    }
                    
                    remaining_position -= allocation
                    print(f"分配 {allocation}股 到网格 {grid_price:.1f}, 成本价 {grid_cost:.1f}")
                
                self.total_position = sum(self.positions.values())

            print(f"持仓分配完成")
            self._print_grid_status(show_all=True)
            
            # 验证恢复后的持仓状态
            if not self._verify_positions():
                print("持仓验证失败")
                return False

            self.is_initialized = True
            return True

        except Exception as e:
            print(f"恢复持仓状态时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return False
            
    def _initialize_grids(self, base_price):
        """初始化或重置网格"""
        try:
            print(f"\n初始化网格 - 基准价格: {base_price}")
            
            # 添加参数验证
            if not base_price or base_price <= 0:
                print("无效的基准价格")
                return False
                
            if not self.grid_percentage or self.grid_percentage <= 0:
                print("无效的网格间距")
                return False

            with self._position_lock:
                # 获取实际持仓用于验证
                actual_position = position_holding_qty(self.stock)
                print(f"当前实际持仓: {actual_position}股")
                
                # 生成新网格价格
                grid_spacing = base_price * self.grid_percentage
                half_grids = self.grid_num // 2
                new_grid_prices = []
                base_grid = int(base_price * 10) / 10
                new_grid_prices.append(base_grid)
                
                for i in range(half_grids):
                    up_price = int((base_grid + (i + 1) * grid_spacing) * 10) / 10
                    down_price = int((base_grid - (i + 1) * grid_spacing) * 10) / 10
                    new_grid_prices.extend([up_price, down_price])
                new_grid_prices.sort()
                
                if actual_position > 0:
                    # 保存原有持仓信息
                    old_positions = {k: v for k, v in self.positions.items() if v > 0}
                    old_records = {k: v.copy() for k, v in self.position_records.items() 
                                if v.get('quantity', 0) > 0}
                    
                    # 先处理原有持仓的盈利机会
                    if self._check_profit_before_reset(base_price):
                        print("盈利平仓成功，继续初始化网格")
                        actual_position = position_holding_qty(self.stock)
                        # 更新持仓信息
                        if actual_position > 0:
                            old_positions = {k: v for k, v in self.positions.items() if v > 0}
                            old_records = {k: v.copy() for k, v in self.position_records.items() 
                                        if v.get('quantity', 0) > 0}
                    
                    if actual_position > 0:
                        # 执行持仓迁移
                        migration_result = self._migrate_positions_to_new_grids(
                            actual_position, old_positions, old_records, new_grid_prices
                        )
                        if not migration_result:
                            print("持仓迁移失败，尝试从成交记录恢复")
                            positions_from_trades = self._get_positions_from_trades()
                            if positions_from_trades:
                                print("从成交记录恢复持仓分布成功")
                                self.positions = positions_from_trades['positions']
                                self.position_records = positions_from_trades['records']
                                self.total_position = positions_from_trades['total']
                                self.grid_prices = new_grid_prices  # 确保更新网格价格
                            else:
                                print("无法恢复持仓状态，强制同步到实际持仓")
                                if not self._force_sync_position(actual_position):
                                    return False
                else:
                    # 初始化空网格
                    self.grid_prices = new_grid_prices
                    self.positions = {}
                    self.position_records = {
                        price: {'buy_price': 0, 'quantity': 0, 'update_time': time.time()}
                        for price in new_grid_prices
                    }
                    self.total_position = 0
                
                # 打印网格状态
                self._print_grid_status(show_all=True, show_time=False)
                
                # 检查是否有开仓机会
                if actual_position < self.max_total_position:
                    current_grid = self._find_nearest_grid(base_price)
                    if current_grid and current_grid not in self.positions:
                        print(f"网格重置后检查到开仓机会: {current_grid:.1f}")
                        self._place_buy_order(current_grid, base_price)
                
                return True
                
        except Exception as e:
            print(f"初始化网格时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return False

    def _check_profit_before_reset(self, current_price):
        """重置网格前检查是否有盈利机会"""
        try:
            profitable_grids = []
            total_sell_quantity = 0
            
            # 检查每个持仓的网格是否满足盈利条件
            for grid_price, qty in self.positions.items():
                if qty <= 0:
                    continue
                    
                record = self.position_records.get(grid_price, {})
                buy_price = record.get('buy_price', grid_price)
                price_diff = (current_price - buy_price) / buy_price
                
                if price_diff >= self.grid_percentage:
                    print(f"网格重置时发现盈利机会: 网格={grid_price:.1f} 盈利={price_diff:.1%}")
                    profitable_grids.append((grid_price, qty, buy_price))
                    total_sell_quantity += qty
            
            # 如果有盈利机会，执行批量卖出
            if profitable_grids:
                return self._execute_batch_sell(profitable_grids, current_price)
                
            return False
            
        except Exception as e:
            print(f"检查重置前盈利机会时发生错误: {str(e)}")
            return False

    def _execute_batch_sell(self, profitable_grids, current_price):
        """执行批量卖出操作"""
        try:
            total_quantity = sum(grid[1] for grid in profitable_grids)
            
            # 检查是否可以在当前周期交易
            if not self._can_trade_in_period(None, is_buy=False):
                print("当前周期已执行过卖出操作")
                return False
                
            print(f"执行批量卖出: 总数量={total_quantity}")
            sell_order_id = place_market(
                symbol=self.stock,
                qty=total_quantity,
                side=OrderSide.SELL,
                time_in_force=TimeInForce.DAY
            )
            
            if not sell_order_id:
                print("批量卖出订单创建失败")
                return False
                
            # 记录订单信息
            self.order_records[sell_order_id] = {
                'side': OrderSide.SELL,
                'grid_prices': [g[0] for g in profitable_grids],
                'qty': total_quantity
            }
            
            self.pending_orders.add(sell_order_id)
            
            try:
                if self._check_order_status(sell_order_id):
                    # 构建批量更新数据
                    updates = []
                    for grid_price, qty, _ in profitable_grids:
                        updates.append((grid_price, qty, False, current_price))
                    
                    # 执行批量更新
                    if self._batch_update_positions(updates):
                        self._update_period_trade_status(None, is_buy=False)
                        # 立即尝试在新的价位开仓
                        current_grid = self._find_nearest_grid(current_price)
                        if current_grid:
                            print(f"尝试在新网格 {current_grid:.1f} 开启新仓位")
                            if self._place_buy_order(current_grid, current_price):
                                print(f"新网格 {current_grid:.1f} 开仓成功")
                        return True
                    else:
                        print("持仓更新失败")
                        return False
                else:
                    print("批量卖出订单执行失败")
                    return False
                    
            finally:
                self.pending_orders.discard(sell_order_id)
                
            return False
                
        except Exception as e:
            print(f"执行批量卖出操作失败: {str(e)}")
            return False

    def _migrate_positions_to_new_grids(self, actual_position, old_positions, old_records, new_grid_prices):
        """
        将持仓迁移到新网格,保留高位网格信息
        """
        try:
            new_positions = {}
            new_records = {}
            new_high_positions = {}
            new_high_records = {}
                
            # 获取新网格的最高价格
            highest_new_grid = new_grid_prices[0]
            for price in new_grid_prices[1:]:
                if price > highest_new_grid:
                    highest_new_grid = price
            print(f"\n开始迁移持仓（新网格最高价格: {highest_new_grid:.1f}）")
            
            # 1. 先处理原有的高位网格持仓
            if self.high_positions:
                print("\n处理原有高位网格持仓:")
                for price, qty in sorted(self.high_positions.items()):
                    if qty <= 0:
                        continue
                        
                    record = self.high_records[price]
                    # 判断是否可以进入新网格
                    if price <= highest_new_grid:
                        nearest_grid = self._find_nearest_price_in_list(price, new_grid_prices)
                        if nearest_grid:
                            print(f"高位网格 {price:.1f} 的 {qty}股可以迁移到新网格 {nearest_grid:.1f}")
                            current_qty = new_positions.get(nearest_grid, 0)
                            if current_qty + qty <= self.position_limit:
                                new_positions[nearest_grid] = current_qty + qty
                                new_records[nearest_grid] = record.copy()
                                new_records[nearest_grid]['quantity'] = current_qty + qty
                            else:
                                # 超出新网格容量，保持为高位网格
                                print(f"因超出网格容量限制，保持为高位网格")
                                new_high_positions[price] = qty
                                new_high_records[price] = record.copy()
                    else:
                        print(f"保持高位网格 {price:.1f} 的 {qty}股")
                        new_high_positions[price] = qty
                        new_high_records[price] = record.copy()
            
            # 2. 处理现有持仓
            print("\n处理当前活动网格持仓:")
            for old_price, qty in sorted(old_positions.items()):
                if qty <= 0:
                    continue
                    
                record = old_records[old_price]
                
                # 判断是否应该成为高位网格
                if old_price > highest_new_grid:
                    print(f"网格 {old_price:.1f} 的 {qty}股 高于新网格范围，转为高位网格")
                    new_high_positions[old_price] = qty
                    new_high_records[old_price] = record.copy()
                    continue
                    
                # 在新网格范围内的持仓正常迁移
                nearest_grid = self._find_nearest_price_in_list(old_price, new_grid_prices)
                if nearest_grid:
                    print(f"迁移 {old_price:.1f} 的 {qty}股 到网格 {nearest_grid:.1f}")
                    current_qty = new_positions.get(nearest_grid, 0)
                    if current_qty + qty <= self.position_limit:
                        new_positions[nearest_grid] = current_qty + qty
                        new_records[nearest_grid] = record.copy()
                        new_records[nearest_grid]['quantity'] = current_qty + qty
                    else:
                        print(f"超出网格 {nearest_grid:.1f} 容量限制，转为高位网格")
                        new_high_positions[old_price] = qty
                        new_high_records[old_price] = record.copy()
                else:
                    print(f"无法为价格 {old_price:.1f} 找到合适的网格")
                    return False
            
            # 验证迁移结果
            total_active = sum(new_positions.values())
            total_high = sum(new_high_positions.values())
            print("\n迁移结果验证:")
            print(f"活动网格持仓: {total_active}股")
            print(f"高位网格持仓: {total_high}股")
            print(f"持仓总数: {total_active + total_high}股")
            print(f"实际持仓: {actual_position}股")
            
            if total_active + total_high != actual_position:
                print(f"警告: 持仓不一致 - 活动网格:{total_active} + 高位网格:{total_high} != 实际持仓:{actual_position}")
                return False
                    
            # 更新网格信息
            self.grid_prices = new_grid_prices
            self.positions = new_positions
            self.position_records = new_records
            self.high_positions = new_high_positions
            self.high_records = new_high_records
            self.total_position = total_active + total_high
            
            print("\n迁移后网格状态:")
            self._print_grid_status(show_all=True)
            
            return self._verify_positions()
                
        except Exception as e:
            print(f"迁移持仓到新网格时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return False

    def _force_sync_position(self, actual_position, avg_cost=None, grid_price=None):
        """
        强制同步持仓到实际状态
        Args:
            actual_position: int, 实际持仓数量
            avg_cost: float, 可选的成本价
            grid_price: float, 可选的网格价格
        Returns:
            bool: 同步是否成功
        """
        try:
            if actual_position == 0:
                self.positions = {}
                self.position_records = {}
                self.total_position = 0
                return True
                
            # 如果未提供成本价，获取平均成本价
            if avg_cost is None:
                avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
                if not avg_cost:
                    avg_cost = current_price(self.stock)
            
            # 如果未提供网格价格，找到最近的网格
            if grid_price is None:
                grid_price = self._find_nearest_grid(avg_cost)
                
            if not grid_price:
                print("无法找到合适的网格来分配持仓")
                return False
                
            # 强制更新持仓记录
            self.positions = {grid_price: actual_position}
            self.position_records = {
                grid_price: {
                    'buy_price': avg_cost,
                    'quantity': actual_position,
                    'update_time': time.time()
                }
            }
            self.total_position = actual_position
            
            print(f"强制同步持仓完成 - 网格:{grid_price}, 持仓:{actual_position}, 成本:{avg_cost}")
            return True
            
        except Exception as e:
            print(f"强制同步持仓失败: {str(e)}")
            return False

    def _verify_and_fix_positions(self):
        """验证并修正持仓数据"""
        try:
            actual_position = position_holding_qty(self.stock)
            print(f"当前实际持仓: {actual_position}股")
            
            # 如果无持仓，清空记录
            if actual_position == 0:
                self.positions = {}
                self.position_records = {}
                self.total_position = 0
                print("实际持仓为0，已清空所有持仓记录")
                return True
            
            # 如果持仓不一致，需要修正
            if self.total_position != actual_position:
                print(f"持仓不一致 - 系统记录:{self.total_position}, 实际持仓:{actual_position}")
                
                # === 修改开始：优先使用成交记录恢复 ===
                positions_from_trades = self._get_positions_from_trades()
                if positions_from_trades:
                    print("从成交记录恢复持仓分布")
                    self.positions = positions_from_trades['positions']
                    self.position_records = positions_from_trades['records']
                    self.total_position = positions_from_trades['total']
                    return self._verify_positions()
                # === 修改结束 ===
                
                # 如果无法从成交记录恢复，使用平均成本价
                avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
                if not avg_cost:
                    print("无法获取持仓成本价，尝试计算现有记录的加权平均成本")
                    total_value = 0
                    total_quantity = 0
                    for grid_price, qty in self.positions.items():
                        if qty <= 0:
                            continue
                        record = self.position_records.get(grid_price, {})
                        buy_price = record.get('buy_price', grid_price)
                        total_value += qty * buy_price
                        total_quantity += qty
                    
                    if total_quantity > 0:
                        avg_cost = int(total_value / total_quantity * 10) / 10
                    else:
                        avg_cost = current_price(self.stock)
                
                # 找到最适合的网格
                nearest_grid = self._find_nearest_grid(avg_cost)
                if nearest_grid:
                    self._force_sync_position(actual_position, avg_cost, nearest_grid)
                    print(f"已同步实际持仓 {actual_position}股 到网格 {nearest_grid:.1f}, 成本价: {avg_cost:.1f}")
                else:
                    print("无法找到合适的网格，需要重新初始化网格")
                    return False
            
            return self._verify_positions()
            
        except Exception as e:
            print(f"验证和修正持仓时发生错误: {str(e)}")
            return False

    def _verify_positions(self):
        """验证持仓数据一致性"""
        try:
            actual_position = position_holding_qty(self.stock)
            
            # 计算所有持仓
            total_active = sum(qty for qty in self.positions.values() if qty > 0)
            total_high = sum(qty for qty in self.high_positions.values() if qty > 0)
            total_positions = total_active + total_high
            
            print(f"\n持仓验证:")
            print(f"活动网格持仓: {total_active}股")
            print(f"高位网格持仓: {total_high}股")
            print(f"持仓总数: {total_positions}股")
            print(f"实际持仓: {actual_position}股")
            
            # 检查标准网格
            grid_prices = set()
            for grid, qty in self.positions.items():
                if qty > 0:
                    if grid in grid_prices:
                        print(f"错误:标准网格{grid}重复分配")
                        return False
                    grid_prices.add(grid)
                    
                    if qty > self.position_limit:
                        print(f"错误:标准网格{grid}超出持仓限制({qty}>{self.position_limit})")
                        return False
            
            # 检查高位网格
            for grid, qty in self.high_positions.items():
                if qty > 0:
                    if grid in grid_prices:
                        print(f"错误:高位网格{grid}与标准网格重叠")
                        return False
                    if grid in self.positions:
                        print(f"错误:高位网格{grid}价格与标准网格冲突")
                        return False
                    
                    if qty > self.position_limit:
                        print(f"错误:高位网格{grid}超出持仓限制({qty}>{self.position_limit})")
                        return False
            
            if abs(total_positions - actual_position) > 0.01:
                print(f"持仓不一致 - 实际:{actual_position} != 记录:{total_positions}")
                return False
                
            self.total_position = total_positions
            return True
                
        except Exception as e:
            print(f"验证持仓失败: {str(e)}")
            return False

    def _should_reset_grid(self, latest_price):
        """判断是否需要重置网格"""
        try:
            if not self.grid_prices:
                return True
                    
            closest_grid = self._find_nearest_grid(latest_price)
            if closest_grid:
                deviation = abs(latest_price - closest_grid) / closest_grid
                if deviation > self.grid_percentage:
                    # 检查活动网格中是否存在高于当前价格的持仓
                    high_position = sum(qty for grid, qty in self.positions.items() 
                                    if grid > latest_price)
                    if high_position > 0:
                        print(f"价格偏离网格过大: {deviation:.2%}, 但当前网格存在高位持仓{high_position}, 执行网格保存")
                        return True
                    else:
                        print(f"价格偏离网格过大: {deviation:.2%}, 且无高位持仓, 执行网格重置")
                        return True
            return False
                
        except Exception as e:
            print(f"检查网格重置时发生错误: {str(e)}")
            return False

    def _find_nearest_grid(self, target_price):
        """找到最接近目标价格的网格"""
        try:
            if not self.grid_prices:
                return None
                
            target_price = int(target_price * 10) / 10  # 保持1位小数
            
            nearest_grid = self.grid_prices[0]
            min_distance = abs(target_price - nearest_grid)
            
            for grid in self.grid_prices[1:]:
                distance = abs(target_price - grid)
                if distance < min_distance:
                    min_distance = distance
                    nearest_grid = grid
                    
            return nearest_grid
            
        except Exception as e:
            print(f"查找最近网格失败: {str(e)}")
            return None

    def _find_nearest_price_in_list(self, target_price, price_list):
        """20241130新增辅助方法，专门用于在任意价格列表中查找最近值"""
        try:
            if not price_list:
                return None
                
            target_price = int(target_price * 10) / 10  # 保持1位小数
            
            nearest_price = price_list[0]
            min_distance = abs(target_price - nearest_price)
            
            for price in price_list[1:]:
                distance = abs(target_price - price)
                if distance < min_distance:
                    min_distance = distance
                    nearest_price = price
                    
            return nearest_price
            
        except Exception as e:
            print(f"查找最近价格失败: {str(e)}")
            return None

    def _is_new_period(self, current_time):
        """判断是否是新的交易周期"""
        current_period = current_time.strftime('%Y%m%d_%H%M')
        if current_period != self.current_period_trades['period']:
            # 新周期，重置交易状态
            self.current_period_trades = {
                'period': current_period,
                'buy_count': 0,
                'sell_count': 0,
                'grids': set()
            }
            return True
        return False

    def _can_trade_in_period(self, grid_price, is_buy=True):
        """检查是否可以在当前周期交易"""
        if is_buy and self.current_period_trades['buy_count'] > 0:
            print(f"当前周期已执行过买入操作")
            return False
        if not is_buy and self.current_period_trades['sell_count'] > 0:
            print(f"当前周期已执行过卖出操作")
            return False
        if grid_price in self.current_period_trades['grids']:
            print(f"当前周期已在网格{grid_price:.1f}执行过交易")
            return False
        return True

    def _update_period_trade_status(self, grid_price, is_buy=True):
        """更新周期交易状态"""
        if is_buy:
            self.current_period_trades['buy_count'] += 1
        else:
            self.current_period_trades['sell_count'] += 1
        if grid_price is not None:
            self.current_period_trades['grids'].add(grid_price)

    def handle_data(self):
        """主要策略逻辑"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            
            # 定期检查策略状态
            if not self.check_strategy_status():
                print("策略状态异常，跳过本次交易")
                return
                
            # 获取当前价格
            latest_price = current_price(self.stock)
            if not latest_price:
                return
                    
            print(f"\n当前时间: {current_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"当前价格: {latest_price:.1f}")
            
            # 检查是否新周期
            if not self._is_new_period(current_time):
                print(f"当前周期已执行交易, 等待下一周期")
                return
                
            # 先检查高位网格是否有盈利机会
            high_grid_profit = self._check_high_grid_profit(latest_price)
            
            # 检查是否需要重置网格
            if not self.is_initialized or self._should_reset_grid(latest_price):
                self._initialize_grids(latest_price)
                self.is_initialized = True
                return
                
            # 再检查普通网格是否有盈利机会
            if not high_grid_profit and self._check_and_execute_sell(latest_price):
                self.last_trade_time = current_time
                return
                
            # 找到当前价格所属网格
            current_grid = self._find_nearest_grid(latest_price)
            if not current_grid:
                return
                    
            print(f"当前所属网格: {current_grid:.1f}")
            
            # 检查是否可以买入
            if not self._can_trade_in_period(current_grid, is_buy=True):
                return
                
            # 执行买入
            if self._place_buy_order(current_grid, latest_price):
                self._update_period_trade_status(current_grid, is_buy=True)
                self.last_trade_time = current_time
                
        except Exception as e:
            print(f"策略运行时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())

    def _check_and_execute_sell(self, current_price):
        """检查并执行卖出操作"""
        try:
            if not self._can_trade_in_period(None, is_buy=False):
                return False
                
            sell_price = bid(self.stock, level=1)
            if not sell_price:
                sell_price = current_price
                
            profitable_grids = []
            total_sell_quantity = 0
            
            with self._position_lock:
                # 按照持仓成本从低到高排序，优先平掉低位的获利仓位
                position_items = sorted(
                    [(grid_price, qty, self.position_records.get(grid_price, {}).get('buy_price', 0)) 
                    for grid_price, qty in self.positions.items() if qty > 0],
                    key=lambda x: x[2]  # 按买入价格排序
                )
                
                for grid_price, position, buy_price in position_items:
                    if position <= 0:
                        continue
                        
                    # 使用实际成本价计算盈利比例
                    price_diff = (sell_price - buy_price) / buy_price
                    if price_diff >= self.grid_percentage:
                        profitable_grids.append((grid_price, position, buy_price))
                        total_sell_quantity += position
                        print(f"网格 {grid_price:.1f} 符合盈利条件: 成本={buy_price:.1f}, 盈利={price_diff:.1%}")
                
                if not profitable_grids:
                    return False

                # 执行批量卖出
                if total_sell_quantity > 0:
                    return self._execute_batch_sell(profitable_grids, current_price)
                        
                return False
                    
        except Exception as e:
            print(f"检查并执行卖出操作失败: {str(e)}")
            return False

    def _place_buy_order(self, grid_price, latest_price):
        """执行买入订单"""
        try:
            # 检查当前网格是否已存在持仓
            current_pos = self.positions.get(grid_price, 0)
            if current_pos >= self.position_limit:
                print(f"网格{grid_price:.1f}持仓{current_pos}已达上限{self.position_limit}")
                return False
                
            # 检查总持仓限制
            if self.total_position >= self.max_total_position:
                print(f"总持仓{self.total_position}已达上限{self.max_total_position}")
                return False
                
            with self._order_lock:
                try:
                    # 获取实时买入价格
                    buy_price = ask(self.stock, level=1)  # 使用卖一价
                    if not buy_price:
                        buy_price = latest_price
                        
                    print(f"执行买入: 网格={grid_price:.1f} 数量={self.min_order_quantity} @ {buy_price:.1f}")
                    buy_order_id = place_market(
                        symbol=self.stock,
                        qty=self.min_order_quantity,
                        side=OrderSide.BUY,
                        time_in_force=TimeInForce.DAY
                    )
                    
                    if not buy_order_id:
                        print("买入订单创建失败")
                        return False

                    # 记录订单信息
                    self.order_records[buy_order_id] = {
                        'side': OrderSide.BUY,
                        'grid_price': grid_price,
                        'qty': self.min_order_quantity
                    }

                    self.pending_orders.add(buy_order_id)
                    
                    if self._check_order_status(buy_order_id):
                        # 更新持仓信息
                        if self._update_position(grid_price, self.min_order_quantity, buy_price, is_buy=True):
                            print(f"买入订单成交: {buy_order_id}, 更新后该网格持仓: {self.positions[grid_price]}")
                            return True
                        else:
                            print(f"买入成功但更新持仓失败: {buy_order_id}")
                            return False
                    else:
                        print(f"买入订单执行失败: {buy_order_id}")
                        return False
                        
                finally:
                    self.pending_orders.discard(buy_order_id)
                    
        except Exception as e:
            print(f"提交买入订单时发生错误: {str(e)}")
            return False

    def _update_position(self, grid_price, qty, price, is_buy=True):
        """更新持仓信息，使用加权平均计算成本"""
        try:
            with self._position_lock:
                before_total = self.total_position
                grid_price = int(grid_price * 10) / 10
                price = int(price * 10) / 10
                
                if is_buy:
                    current_pos = self.positions.get(grid_price, 0)
                    current_cost = self.position_records.get(grid_price, {}).get('buy_price', 0)
                    new_qty = current_pos + qty
                    
                    # 验证单网格持仓限制
                    if new_qty > self.position_limit:
                        print(f"警告：网格{grid_price:.1f}更新后持仓{new_qty}将超过限制{self.position_limit}")
                        return False
                        
                    # 验证总持仓限制
                    total_high_position = sum(self.high_positions.values())
                    if before_total + qty > self.max_total_position:
                        print(f"警告：更新后总持仓{before_total + qty}将超过限制{self.max_total_position}")
                        return False
                    
                    # 计算加权平均成本
                    if current_pos > 0:
                        new_cost = (current_pos * current_cost + qty * price) / new_qty
                    else:
                        new_cost = price
                        
                    self.positions[grid_price] = new_qty
                    self.position_records[grid_price] = {
                        'buy_price': new_cost,
                        'quantity': new_qty,
                        'update_time': time.time()
                    }
                else:
                    if grid_price in self.positions:
                        current_pos = self.positions[grid_price]
                        if current_pos >= qty:
                            new_qty = current_pos - qty
                            if new_qty == 0:
                                del self.positions[grid_price]
                                self.position_records[grid_price] = {
                                    'buy_price': 0,
                                    'quantity': 0,
                                    'update_time': time.time()
                                }
                            else:
                                # 保持原有成本价
                                self.positions[grid_price] = new_qty
                                self.position_records[grid_price].update({
                                    'quantity': new_qty,
                                    'update_time': time.time()
                                })
                
                # 更新总持仓
                self.total_position = sum(self.positions.values()) + sum(self.high_positions.values())
                print(f"持仓更新 - 网格:{grid_price:.1f} 操作:{'买入' if is_buy else '卖出'} "
                    f"数量:{qty} 价格:{price:.1f} 总持仓:{self.total_position}")
                self._print_grid_status(show_all=False, show_time=True)
                return self._verify_positions()
                        
        except Exception as e:
            print(f"更新持仓失败: {str(e)}")
            return False

    def _check_order_status(self, order_id, max_retries=120, retry_interval=0.5):
        """检查订单状态"""
        if not order_id:
            return False
            
        try:
            start_time = time.time()
            wait_count = 0
            
            while True:
                status = order_status(order_id)
                wait_count += 1
                
                if status == "FILLED_ALL":
                    return True
                    
                if status in ["CANCELLED_ALL", "FAILED", "DISABLED", "DELETED"]:
                    print(f"订单{order_id}已{status}")
                    return False
                    
                # 检查是否达到最大等待时间
                elapsed_time = time.time() - start_time
                if elapsed_time >= self.max_order_timeout:
                    print(f"订单{order_id}等待超时({elapsed_time:.1f}秒),准备撤单")
                    cancel_order_by_orderid(order_id)
                    return False
                    
                # 如果订单未成交但状态正常，继续等待
                if wait_count >= max_retries:
                    print(f"订单{order_id}等待次数达到上限,准备撤单")
                    cancel_order_by_orderid(order_id)
                    return False
                    
                time.sleep(retry_interval)
                
        except Exception as e:
            print(f"检查订单状态出错: {str(e)}")
            return False

    def _print_grid_status(self, show_all=True, show_time=False):
        """打印网格状态"""
        try:
            print("\n网格状态:")
            latest_price = current_price(self.stock)  # 获取当前价格
            
            if show_all:
                for grid in sorted(self.grid_prices):
                    pos = self.positions.get(grid, 0)
                    record = self.position_records.get(grid, {})
                    status_str = (f"网格 {grid:.1f}: 持仓={pos}, "
                                f"成本={record.get('buy_price', 0):.1f}")
                    
                    # 添加盈亏显示
                    if pos > 0 and latest_price:
                        profit = (latest_price - record.get('buy_price', 0)) * pos
                        profit_pct = (latest_price - record.get('buy_price', 0)) / record.get('buy_price', 0) * 100
                        status_str += f", 盈亏={profit:.2f}({profit_pct:.1f}%)"
                    
                    if show_time and pos > 0:
                        update_time = record.get('update_time', 0)
                        if update_time:
                            time_str = time.strftime('%H:%M:%S', time.localtime(update_time))
                            status_str += f", 更新时间={time_str}"
                    print(status_str)
                    
            else:
                # 仅显示有持仓的网格
                for grid_price, qty in sorted(self.positions.items()):
                    if qty > 0:
                        record = self.position_records.get(grid_price, {})
                        status_str = (f"网格 {grid_price:.1f}: 持仓={qty}, "
                                    f"成本={record.get('buy_price', 0):.1f}")
                        
                        if latest_price:
                            profit = (latest_price - record.get('buy_price', 0)) * qty
                            profit_pct = (latest_price - record.get('buy_price', 0)) / record.get('buy_price', 0) * 100
                            status_str += f", 盈亏={profit:.2f}({profit_pct:.1f}%)"
                        
                        if show_time:
                            update_time = record.get('update_time', 0)
                            if update_time:
                                time_str = time.strftime('%H:%M:%S', time.localtime(update_time))
                                status_str += f", 更新时间={time_str}"
                        print(status_str)

            # 打印高位网格状态
            if self.high_positions:
                print("\n高位网格状态:")
                for grid in sorted(self.high_positions.keys()):
                    qty = self.high_positions[grid]
                    if qty > 0 or show_all:
                        record = self.high_records.get(grid, {})
                        status_str = f"网格 {grid:.1f}: 持仓={qty}, 成本={record.get('buy_price', 0):.1f}"
                        if qty > 0 and latest_price:
                            profit = (latest_price - record.get('buy_price', 0)) * qty
                            profit_pct = (latest_price - record.get('buy_price', 0)) / record.get('buy_price', 0) * 100
                            status_str += f", 盈亏={profit:.2f}({profit_pct:.1f}%)"
                        if show_time and qty > 0:
                            update_time = record.get('update_time', 0)
                            if update_time:
                                time_str = time.strftime('%H:%M:%S', time.localtime(update_time))
                                status_str += f", 更新时间={time_str}"
                        print(status_str)
            
            # 直接用当前价格乘以总持仓计算总市值
            total_value = latest_price * self.total_position
            print(f"总持仓: {self.total_position}, 总市值: {total_value:.2f}")
            
        except Exception as e:
            print(f"打印网格状态时发生错误: {str(e)}")

    def _get_actual_position_from_trades(self):
        """根据实际持仓和最近成交记录验证持仓"""
        try:
            # 获取当前实际持仓
            actual_position = position_holding_qty(self.stock)
            print(f"当前实际持仓: {actual_position}股")
            
            # 验证与成交记录的一致性
            execution_ids = request_executionid(symbol=self.stock)
            if not execution_ids:
                print("无法获取成交记录")
                return actual_position
                
            total_buy = 0
            total_sell = 0
            
            # 当前策略的成交情况统计
            strategy_orders = set(self.order_records.keys())
            executed_orders = set()
            
            for eid in execution_ids:
                status = order_status(eid)
                if status != "FILLED_ALL":
                    continue
                    
                # 如果这个成交ID对应的订单是本策略的订单
                if eid in strategy_orders:
                    qty = execution_qty(eid)
                    if self.order_records[eid]['side'] == OrderSide.BUY:
                        total_buy += qty
                    else:
                        total_sell += qty
                    executed_orders.add(eid)
                    
            calculated_position = total_buy - total_sell
            
            # 检查是否有未统计到的订单
            missing_orders = strategy_orders - executed_orders
            if missing_orders:
                print(f"警告: 有{len(missing_orders)}个订单未在成交记录中找到")
                
            if actual_position != calculated_position:
                print(f"警告: 持仓不一致 - 实际持仓:{actual_position}, 成交计算持仓:{calculated_position}")
                print(f"成交统计 - 总买入:{total_buy}股, 总卖出:{total_sell}股")
                
            return actual_position
            
        except Exception as e:
            print(f"获取实际持仓时发生错误: {str(e)}")
            return 0

    def _get_positions_from_trades(self):
        """
        从历史成交记录中恢复持仓分布
        返回: 包含持仓信息的字典，如果无法完全匹配则返回None
        """
        try:
            print("\n=== 开始从成交记录恢复持仓状态 ===")
            
            # 获取当前实际持仓
            actual_position = position_holding_qty(self.stock)
            if actual_position == 0:
                print("当前无持仓，跳过恢复")
                return None
            print(f"当前实际持仓: {actual_position}股")
                    
            # 获取最近31天的成交记录
            execution_ids = request_executionid(symbol=self.stock)
            if not execution_ids:
                print("无法获取成交记录")
                return None
            print(f"获取到 {len(execution_ids)} 条成交记录")
                    
            # 按时间顺序处理成交记录
            print("\n--- 成交记录明细 ---")
            print("时间\t\t\t方向\t价格\t数量\t状态")
            print("-" * 60)
            
            trades = []
            buy_total = 0
            sell_total = 0
            
            for eid in execution_ids:
                status = execution_status(eid)
                if status != "OK":
                    continue
                        
                price = execution_price(eid)
                qty = execution_qty(eid)
                side = execution_side(eid)
                trade_time = execution_time(eid)
                
                # 打印每笔成交
                print(f"{trade_time.strftime('%Y-%m-%d %H:%M:%S')}\t"
                    f"{side}\t{price:.2f}\t{qty}\t{status}")
                
                # 统计买卖总量
                if side == OrderSide.BUY:
                    buy_total += qty
                elif side == OrderSide.SELL:
                    sell_total += qty
                    
                trades.append({
                    'time': trade_time,
                    'price': price,
                    'quantity': qty,
                    'side': side
                })
                    
            # 按时间排序
            trades.sort(key=lambda x: x['time'])
            
            # 打印成交汇总
            net_position = buy_total - sell_total
            print("\n--- 成交汇总 ---")
            print(f"总买入: {buy_total}股")
            print(f"总卖出: {sell_total}股")
            print(f"净持仓: {net_position}股")
            print(f"实际持仓: {actual_position}股")
                    
            # 计算当前持仓的构成
            position_map = {}  # 记录每个价位的持仓
            total_position = 0
            
            print("\n--- 持仓构建过程 ---")
            for trade in trades:
                price = int(trade['price'] * 10) / 10  # 保持1位小数
                qty = trade['quantity']
                    
                if trade['side'] == OrderSide.BUY:
                    if price not in position_map:
                        position_map[price] = 0
                    position_map[price] += qty
                    total_position += qty
                    print(f"买入: {qty}股 @ {price:.1f}, 该价位累计持仓: {position_map[price]}")
                else:  # SELL
                    print(f"卖出处理: {qty}股")
                    # 从最高价的持仓开始减少
                    remaining_qty = qty
                    for p in sorted(position_map.keys(), reverse=True):
                        if remaining_qty <= 0:
                            break
                        if position_map[p] > 0:
                            deduct = min(position_map[p], remaining_qty)
                            position_map[p] -= deduct
                            remaining_qty -= deduct
                            total_position -= deduct
                            print(f"  从价位 {p:.1f} 扣减 {deduct}股, 剩余 {position_map[p]}股")
                            if position_map[p] == 0:
                                position_map.pop(p)
                                    
            # 验证计算结果
            calculated_position = sum(position_map.values())
            print("\n--- 持仓验证 ---")
            print(f"计算持仓: {calculated_position}股")
            print(f"实际持仓: {actual_position}股")
            
            if abs(calculated_position - actual_position) > 0.01:  # 允许0.01的误差
                print(f"警告：计算持仓与实际持仓不匹配，差额: {actual_position - calculated_position}股")
                return None
                    
            # 基于当前价格创建网格
            latest_price = current_price(self.stock)
            grid_spacing = latest_price * self.grid_percentage
            base_grid = int(latest_price * 10) / 10
            half_grids = self.grid_num // 2
            
            # 生成网格价格
            grid_prices = [base_grid]
            for i in range(half_grids):
                up_price = int((base_grid + (i + 1) * grid_spacing) * 10) / 10
                down_price = int((base_grid - (i + 1) * grid_spacing) * 10) / 10
                grid_prices.extend([up_price, down_price])
            grid_prices.sort()
            
            print("\n--- 网格创建 ---")
            print(f"当前价格: {latest_price:.1f}")
            print(f"网格间距: {grid_spacing:.1f}")
            print("网格价格: " + ", ".join([f"{p:.1f}" for p in grid_prices]))
                
            # 初始化网格和高位网格
            grid_positions = {price: 0 for price in grid_prices}
            grid_records = {
                price: {'buy_price': 0, 'quantity': 0, 'update_time': time.time()}
                for price in grid_prices
            }
            high_positions = {}
            high_records = {}
            
            # 最高网格价格
            highest_grid = grid_prices[0]
            for price in grid_prices[1:]:
                if price > highest_grid:
                    highest_grid = price
            print(f"\n--- 持仓分配到网格（最高网格价格: {highest_grid}）---")
            
            for price, qty in sorted(position_map.items()):
                if qty <= 0:
                    continue
                
                print(f"\n处理价格 {price:.1f} 的 {qty}股持仓")
                remaining_qty = qty

                # 判断是否应该进入高位网格
                if price > highest_grid:
                    print(f"价格 {price:.1f} 高于最高网格 {highest_grid:.1f}，保存为高位网格")
                    high_positions[price] = qty
                    high_records[price] = {
                        'buy_price': price,
                        'quantity': qty,
                        'update_time': time.time()
                    }
                    continue
                    
                # 判断是否高于最高网格
                if price > highest_grid:
                    print(f"价格 {price:.1f} 高于最高网格 {highest_grid:.1f}，保存为高位网格")
                    high_positions[price] = qty
                    high_records[price] = {
                        'buy_price': price,
                        'quantity': qty,
                        'update_time': time.time()
                    }
                    continue
                
                # 尝试分配到标准网格
                for grid_price in sorted(grid_prices, key=lambda x: abs(x - price)):
                    if remaining_qty <= 0:
                        break
                        
                    current_qty = grid_positions.get(grid_price, 0)
                    available_space = self.position_limit - current_qty
                    
                    if available_space > 0:
                        alloc_qty = min(remaining_qty, available_space)
                        grid_positions[grid_price] = current_qty + alloc_qty
                        if current_qty == 0:
                            grid_records[grid_price] = {
                                'buy_price': price,
                                'quantity': alloc_qty,
                                'update_time': time.time()
                            }
                        else:
                            # 计算加权平均成本
                            old_cost = grid_records[grid_price]['buy_price']
                            new_cost = (old_cost * current_qty + price * alloc_qty) / (current_qty + alloc_qty)
                            grid_records[grid_price].update({
                                'buy_price': new_cost,
                                'quantity': current_qty + alloc_qty,
                                'update_time': time.time()
                            })
                        remaining_qty -= alloc_qty
                        print(f"分配 {alloc_qty}股 到网格 {grid_price:.1f}")
                
                # 如果还有剩余，才转为高位网格
                if remaining_qty > 0:
                    print(f"剩余 {remaining_qty}股无法分配到标准网格，转为高位网格")
                    high_positions[price] = remaining_qty
                    high_records[price] = {
                        'buy_price': price,
                        'quantity': remaining_qty,
                        'update_time': time.time()
                    }
            
            # 清理原有的高位网格记录
            self.high_positions = {}
            self.high_records = {}
            
            # 更新高位网格
            self.high_positions.update(high_positions)
            self.high_records.update(high_records)
            
            total_grid_position = sum(grid_positions.values())
            total_high_position = sum(high_positions.values())
            
            print("\n--- 网格分配结果 ---")
            print("标准网格:")
            print("网格\t持仓\t成本")
            print("-" * 30)
            for grid, qty in sorted(grid_positions.items()):
                if qty > 0:
                    cost = grid_records[grid]['buy_price']
                    print(f"{grid:.1f}\t{qty}\t{cost:.1f}")
                    
            if high_positions:
                print("\n高位网格:")
                print("网格\t持仓\t成本")
                print("-" * 30)
                for grid, qty in sorted(high_positions.items()):
                    cost = high_records[grid]['buy_price']
                    print(f"{grid:.1f}\t{qty}\t{cost:.1f}")
            
            print(f"\n标准网格持仓: {total_grid_position}股")
            print(f"高位网格持仓: {total_high_position}股")
            print(f"总持仓: {total_grid_position + total_high_position}股")
            print(f"实际持仓: {actual_position}股")
                        
            if abs((total_grid_position + total_high_position) - actual_position) > 0.01:
                print("警告：恢复后的持仓总数与实际不符")
                return None
                        
            return {
                'positions': grid_positions,
                'records': grid_records,
                'total': total_grid_position + total_high_position
            }
                
        except Exception as e:
            print(f"从成交记录恢复持仓时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return None
            
    def _batch_update_positions(self, updates):
        """批量更新多个网格的持仓"""
        with self._position_lock:
            try:
                # 记录更新前的状态
                old_positions = self.positions.copy()
                old_records = {k: v.copy() for k, v in self.position_records.items()}
                old_total = self.total_position
                
                # 执行所有更新
                for grid_price, qty, is_buy, price in updates:
                    if is_buy:
                        current_pos = self.positions.get(grid_price, 0)
                        new_qty = current_pos + qty
                        self.positions[grid_price] = new_qty
                        self.position_records[grid_price] = {
                            'buy_price': price,
                            'quantity': new_qty,
                            'update_time': time.time()
                        }
                    else:
                        if grid_price in self.positions:
                            current_pos = self.positions[grid_price]
                            if current_pos <= qty:
                                del self.positions[grid_price]
                                self.position_records[grid_price] = {
                                    'buy_price': 0,
                                    'quantity': 0,
                                    'update_time': time.time()
                                }
                            else:
                                new_qty = current_pos - qty
                                self.positions[grid_price] = new_qty
                                self.position_records[grid_price].update({
                                    'quantity': new_qty,
                                    'update_time': time.time()
                                })
                
                # 验证更新结果
                if self._verify_positions():
                    print(f"批量更新持仓成功 - 总持仓:{self.total_position}")
                    self._print_grid_status(show_all=False, show_time=True)
                    return True
                
                # 如果验证失败，回滚更新
                print("批量更新持仓验证失败，执行回滚")
                self.positions = old_positions
                self.position_records = old_records
                self.total_position = old_total
                return False
                    
            except Exception as e:
                print(f"批量更新持仓失败: {str(e)}")
                return False

    def _check_high_grid_profit(self, current_price):
        """检查高位网格是否有盈利机会"""
        try:
            if not self.high_positions:
                return False
                
            profitable_grids = []
            total_sell_quantity = 0
            
            # 检查每个高位网格
            for grid_price, qty in self.high_positions.items():
                if qty <= 0:
                    continue
                    
                record = self.high_records.get(grid_price, {})
                buy_price = record.get('buy_price', grid_price)
                price_diff = (current_price - buy_price) / buy_price
                
                if price_diff >= self.grid_percentage:
                    print(f"高位网格 {grid_price:.1f} 符合盈利条件: 成本={buy_price:.1f}, 盈利={price_diff:.1%}")
                    profitable_grids.append((grid_price, qty, buy_price))
                    total_sell_quantity += qty
            
            # 执行批量卖出
            if profitable_grids:
                return self._execute_high_grid_sell(profitable_grids, current_price)
                
            return False
            
        except Exception as e:
            print(f"检查高位网格盈利失败: {str(e)}")
            return False
    
    def _execute_high_grid_sell(self, profitable_grids, current_price):
        """执行高位网格的平仓操作"""
        try:
            total_quantity = sum(grid[1] for grid in profitable_grids)
            
            sell_order_id = place_market(
                symbol=self.stock,
                qty=total_quantity,
                side=OrderSide.SELL,
                time_in_force=TimeInForce.DAY
            )
            
            if not sell_order_id:
                return False
                
            self.pending_orders.add(sell_order_id)
            
            try:
                if self._check_order_status(sell_order_id):
                    # 更新高位网格记录
                    for grid_price, qty, _ in profitable_grids:
                        self.high_positions[grid_price] = 0
                        self.high_records[grid_price] = {
                            'buy_price': 0,
                            'quantity': 0,
                            'update_time': time.time()
                        }
                        print(f"高位网格平仓成功: 网格={grid_price:.1f}, 数量={qty}")
                    
                    # 更新总持仓
                    self.total_position = sum(self.positions.values()) + sum(self.high_positions.values())
                    
                    # 清理空仓的高位网格记录
                    self._clean_empty_high_grids()
                    
                    # 打印更新后的状态
                    self._print_grid_status(show_all=True, show_time=True)
                    return True
            finally:
                self.pending_orders.discard(sell_order_id)
                
            return False
            
        except Exception as e:
            print(f"执行高位网格平仓失败: {str(e)}")
            return False

    def _clean_empty_high_grids(self):
        """清理空仓的高位网格记录"""
        try:
            # 清理空仓位
            empty_grids = [grid for grid, qty in self.high_positions.items() 
                        if qty <= 0 or grid in self.positions]
            
            for grid in empty_grids:
                if grid in self.high_positions:
                    print(f"清理高位网格: {grid}")
                    self.high_positions.pop(grid)
                    self.high_records.pop(grid)
            
            # 验证清理结果
            for grid in self.high_positions:
                if grid in self.positions:
                    print(f"警告: 高位网格{grid}仍与标准网格重叠")
                    
        except Exception as e:
            print(f"清理高位网格时发生错误: {str(e)}")