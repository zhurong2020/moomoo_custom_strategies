class Strategy(StrategyBase):
    """DCA定投策略 - 统一开发版 v2.8.1"""

    def initialize(self):
        """初始化策略"""
        try:
            self._version = "v2.8.1-MainDev"
            
            print("🚀 开始初始化 {0}".format(self._version))
            
            # 核心状态变量
            self.last_investment_time = None
            self.highest_price = None  # 兼容性保留
            self.run_highest_price = None  # 新的运行时最高价
            self.last_valid_price = 100.0
            self.strategy_start_price = None
            self.drawdown_reset_threshold = 0.05
            
            # 简化状态管理
            
            # 回测支持变量
            import collections
            self.high_queue = collections.deque(maxlen=20)
            self._position = 0
            self._total_cost = 0.0
            self.virtual_balance = None
            
            # VIP推广控制变量
            self._vip_promotion_shown = False
            self._layer_promotion_shown = {}
            
            # 初始化组件
            self.trigger_symbols()
            self.custom_indicator()
            self.global_variables()
            self.setup_presets()  # 预设设置先执行，设定effective_qty
            self.setup_tier_features()  # 分层功能后执行，依赖effective_qty
            
            # v2.4.0 新增: 初始化历史最高价基准
            self.initialize_highest_price_baseline()
            
            print("✅ 初始化完成")
            self.print_welcome()
            
        except Exception as e:
            print("❌ 初始化失败: {0}".format(str(e)))

    def trigger_symbols(self):
        """设置交易标的"""
        try:
            self.stock = declare_trig_symbol()
            print("📈 交易标的: {0}".format(self.stock))
        except Exception as e:
            print("❌ 标的设置失败: {0}".format(str(e)))

    def custom_indicator(self):
        """注册自定义技术指标"""
        try:
            self.register_indicator(
                indicator_name='MA',
                script='MA5:MA(CLOSE,5),COLORFF8D1E;',
                param_list=[]
            )
        except Exception as e:
            print("❌ 技术指标注册失败: {0}".format(str(e)))

    def global_variables(self):
        """全局变量设置"""
        try:
            # === 基础参数 ===
            self.qty = show_variable(20, GlobalType.INT)
            self.preset_mode = show_variable(2, GlobalType.INT)  # 默认平衡型
            self.backtest = show_variable(True, GlobalType.BOOL)
            self.basic_invest_only = show_variable(False, GlobalType.BOOL)
            
            # === 分层功能参数 ===
            self.version_tier = show_variable(2, GlobalType.INT)  # 1=免费版 2=付费版
            self.balance_mode = show_variable(2, GlobalType.INT)  # 使用自定义资金
            self.custom_balance = show_variable(100000, GlobalType.INT)  # 增加到10万
            self.interval_mode = show_variable(1, GlobalType.INT)  # 自动模式
            self.custom_interval_min = show_variable(1440, GlobalType.INT)
            
            # === v2.4.0 新增: 激进乘数系统 ===
            self.aggressive_multiplier = show_variable(1.0, GlobalType.FLOAT)  # 1.0-2.5倍乘数
            
            # === v2.8.0 新增: 数据收集模式 ===  
            self.data_collection_mode = show_variable(0, GlobalType.INT)  # 0=正常 1=纯数据收集
            
            # 基础固定参数 - v2.5.0扩展支持
            # 免费版: 3层, 付费版: 5层
            if self.version_tier == 1:
                self.drawdown_layers = [5.0, 10.0, 20.0]
                self.base_multipliers = [1.5, 2.0, 3.0]
            else:  # self.version_tier == 2 (付费版)
                self.drawdown_layers = [5.0, 10.0, 20.0, 35.0, 50.0] 
                self.base_multipliers = [1.5, 2.0, 3.0, 4.0, 5.0]
            
            self.extreme_drawdown_pct = 60.0  # 超过最高层的极端回撤阈值
            self.log_level = 0
            
            # v2.6.0新增: 功能体验券系统
            self.trial_voucher_used = False  # 是否已使用体验券
            self.trial_voucher_available = (self.version_tier == 1)  # 仅免费版提供体验券
            
            # 动态计算最终倍数 - 在setup_tier_features()中设置
            self.drawdown_multipliers = self.base_multipliers  # 默认值
            
            print("⚙️ 参数配置完成")
            
        except Exception as e:
            print("❌ 参数设置失败: {0}".format(str(e)))

    def setup_presets(self):
        """设置预设模板 - 实际应用数量设置"""
        try:
            presets = {
                1: {"name": "保守型", "description": "低风险", "base_qty": 10, "risk_level": "低"},
                2: {"name": "平衡型", "description": "中等风险", "base_qty": 15, "risk_level": "中"},
                3: {"name": "积极型", "description": "高风险", "base_qty": 25, "risk_level": "高"}
            }
            
            if self.preset_mode in presets:
                preset = presets[self.preset_mode]
                self.preset_name = preset["name"]
                self.preset_desc = preset["description"]
                self.risk_level = preset["risk_level"]
                
                # 尊重用户设置，预设仅作为建议
                self.effective_qty = self.qty
                recommended_qty = preset["base_qty"]
                
                if self.qty != recommended_qty:
                    print("💡 预设建议: {0}推荐{1}股，您选择{2}股".format(
                        self.preset_name, recommended_qty, self.qty))
                else:
                    print("✅ 预设匹配: {0} - 投资数量: {1}股".format(
                        self.preset_name, self.qty))
                    
            else:
                self.preset_name = "自定义"
                self.preset_desc = "用户自定义参数"
                self.risk_level = "中"
                self.effective_qty = self.qty
                
            print("🎨 预设配置: {0} - 数量: {1}股".format(self.preset_name, self.effective_qty))
            
        except Exception as e:
            print("❌ 预设配置失败: {0}".format(str(e)))
            self.preset_name = "默认"
            self.preset_desc = "系统默认配置"
            self.risk_level = "中"
            self.effective_qty = self.qty

    def setup_tier_features(self):
        """设置分层功能特性"""
        try:
            # 资金管理设置
            if self.version_tier >= 2 and self.balance_mode == 2:
                if self.backtest:
                    self.initial_balance = self.custom_balance
                    self.virtual_balance = self.custom_balance
                print("💰 使用自定义资金: ${0:,}".format(self.custom_balance))
            else:
                if self.backtest:
                    try:
                        self.initial_balance = total_cash(currency=Currency.USD)
                        if self.initial_balance is None or self.initial_balance <= 0:
                            self.initial_balance = 10000.0
                        self.virtual_balance = self.initial_balance
                    except:
                        self.initial_balance = 10000.0
                        self.virtual_balance = 10000.0
                        print("⚠️ 使用默认资金$10,000")
                
            # 投资周期设置
            if self.interval_mode == 1:  # 自动模式
                if self.version_tier == 1:
                    self.interval_min = 10080  # 每周
                    self.interval_desc = "每周定投 (免费版)"
                else:
                    # 付费版智能频率：根据资金和数量自动调整
                    daily_cost = self.effective_qty * 600  # 估算每日成本(SPY约$600)
                    max_days = int(self.virtual_balance / daily_cost)
                    
                    # 考虑智能加仓预留资金 (预留30%资金用于加仓)
                    conservative_days = int(max_days * 0.7)
                    
                    if conservative_days >= 5:  # 保守预估5天以上，使用每日定投
                        self.interval_min = 1440
                        self.interval_desc = "每日定投 (付费版智能)"
                    elif conservative_days >= 2:  # 保守预估2天以上，使用每周定投
                        self.interval_min = 10080
                        self.interval_desc = "每周定投 (付费版智能)"
                    else:  # 资金严重不足，使用双周
                        self.interval_min = 20160
                        self.interval_desc = "双周定投 (资金优化)"
                        
                    print("📊 智能频率计算: 预估{0}天资金(保守{1}天)，选择{2}".format(max_days, conservative_days, self.interval_desc))
                    
            elif self.interval_mode == 2:  # 强制每日
                if self.version_tier >= 2:
                    self.interval_min = 1440
                    self.interval_desc = "每日定投"
                else:
                    print("💡 每日定投为付费版功能")
                    self.interval_min = 10080
                    self.interval_desc = "每周定投 (免费版限制)"
            elif self.interval_mode == 3:  # 每周
                self.interval_min = 10080
                self.interval_desc = "每周定投"
            elif self.interval_mode == 4:  # 自定义
                if self.version_tier >= 2:
                    self.interval_min = self.custom_interval_min
                    self.interval_desc = "自定义周期 ({0}分钟)".format(self.interval_min)
                else:
                    print("💡 自定义周期为付费版功能")
                    self.interval_min = 10080
                    self.interval_desc = "每周定投 (免费版限制)"
            
            print("📅 投资周期: {0}".format(self.interval_desc))
            
            # v2.4.0 新增: 设置激进乘数系统
            self.setup_aggressive_multiplier_system()
            
        except Exception as e:
            print("❌ 分层功能设置失败: {0}".format(str(e)))
            self.interval_min = 10080 if getattr(self, 'version_tier', 1) == 1 else 1440
            self.interval_desc = "默认周期 ({0}分钟)".format(self.interval_min)
            if not hasattr(self, 'virtual_balance') or self.virtual_balance is None:
                self.virtual_balance = 10000.0
                self.initial_balance = 10000.0

    def initialize_highest_price_baseline(self):
        """初始化历史最高价基准 - v2.4.0新增"""
        try:
            print("📈 正在初始化历史最高价基准...")
            
            # 使用bar_custom API获取过去200个交易日的最高价
            historical_high = bar_custom(
                symbol=self.stock,
                data_type=BarDataType.HIGH,
                custom_num=200,  # 约200个交易日（约1年）
                custom_type=CustomType.D1,
                select=1
            )
            
            if historical_high and historical_high > 0:
                self.run_highest_price = historical_high
                print("✅ 历史最高价基准: ${0:.2f} (200日内)".format(historical_high))
            else:
                # 如果无法获取历史数据，使用当前价格
                current_price_val = current_price(self.stock, price_type=THType.FTH)
                if current_price_val and current_price_val > 0:
                    self.run_highest_price = current_price_val
                else:
                    self.run_highest_price = self.last_valid_price
                print("⚠️ 无法获取历史数据，使用当前价格: ${0:.2f}".format(self.run_highest_price))
            
            # 兼容性设置
            self.highest_price = self.run_highest_price
            
        except Exception as e:
            print("❌ 历史最高价初始化失败: {0}".format(str(e)))
            # 回退到当前价格
            self.run_highest_price = self.last_valid_price
            self.highest_price = self.run_highest_price
            print("🔧 使用默认值: ${0:.2f}".format(self.run_highest_price))

    def setup_aggressive_multiplier_system(self):
        """设置激进乘数系统 - v2.4.0新增"""
        try:
            print("🎯 正在设置激进乘数系统...")
            
            # 根据版本层级设置乘数限制
            if self.version_tier == 1:
                # 免费版：固定标准倍数
                self.aggressive_multiplier = 1.0
                print("🆓 免费版: 使用标准乘数 1.0x")
            elif self.version_tier == 2:
                # 付费版：允许激进乘数 1.0-2.5
                multiplier_input = getattr(self, 'aggressive_multiplier', 1.0)
                if multiplier_input < 1.0:
                    self.aggressive_multiplier = 1.0
                    print("⚠️ 乘数不能小于1.0，设置为1.0x")
                elif multiplier_input > 2.5:
                    self.aggressive_multiplier = 2.5
                    print("⚠️ 乘数不能超过2.5，设置为2.5x")
                else:
                    self.aggressive_multiplier = multiplier_input
                
                print("💰 付费版: 使用激进乘数 {0}x".format(self.aggressive_multiplier))
            
            # 计算最终倍数
            self.drawdown_multipliers = [
                m * self.aggressive_multiplier for m in self.base_multipliers
            ]
            
            print("📋 基础倍数: {0}".format(self.base_multipliers))
            print("🚀 最终倍数: {0}".format(["{0:.1f}x".format(m) for m in self.drawdown_multipliers]))
            
            # 显示层级和倍数对应关系
            for i, (layer, multiplier) in enumerate(zip(self.drawdown_layers, self.drawdown_multipliers)):
                print("   第{0}层: {1}%回撤 → {2:.1f}倍加仓".format(i+1, layer, multiplier))
            
        except Exception as e:
            print("❌ 激进乘数设置失败: {0}".format(str(e)))
            # 回退到标准倍数
            self.aggressive_multiplier = 1.0
            self.drawdown_multipliers = self.base_multipliers
            print("🔧 使用标准倍数")

    def print_welcome(self):
        """打印欢迎信息"""
        version_info = {
            1: {"name": "免费基础版", "features": "固定定投+智能体验券", "color": "🆓"},
            2: {"name": "付费进阶版(¥35/月)", "features": "5层智能加仓系统", "color": "💎"}
        }
        
        current_version = version_info.get(self.version_tier, version_info[1])
        
        print("="*60)
        print("🚀 DCA智能定投策略 {0}".format(self._version))
        print("="*60)
        print("{0} 当前版本: {1}".format(current_version['color'], current_version['name']))
        print("✨ 核心功能: {0}".format(current_version['features']))
        
        print("\n📊 当前配置:")
        print("   版本等级: {0} ({1})".format(self.version_tier, '免费版' if self.version_tier == 1 else '付费版'))
        print("   投资模板: {0} ({1})".format(self.preset_name, self.preset_desc))
        print("   用户设置: {0}股".format(self.qty))
        print("   实际投资: {0}股".format(self.effective_qty))
        print("   投资周期: {0}".format(getattr(self, 'interval_desc', '未知')))
        if hasattr(self, 'virtual_balance'):
            print("   初始资金: ${0:,.0f}".format(self.virtual_balance))
            # 计算大约可投资天数
            daily_cost = self.effective_qty * 600  # 估算
            estimated_days = int(self.virtual_balance / daily_cost)
            conservative_days = int(estimated_days * 0.7)
            print("   预估投资: 约{0}天 (保守{1}天，预留加仓资金)".format(estimated_days, conservative_days))
        print("   运行模式: {0}".format('回测' if self.backtest else '实盘'))
        
        # v2.4.0 新增：显示激进乘数系统
        if hasattr(self, 'run_highest_price'):
            print("   历史最高价: ${0:.2f}".format(self.run_highest_price))
        if hasattr(self, 'aggressive_multiplier'):
            print("   激进乘数: {0}x".format(self.aggressive_multiplier))
        if hasattr(self, 'drawdown_multipliers'):
            print("   回撤层级: {0}".format(self.drawdown_layers))
            print("   加仓倍数: {0}".format(["{0:.1f}x".format(m) for m in self.drawdown_multipliers]))
        
        if self.version_tier == 1:
            print("\n🎁 免费版专享:")
            print("   ✨ 智能加仓体验券: 1次 (10%回撤时自动触发)")
            print("   📈 体验2.0倍加仓威力，感受付费版功能")
            print("\n🎯 升级提示:")
            print("   💎 付费版支持完整5层智能加仓系统")
            print("   ⚡ 激进乘数最高2.5x，长期收益更优")
            print("   💰 联系作者升级至付费版(¥35/月)")
        else:
            # 付费版显示数据收集模式说明
            if getattr(self, 'data_collection_mode', 0) == 1:
                print("\n🔍 数据收集模式已启用:")
                print("   📊 纯粹每日定投 - 无任何复杂计算和判断")
                print("   ⚡ 专为快速获取长期历史数据设计")
                print("   📈 每日无条件投资{0}股，适合1年+回测".format(self.effective_qty))
                print("   🚀 高速数据收集，无策略逻辑干扰")
            else:
                print("\n💎 付费版高级功能:")
                print("   🔍 数据收集模式: 设置data_collection_mode=1启用")
                print("   📊 纯每日定投模式，专为获取历史数据设计")
        
        print("="*60 + "\n")

    def handle_data(self):
        """主要交易逻辑"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            latest_price, account_balance = self.get_market_data()
            
            drawdown = self.calculate_drawdown(latest_price)
            
            # 添加调试信息（减少频率）
            if hasattr(self, 'bar_index') and self.bar_index % 20 == 0:  # 每20个bar打印一次
                print("📊 第{0}天 | 价格: ${1:.2f} | 余额: ${2:,.0f}".format(
                    self.bar_index, latest_price, account_balance))
            
            # 分层功能路由
            if self.version_tier == 1:
                self.free_version_logic(current_time, latest_price, account_balance, drawdown)
            elif self.version_tier == 2:
                self.advanced_version_logic(current_time, latest_price, account_balance, drawdown)
            else:
                print("⚠️ 版本参数错误，使用免费版功能")
                self.free_version_logic(current_time, latest_price, account_balance, drawdown)

        except Exception as e:
            print("❌ 策略执行错误: {0}".format(str(e)))

    def get_market_data(self):
        """获取市场数据 - v2.7.0重构统一版"""
        latest_price = None
        account_balance = None
        
        try:
            if self.backtest:
                latest_price = self._get_backtest_price()
                account_balance = self.virtual_balance
            else:
                latest_price = self._get_live_price()
                account_balance = self._get_live_balance()
            
            # 统一的价格验证和更新逻辑
            latest_price = self._validate_and_update_price(latest_price)
            
            return latest_price, account_balance
            
        except Exception as e:
            print("市场数据获取错误: {0}".format(str(e)))
            return self._get_fallback_data()
    
    def _get_backtest_price(self):
        """获取回测价格"""
        if not hasattr(self, 'bar_index'):
            self.bar_index = 0
        self.bar_index += 1
        
        price = bar_close(self.stock, bar_type=BarType.D1, select=1)
        return price if price and price > 0 else 100.0
    
    def _get_live_price(self):
        """获取实盘价格"""
        return current_price(self.stock, price_type=THType.FTH)
    
    def _get_live_balance(self):
        """获取实盘余额"""
        return total_cash(currency=Currency.USD)
    
    def _validate_and_update_price(self, price):
        """验证并更新价格"""
        if price is None or price <= 0:
            price = self.last_valid_price
        else:
            self.last_valid_price = price
        return price
    
    def _get_fallback_data(self):
        """获取回退数据"""
        default_balance = getattr(self, 'virtual_balance', 10000.0) or 10000.0
        return self.last_valid_price, default_balance

    def calculate_drawdown(self, latest_price):
        """计算回撤幅度 - v2.4.0修复版"""
        # 初始化检查
        if not hasattr(self, 'run_highest_price') or self.run_highest_price is None:
            self.run_highest_price = latest_price
            print("⚠️ 运行时初始化最高价: ${0:.2f}".format(latest_price))
            
        # 实时更新运行时最高价
        if latest_price > self.run_highest_price:
            old_high = self.run_highest_price
            self.run_highest_price = latest_price
            print("📈 创新高: ${0:.2f} → ${1:.2f}".format(old_high, latest_price))
            
            # 价格创新高时重置回撤层级
            if hasattr(self, 'current_drawdown_layer'):
                self.current_drawdown_layer = -1
        
        # 兼容性更新旧的highest_price
        self.highest_price = self.run_highest_price
        
        # 计算准确回撤
        if self.run_highest_price > 0:
            drawdown = (self.run_highest_price - latest_price) / self.run_highest_price * 100
        else:
            drawdown = 0.0
            
        return drawdown

    def calculate_add_position_qty(self, drawdown):
        """计算加仓数量 - v2.4.1修复版：从高层级往低层级检查"""
        # v2.5.0新增: 检查是否超出最高层级的极端回撤
        max_layer_threshold = self.drawdown_layers[-1]
        if drawdown > max_layer_threshold and drawdown >= self.extreme_drawdown_pct:
            if not hasattr(self, '_extreme_drawdown_warned'):
                print("🚨 极端回撤警告: 当前回撤{0:.1f}%超过第{1}层({2}%)".format(
                    drawdown, len(self.drawdown_layers), max_layer_threshold))
                print("📱 建议考虑VIP App的高级回撤管理功能")
                self._extreme_drawdown_warned = True
        
        # v2.6.0新增: 功能体验券逻辑
        if self.version_tier == 1:  # 仅免费版处理体验券
            return self._handle_free_tier_experience(drawdown)
        
        # 付费版正常处理
        return self._handle_paid_tier_drawdown(drawdown)
    
    def _handle_free_tier_experience(self, drawdown):
        """处理免费版体验券逻辑"""
        # 检查是否达到第2层(10%回撤)
        if drawdown >= 10.0:
            if self.trial_voucher_available and not self.trial_voucher_used:
                # 使用体验券！
                self.trial_voucher_used = True
                add_qty = int(self.effective_qty * 2.0)  # 第2层倍数
                
                print("=" * 60)
                print("🎉 恭喜！您已触发并使用了【智能加仓体验券】！")
                print("🎯 体验功能: 第2层智能加仓 (10%回撤阈值)")
                print("💰 本次加仓: {0}股 (2.0倍增强)".format(add_qty))
                print("⚡ 这就是付费版的威力 - 自动在最佳时机加仓！")
                print("=" * 60)
                print("⚠️ 重要提醒: 体验券仅此一次，后续智能加仓需要升级付费版")
                print("💎 付费版提供完整的5层智能加仓系统")
                print("📈 激进乘数最高2.5x，长期投资收益更优")
                print("=" * 60)
                
                return add_qty
            else:
                # 体验券已用完，显示焦虑驱动转化
                if self.trial_voucher_used:
                    self._show_anxiety_driven_conversion(drawdown)
                else:
                    # 还未使用体验券但不符合条件
                    print("🔍 市场回调{0:.1f}%，暂未达到体验券触发阈值(10%)".format(drawdown))
    
    def _show_anxiety_driven_conversion(self, drawdown):
        """显示焦虑驱动的付费转化文案"""
        print("=" * 60)
        print("🚨 【市场风险警告】回撤已达 {0:.1f}%！".format(drawdown))
        print("📉 当前正处于投资的黄金加仓时机，但您的体验券已用完")
        
        if drawdown >= 20.0:
            print("🔥 【深度回撤】这是付费版用户最激动的时刻！")
            print("💎 付费版此时将触发第3层智能加仓 (3.0倍增强)")
            print("📈 历史数据显示：20%+回撤后6个月内平均收益+15%")
        elif drawdown >= 15.0:
            print("⚡ 【机会窗口】付费版用户正在享受智能加仓！")
            print("💰 付费版此时将触发第2层智能加仓 (2.0倍)")
        else:
            print("💡 【错失机会】付费版用户此时将获得智能加仓 (2.0倍)")
        
        print("\n✅ 【付费版解决方案】")
        print("   🛡️ 5层智能加仓系统 - 每个回撤层级都有精确应对")
        print("   ⚡ 激进乘数最高2.5x - 极端回撤时加倍抄底")
        print("   🎯 历史验证收益 - 长期跑赢免费版33-67%")
        
        print("\n⏰ 机会稍纵即逝，立即升级享受完整智能加仓！")
        print("=" * 60)
        
        return 0  # 免费版不提供常规智能加仓
    
    def _handle_paid_tier_drawdown(self, drawdown):
        """处理付费版回撤加仓"""
        # v2.4.1 修复: 从最高层级开始检查（从后往前遍历）
        for i in reversed(range(len(self.drawdown_layers))):
            threshold = self.drawdown_layers[i]
            if drawdown >= threshold:
                # 激进抄底策略 - 选择最适合的层级
                add_qty = int(self.effective_qty * self.drawdown_multipliers[i])
                
                print("📊 回撤加仓触发: 第{0}层 ({1}%), 实际回撤{2:.1f}%, 数量={3}股".format(
                    i+1, threshold, drawdown, add_qty))
                print("📈 乘数详情: 基础{0}股 × {1:.1f}倍 = {2}股".format(
                    self.effective_qty, self.drawdown_multipliers[i], add_qty))
                
                # VIP推广信息 - 每个层级只显示一次
                layer_key = "layer_{0}".format(i+1)
                if not self._vip_promotion_shown and layer_key not in self._layer_promotion_shown:
                    self._layer_promotion_shown[layer_key] = True
                    if i >= 2:  # 第3层及以上显示VIP推广
                        print("💡 VIP版本提供11层成本定投算法，在{0:.1f}%回撤时有更精细的加仓策略".format(drawdown))
                        print("📞 联系微信获取VIP完整版(¥500/年)，包含AI参数优化和多标的投资组合")
                        self._vip_promotion_shown = True  # 全局标记，避免后续层级重复显示
                
                return add_qty
        
        return 0

    def should_invest(self, current_time):
        """判断是否应该定投"""
        if self.last_investment_time is None:
            return True
        elapsed = (current_time - self.last_investment_time).total_seconds() / 60
        
        if not hasattr(self, 'interval_min') or self.interval_min is None:
            default_interval = 10080 if getattr(self, 'version_tier', 1) == 1 else 1440
            self.interval_min = default_interval
        
        should_invest_now = elapsed >= self.interval_min
        
        # 调试信息
        if elapsed > 0:
            print("⏰ 定投检查: 间隔{0:.0f}分钟 / 需要{1}分钟 = {2}".format(
                elapsed, self.interval_min, "✅可定投" if should_invest_now else "⏳等待中"))
        
        return should_invest_now

    def free_version_logic(self, current_time, latest_price, account_balance, drawdown):
        """免费版策略逻辑"""
        
        # 风险提醒功能
        if drawdown >= 20.0:
            print("⚠️ 免费版风险提醒: 当前回撤{0:.1f}%".format(drawdown))
        elif drawdown >= 10.0:
            print("📢 回撤监控: 当前回撤{0:.1f}%".format(drawdown))
            
        # 定投逻辑
        basic_only = bool(getattr(self, 'basic_invest_only', False))
        if basic_only or True:  # 免费版只做定投
            if self.should_invest(current_time):
                self.execute_investment(latest_price, account_balance, self.effective_qty, "基础定投")

    def advanced_version_logic(self, current_time, latest_price, account_balance, drawdown):
        """付费版策略逻辑"""
        
        if self.version_tier != 2:
            print("💡 智能加仓功能需要升级到付费版(¥35/月)")
            return self.free_version_logic(current_time, latest_price, account_balance, drawdown)
        
        # v2.8.0新增: 数据收集模式 - 纯粹的每日定投，无任何判断逻辑
        if getattr(self, 'data_collection_mode', 0) == 1:
            return self.data_collection_mode_logic(current_time, latest_price, account_balance)
        
        # 极端回撤保护
        if drawdown >= self.extreme_drawdown_pct:
            print("🚨 极端回撤保护: {0:.1f}%，仅定投模式".format(drawdown))
            if self.should_invest(current_time):
                self.execute_investment(latest_price, account_balance, self.effective_qty, "极端回撤保护")
            return

        # 智能加仓系统
        add_qty = self.calculate_add_position_qty(drawdown)
        if add_qty > 0:
            self.execute_investment(latest_price, account_balance, add_qty, "付费版-智能加仓")
            return

        # 常规定投
        if self.should_invest(current_time):
            self.execute_investment(latest_price, account_balance, self.effective_qty, "付费版-定期定投")
    
    def data_collection_mode_logic(self, current_time, latest_price, account_balance):
        """数据收集模式 - v2.8.0新增: 纯粹每日定投，专为获取历史数据设计"""
        
        # 简单日志输出，记录关键数据
        if hasattr(self, 'bar_index'):
            bar_count = self.bar_index
        else:
            bar_count = getattr(self, '_data_collection_day_count', 0)
            self._data_collection_day_count = bar_count + 1
        
        # 每10天输出一次进度 
        if bar_count % 10 == 0:
            total_position = self.get_position()
            total_cost = self.get_total_cost()
            avg_cost = total_cost / total_position if total_position > 0 else 0
            current_value = total_position * latest_price
            
            print("📊 数据收集第{0}天: 价格=${1:.2f} | 持仓{2}股 | 成本${3:.2f} | 价值${4:,.0f}".format(
                bar_count, latest_price, total_position, avg_cost, current_value))
        
        # 纯粹的每日定投 - 无任何条件判断
        self.execute_investment(latest_price, account_balance, self.effective_qty, "数据收集模式")
        
        # 记录数据收集状态
        if not hasattr(self, '_data_collection_started'):
            self._data_collection_started = True
            print("🔍 数据收集模式已启动 - 每日无条件投资{0}股".format(self.effective_qty))
            print("📈 此模式专为快速获取长期历史数据设计，无任何复杂逻辑")

    def execute_investment(self, latest_price, account_balance, quantity, trade_type="定投"):
        """执行投资 - v2.7.0重构统一版"""
        
        # 1. 统一的参数验证
        quantity = self._validate_investment_quantity(quantity)
        if quantity <= 0:
            return
        
        # 2. 统一的资金检查和调整
        quantity, required_cash = self._adjust_quantity_for_balance(
            quantity, latest_price, account_balance)
        if quantity <= 0:
            return
            
        # 3. 统一的下单执行
        success = self._execute_order(quantity, latest_price, trade_type)
        if not success:
            return
            
        # 4. 统一的账户更新
        self._update_account_after_trade(quantity, required_cash)
        
        # 5. 更新最后投资时间
        self.last_investment_time = device_time(TimeZone.DEVICE_TIME_ZONE)
    
    def _validate_investment_quantity(self, quantity):
        """验证投资数量"""
        if self.version_tier == 2:
            # 付费版参数验证
            if quantity < 1 or quantity > 1000:
                print("⚠️ 付费版参数修正: 投资数量 {0} -> {1}股".format(quantity, self.effective_qty))
                return self.effective_qty
        else:
            # 免费版参数验证
            if quantity < 10 or quantity > 100 or quantity % 10 != 0:
                print("⚠️ 免费版参数修正: 投资数量 {0} -> 10股".format(quantity))
                return 10
        return quantity
    
    def _adjust_quantity_for_balance(self, quantity, latest_price, account_balance):
        """根据余额调整投资数量"""
        required_cash = quantity * latest_price
        
        if self.backtest:
            return self._adjust_for_backtest_balance(quantity, latest_price, required_cash)
        else:
            return self._adjust_for_live_balance(quantity, latest_price, account_balance, required_cash)
    
    def _adjust_for_backtest_balance(self, quantity, latest_price, required_cash):
        """回测模式资金调整"""
        if self.virtual_balance is None:
            self.virtual_balance = 10000.0
        
        if required_cash > self.virtual_balance:
            max_qty = int(self.virtual_balance // latest_price)
            if max_qty < 1:
                print("💰 虚拟余额不足: ${0:.0f} < ${1:.0f}".format(self.virtual_balance, required_cash))
                print("📊 建议: 增加initial_balance或减少投资频率")
                return 0, 0
            
            quantity = max_qty
            required_cash = quantity * latest_price
            print("⚠️ 智能资金调整: 原计划{0}股 → 实际{1}股 (剩余${2:.0f})".format(
                int(self.effective_qty), quantity, self.virtual_balance))
        
        return quantity, required_cash
    
    def _adjust_for_live_balance(self, quantity, latest_price, account_balance, required_cash):
        """实盘模式资金调整"""
        if required_cash > account_balance:
            max_qty = int((account_balance // latest_price) // 10 * 10)
            if max_qty < 10:
                print("💰 资金不足，无法投资")
                return 0, 0
            
            quantity = max_qty
            required_cash = quantity * latest_price
            print("⚠️ 资金调整: 投资数量调整为 {0}股".format(quantity))
        
        return quantity, required_cash
    
    def _execute_order(self, quantity, latest_price, trade_type):
        """执行下单"""
        try:
            order_id = place_market(self.stock, quantity, OrderSide.BUY, TimeInForce.DAY)
            
            if self.backtest:
                # 简化回测输出
                if "加仓" in trade_type:
                    print("🔥 {0}: {1}股 @ ${2:.2f}".format(trade_type, quantity, latest_price))
                else:
                    print("📊 {0}: {1}股 @ ${2:.2f}".format(trade_type, quantity, latest_price))
            else:
                print("✅ {0}订单: {1}股 @ 市价, ID: {2}".format(trade_type, quantity, order_id))
            
            return True
            
        except Exception as e:
            print("❌ 下单失败: {0}".format(str(e)))
            return False
    
    def _update_account_after_trade(self, quantity, required_cash):
        """交易后更新账户"""
        if self.backtest:
            self.virtual_balance -= required_cash
            self._total_cost += required_cash
            self._position += quantity
            if hasattr(self, 'bar_index') and self.bar_index % 10 == 0:  # 每10个交易日打印一次
                print("💰 余额: ${0:,.0f} | 持仓: {1}股".format(self.virtual_balance, self._position))

    def get_position(self):
        """获取持仓数量"""
        if self.backtest:
            return self._position
        try:
            return position_holding_qty(self.stock)
        except:
            return 0

    def get_total_cost(self):
        """获取总成本"""
        if self.backtest:
            return self._total_cost
        try:
            pos = position_holding_qty(self.stock)
            avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
            return pos * avg_cost
        except:
            return 0.0

    def get_avg_cost(self):
        """获取平均成本"""
        if self.backtest:
            return self._total_cost / self._position if self._position > 0 else 0.0
        try:
            return position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
        except:
            return 0.0