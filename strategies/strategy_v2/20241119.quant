class Strategy(StrategyBase):
    """网格交易策略V6.1 - 修订订单和成交信息同步延迟问题"""
    
    def initialize(self):
        """初始化策略"""
        try:
            # 初始化基本数据结构
            self.grid_prices = []        # 存储网格价格
            self.positions = {}          # 记录所有网格的持仓 (包含普通网格和高位网格)
            self.position_records = {}   # 记录所有网格的交易详情
            self.total_position = 0      # 总持仓跟踪
           
            self.is_initialized = False
            self.last_sync_time = None  # 最后同步时间的初始化
            self.last_trade_time = None  # 上次交易时间记录
            self.pending_orders = set()  # 跟踪待处理订单
            self.order_records = {}      # 记录本策略的所有订单信息
            
            # 记录当前周期的交易状态
            self.current_period_trades = {
                'period': '',        # 当前周期标识
                'buy_count': 0,      # 买入次数
                'sell_count': 0,     # 卖出次数
                'grids': set()       # 已操作的网格
            }
            self.last_trade_date = None  # 记录上次交易所在日期（如'2024-11-11'）
            self.daily_trade_count = 0   # 记录当日交易次数

            # 执行标准初始化流程
            print("开始执行标准初始化流程...")
            self.trigger_symbols()
            self.custom_indicator()
            self.global_variables()
            print("标准初始化完成")
            
            # 检查是否有未处理的持仓
            actual_position = self._get_position_qty(self.stock)
            if actual_position > 0:
                print(f"检测到已有持仓{actual_position}股，尝试恢复持仓状态")
                if self._recover_positions():
                    print("持仓状态恢复成功，继续执行策略")
                else:
                    print("持仓状态恢复失败，停止策略")
                    return

            print("策略初始化完成")
            self.is_initialized = True
            
        except Exception as e:
            print(f"策略初始化发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())

    def trigger_symbols(self):
        """定义交易标的"""
        try:
            self.stock = declare_trig_symbol()
            print("交易标的设置完成")
        except Exception as e:
            print(f"设置交易标的时发生错误: {str(e)}")

    def custom_indicator(self):
        """设置技术指标"""
        try:
            self.register_indicator(
                indicator_name='MA',
                script='MA5:MA(CLOSE,5),COLORFF8D1E;',
                param_list=[]
            )
            print("技术指标设置完成")
        except Exception as e:
            print(f"设置技术指标时发生错误: {str(e)}")

    def global_variables(self):
        """定义全局变量"""
        try:
            # 移除 initial_capital 和 time_interval
            # 保留必要的用户配置参数
            self.max_total_position = show_variable(500, GlobalType.INT, "最大总持仓")
            self.min_order_quantity = show_variable(20, GlobalType.INT, "单次交易数量")
            self.position_limit = show_variable(80, GlobalType.INT, "单个网格持仓上限")
            self.enable_non_intraday_mode = show_variable(False, GlobalType.BOOL, "启用非日内模式(每天仅一次交易)")
            self.grid_percentage = show_variable(0.03, GlobalType.FLOAT, "网格间距/盈利标准")
            self.grid_num = show_variable(10, GlobalType.INT, "网格数量")
            self.max_capital_usage = show_variable(0.9, GlobalType.FLOAT, "最大资金使用率")
            self.max_order_timeout = show_variable(300, GlobalType.INT, "订单超时时间(秒)")
            self.use_trade_records = show_variable(True, GlobalType.BOOL, "使用成交记录恢复持仓")
            self.trade_record_days = show_variable(31, GlobalType.INT, "成交记录查询天数(1-31)")
            self.position_sync_retry = show_variable(3, GlobalType.INT, "持仓同步重试次数")
            
            print("全局变量设置完成")
                
        except Exception as e:
            print(f"设置全局变量时发生错误: {str(e)}")

    def _get_position_qty(self, symbol):
        """获取持仓数量,带标准错误处理"""
        try:
            return position_holding_qty(symbol)
        except APIException as ex:
            if ex.err_code == ErrCode.NoDataAvailable:
                print("无持仓数据")
                return 0
            else:
                print(f"获取持仓失败: {str(ex)}")
                return 0
        except Exception as e:
            print(f"获取持仓时发生未知错误: {str(e)}")
            return 0

    def _get_latest_price(self, symbol):
        """获取最新价格,带标准错误处理"""
        try:
            for _ in range(3):  # 最多重试3次
                try:
                    price = current_price(symbol)
                    if price:
                        return price
                except APIException as ex:
                    if ex.err_code == ErrCode.ExceedReqLimit:
                        print("请求过于频繁，等待重试")
                    elif ex.err_code == ErrCode.ReqTimeout:
                        print("获取价格超时，等待重试")
                    else:
                        print(f"获取价格失败: {str(ex)}")
                    time.sleep(0.1)
                    continue
                    
            print("获取价格重试次数达到上限")
            return None
                
        except Exception as e:
            print(f"获取价格时发生未知错误: {str(e)}")
            return None

    def handle_data(self):
        """主要策略逻辑"""
        try:
            # 获取当前时间和价格
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            latest_price = self._get_latest_price(self.stock)
            if not latest_price:
                return
                    
            print(f"\n当前时间: {current_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"当前价格: {latest_price:.1f}")
            
            # 定期同步持仓状态
            if not self.last_sync_time or (current_time - self.last_sync_time).total_seconds() > 300:  # 5分钟同步一次
                if self._sync_positions():
                    self.last_sync_time = current_time
                
            # 检查是否新周期
            if not self._is_new_period(current_time):
                print(f"当前周期已执行交易, 等待下一周期")
                return
                
            # 检查网格状态和交易机会
            if not self.is_initialized or self._should_reset_grid(latest_price):
                self._initialize_grids(latest_price)
                return
                
            # 检查是否有交易机会
            if self._check_trading_opportunity(latest_price):
                self.current_period_trades['last_update'] = current_time
                
        except Exception as e:
            print(f"策略运行时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())

    def _check_trading_opportunity(self, current_price):
        """统一检查交易机会"""
        try:
            # 获取实时卖出价格，增加重试机制
            sell_price = None
            for _ in range(3):  # 最多重试3次
                sell_price = bid(self.stock, level=1)
                if sell_price:
                    break
                time.sleep(0.1)
            sell_price = sell_price or current_price
                    
            # 先检查是否有盈利机会（按盈利比例排序）
            profitable_grids = []
            for grid_price, pos in sorted(self.positions.items()):
                if pos <= 0:
                    continue
                        
                record = self.position_records[grid_price]
                buy_price = record['buy_price']
                # 使用实时买价计算盈利
                price_diff = (sell_price - buy_price) / buy_price
                
                # 根据盈利比例动态调整
                min_profit = max(self.grid_percentage, 0.02)  # 最小2%
                if price_diff >= min_profit:
                    profit_amount = (sell_price - buy_price) * pos
                    profitable_grids.append({
                        'grid_price': grid_price,
                        'quantity': pos,
                        'buy_price': buy_price,
                        'profit_pct': price_diff,
                        'profit_amount': profit_amount
                    })
            
            # 按盈利金额排序
            profitable_grids.sort(key=lambda x: x['profit_amount'], reverse=True)
            
            if profitable_grids:
                print("\n发现盈利机会:")
                for grid in profitable_grids:
                    print(f"网格 {grid['grid_price']:.1f}: "
                        f"持仓={grid['quantity']} "
                        f"成本={grid['buy_price']:.2f} "
                        f"盈利={grid['profit_pct']:.1%} "
                        f"({grid['profit_amount']:.2f})")
                
                # 执行批量卖出前再次验证持仓
                if not self._verify_positions():
                    print("持仓验证失败，取消卖出")
                    return False
                    
                # 执行批量卖出
                did_sell = False
                if self._can_trade_in_period(is_buy=False):
                    sell_grids = [(g['grid_price'], g['quantity'], g['buy_price']) 
                                for g in profitable_grids]
                    did_sell = self._execute_batch_sell(sell_grids, current_price)
                    if did_sell:
                        # 如果启用了非日内模式，并且今天已经有过交易，则不再进行开仓操作
                        if self.enable_non_intraday_mode and self._has_traded_today():
                            print("非日内模式已启用，今天已完成盈利平仓交易，不再当日开仓。")
                            return True  # 返回True表示已处理卖出，不再执行后续买入逻辑
                        
                        # 卖出成功后尝试一次买入
                        if self._can_trade_in_period(is_buy=True) and self.total_position < self.max_total_position:
                            potential_grids = self._find_buy_opportunities(current_price)
                            if potential_grids:  # 只尝试第一个合适的网格
                                grid_price = potential_grids[0]
                                if self._should_execute_trade(grid_price, current_price):
                                    print(f"\n尝试在网格 {grid_price:.1f} 开启新仓位")
                                    if self._place_buy_order(grid_price, current_price):
                                        print(f"网格 {grid_price:.1f} 开仓成功")
                                        self._print_grid_status(show_all=False)
                                        return True
                
                return did_sell
                    
            # 如果没有盈利机会，检查是否可以开新仓位
            elif self._can_trade_in_period(is_buy=True) and self.total_position < self.max_total_position:
                potential_grids = self._find_buy_opportunities(current_price)
                if potential_grids:  # 同样只尝试第一个合适的网格
                    grid_price = potential_grids[0]
                    if self._should_execute_trade(grid_price, current_price):
                        print(f"\n尝试在网格 {grid_price:.1f} 开启新仓位")
                        if self._place_buy_order(grid_price, current_price):
                            print(f"网格 {grid_price:.1f} 开仓成功")
                            self._print_grid_status(show_all=False)
                            return True
                            
            return False
                    
        except Exception as e:
            print(f"检查交易机会时发生错误: {str(e)}")
            return False
            
    def _can_trade_in_period(self, is_buy=True):
        """检查是否可以在当前周期交易"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            current_period = current_time.strftime('%Y%m%d_%H%M')
            
            # 检查是否为新周期
            if current_period != self.current_period_trades['period']:
                return True
                
            # 检查距离上次更新是否已经超过一定时间（例如30秒）
            if 'last_update' in self.current_period_trades:
                elapsed = (current_time - self.current_period_trades['last_update']).total_seconds()
                if elapsed > 30:  # 如果超过30秒，允许新的交易
                    return True
                    
            # 检查交易次数限制
            if is_buy:
                max_trades = 2  # 每周期最多买入2次
                return self.current_period_trades['buy_count'] < max_trades
            else:
                max_trades = 2  # 每周期最多卖出2次
                return self.current_period_trades['sell_count'] < max_trades
                
        except Exception as e:
            print(f"检查交易周期失败: {str(e)}")
            return False

    def _is_new_period(self, current_time):
        """判断是否是新的交易周期"""
        current_period = current_time.strftime('%Y%m%d_%H%M')
        if current_period != self.current_period_trades['period']:
            self.current_period_trades = {
                'period': current_period,
                'buy_count': 0,
                'sell_count': 0,
                'grids': set()
            }
            return True
        return False

    def _update_period_trade_status(self, is_buy=True):
        """更新周期交易状态"""
        try:
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            current_period = current_time.strftime('%Y%m%d_%H%M')
            
            # 如果是新周期，重置状态
            if current_period != self.current_period_trades['period']:
                self.current_period_trades = {
                    'period': current_period,
                    'buy_count': 0,
                    'sell_count': 0,
                    'grids': set(),
                    'last_update': current_time
                }
            
            # 更新交易计数
            if is_buy:
                self.current_period_trades['buy_count'] += 1
            else:
                self.current_period_trades['sell_count'] += 1
                
            self.current_period_trades['last_update'] = current_time
            
            # 打印当前周期状态
            print(f"当前周期{current_period}状态: 买入次数={self.current_period_trades['buy_count']}, "
                f"卖出次数={self.current_period_trades['sell_count']}")
                
        except Exception as e:
            print(f"更新周期状态失败: {str(e)}")

    def _execute_batch_sell(self, profitable_grids, current_price):
        """执行批量卖出操作, 使用exec_info或fallback信息更新持仓"""
        try:
            if not profitable_grids:
                return False

            # 同步持仓状态
            if not self._sync_positions():
                print("持仓同步失败，取消卖出")
                return False

            # 验证盈利列表再次确认
            verified_grids = []
            sell_price = bid(self.stock, level=1) or current_price
            for grid_price, qty, buy_price in profitable_grids:
                if grid_price not in self.positions:
                    continue
                actual_qty = self.positions[grid_price]
                if actual_qty <= 0:
                    continue

                price_diff = (sell_price - buy_price) / buy_price
                min_profit = max(self.grid_percentage, 0.02)
                if price_diff >= min_profit:
                    qty = min(qty, actual_qty)
                    verified_grids.append((grid_price, qty, buy_price))
                else:
                    print(f"网格 {grid_price:.1f} 不再满足盈利条件，从卖出列表移除")

            if not verified_grids:
                print("没有网格满足盈利条件，取消卖出")
                return False

            total_quantity = sum(grid[1] for grid in verified_grids)
            print(f"\n执行批量卖出: 总数量={total_quantity}")
            sell_order_id = place_market(
                symbol=self.stock,
                qty=total_quantity,
                side=OrderSide.SELL,
                time_in_force=TimeInForce.DAY
            )

            if not sell_order_id:
                print("批量卖出订单创建失败")
                return False

            self.order_records[sell_order_id] = {
                'side': OrderSide.SELL,
                'grid_prices': [g[0] for g in verified_grids],
                'qty': total_quantity
            }
            self.pending_orders.add(sell_order_id)

            try:
                exec_info = self._check_order_status(sell_order_id)
                if exec_info:
                    avg_price = exec_info['avg_price']
                    total_qty = exec_info['total_qty']
                    
                    # 更新每个网格的持仓
                    for grid_price, qty, _ in profitable_grids:
                        if grid_price in self.positions:
                            actual_qty = min(qty, self.positions[grid_price])
                            self.positions[grid_price] -= actual_qty
                            self.total_position -= actual_qty
                            
                            # 更新持仓记录
                            if self.positions[grid_price] == 0:
                                del self.positions[grid_price]
                                del self.position_records[grid_price]
                            else:
                                self.position_records[grid_price]['quantity'] = self.positions[grid_price]

                    # 验证并记录更新
                    if self._verify_positions():
                        print("批量卖出成功")
                        self._update_period_trade_status(is_buy=False)
                        if self.enable_non_intraday_mode:
                            self._mark_traded_today()
                        return True
                else:
                    print("无法获取成交信息(包括fallback)，放弃该次交易数据更新")
                    return False

            finally:
                self.pending_orders.discard(sell_order_id)

        except Exception as e:
            print(f"执行批量卖出时发生错误: {str(e)}")
            return False

    def _place_buy_order(self, grid_price, current_price):
        """执行买入订单，使用exec_info或fallback信息更新持仓"""
        try:
            # 同步持仓状态
            if not self._sync_positions():
                print("持仓同步失败，取消买入")
                return False

            current_pos = self.positions.get(grid_price, 0)
            available_position = self.max_total_position - self.total_position
            order_quantity = min(
                self.min_order_quantity,
                self.position_limit - current_pos,
                available_position
            )

            if order_quantity <= 0:
                print(f"网格{grid_price:.1f}无法开仓: 当前持仓={current_pos}, 可用持仓={available_position}")
                return False

            ask_price = ask(self.stock, level=1) or current_price
            price_diff = abs(ask_price - grid_price) / grid_price
            if price_diff > self.grid_percentage * 0.8:
                print(f"实时价格{ask_price:.1f}已超出网格{grid_price:.1f}允许范围")
                return False

            print(f"执行买入: 网格={grid_price:.1f} 数量={order_quantity} @ {ask_price:.1f}")
            buy_order_id = place_market(
                symbol=self.stock,
                qty=order_quantity,
                side=OrderSide.BUY,
                time_in_force=TimeInForce.DAY
            )

            if not buy_order_id:
                print("买入订单创建失败")
                return False

            self.order_records[buy_order_id] = {
                'side': OrderSide.BUY,
                'grid_price': grid_price,
                'qty': order_quantity
            }
            self.pending_orders.add(buy_order_id)

            try:
                exec_info = self._check_order_status(buy_order_id)
                if exec_info:
                    # 在使用exec_info['last_time']前，先判空
                    last_time = exec_info.get('last_time')
                    if not last_time:
                        # 如果依旧拿不到真实成交时间，就用本地时间进行兜底
                        last_time = device_time(TimeZone.DEVICE_TIME_ZONE)

                    updates = [{
                        'grid_price': grid_price,
                        'qty': order_quantity,
                        'price': exec_info['avg_price'],
                        'is_buy': True,
                        'time': last_time.strftime('%Y/%m/%d %H:%M:%S')
                    }]

                    # 若成交数量也是0，这里可以再做一次判断:
                    if exec_info.get('total_qty', 0) <= 0:
                        print("警告：exec_info中成交数量为0，更新持仓可能不准确。")
                        # 也可根据需要 return False，或执行fallback

                    if self._batch_update_positions(updates):
                        self._update_period_trade_status(is_buy=True)
                        print(f"网格 {grid_price:.1f} 买入成功")
                        self._print_grid_status(show_all=False)
                        if self.enable_non_intraday_mode:
                            self._mark_traded_today()
                        return True

                    print("持仓更新失败")
                    # 强制同步
                    return self._sync_positions()

                else:
                    print("无法获取成交信息(包括fallback)，买入结果不确定，放弃此次数据更新")
                    return False

            finally:
                self.pending_orders.discard(buy_order_id)

        except Exception as e:
            print(f"执行买入订单时发生错误: {str(e)}")
            return False

    def _check_order_status(self, order_id, max_retries=120, retry_interval=0.5):
        """
        检查订单状态并获取成交详情(增加fallback逻辑 & 直接查询成交API的二次校验)
        """
        if not order_id:
            return None

        try:
            start_time = time.time()
            wait_count = 0
            last_status = None

            while True:
                try:
                    status = order_status(order_id)
                except APIException as e:
                    print(f"获取订单状态失败: {str(e)}")
                    time.sleep(retry_interval)
                    continue

                wait_count += 1
                if status != last_status:
                    print(f"订单{order_id}状态: {status}")
                    last_status = status

                # --- 如果订单已全部成交 ---
                if status == "FILLED_ALL":
                    exec_info = self._get_execution_info(order_id, self.stock)

                    # 如果拿到的 exec_info 无效或 total_qty=0，有可能是因为订单ID和成交ID暂未同步
                    if not exec_info or exec_info.get("total_qty", 0) == 0:
                        print("未能通过 order_id → execution_id 获取真实成交信息，尝试直接查询近期成交...")
                        # 在此进行二次查询(可自己写一个方法，根据下单时间到当前时间范围，再匹配方向/数量)
                        exec_info = self._get_recent_trades_by_time(order_id)

                    if exec_info:
                        avg_price = exec_info['avg_price']
                        total_qty = exec_info['total_qty']
                        print(f"成交详情: 数量={total_qty} @ {avg_price:.2f}")
                        return exec_info
                    else:
                        print("无法获取成交信息(包括fallback)，放弃该次交易数据更新")
                        return None

                if status in ["CANCELLED_ALL", "FAILED", "DISABLED", "DELETED"]:
                    print(f"订单{order_id}已{status}")
                    return None

                # 等待超时和重试上限处理
                elapsed_time = time.time() - start_time
                if elapsed_time >= self.max_order_timeout:
                    print(f"订单{order_id}等待超时({elapsed_time:.1f}秒), 使用fallback处理")
                    exec_info = self._fallback_exec_info(order_id)
                    return exec_info

                if wait_count >= max_retries:
                    print(f"订单{order_id}等待次数达到上限, 使用fallback处理")
                    exec_info = self._fallback_exec_info(order_id)
                    return exec_info

                time.sleep(retry_interval)

        except Exception as e:
            print(f"检查订单状态出错: {str(e)}")
            # 出现异常时也使用fallback
            exec_info = self._fallback_exec_info(order_id)
            return exec_info

    def _get_recent_trades_by_time(self, order_id):
        """
        尝试基于时间范围/交易方向/数量等信息，去 request_executionid(...) 查找最新成交，
        并与当前订单相匹配(仅作简易示例).
        """
        try:
            # 假设记录了订单创建时间
            order_create_time1 = time.time() - 60  # 示例：假设订单是1分钟前下的
            start_str = datetime.datetime.fromtimestamp(order_create_time1).strftime('%Y-%m-%d %H:%M:%S')
            end_str   = device_time(TimeZone.DEVICE_TIME_ZONE).strftime('%Y-%m-%d %H:%M:%S')

            # 获取这段时间内的所有成交ID
            execution_ids = request_executionid(symbol=self.stock, start=start_str, end=end_str)
            if not execution_ids:
                return None

            # 遍历每个成交ID, 看看是否跟order_id信息(或方向/数量等)能对应上
            # 这里可以根据 self.order_records[order_id]['qty'] / side / grid_price 做一定匹配.
            total_qty = 0
            total_value = 0
            last_time = None

            for eid in execution_ids:
                status = execution_status(eid)
                if status != "OK":
                    continue
                qty = execution_qty(eid)
                price = execution_price(eid)
                exec_time = execution_time(eid, time_zone=TimeZone.MARKET_TIME_ZONE)
                # 简单判断：只要在此时间范围内是BUY，就暂且认为是我们的成交(仅示例，实际要更严谨)
                if self.order_records.get(order_id, {}).get('side') == OrderSide.BUY:
                    total_qty += qty
                    total_value += price * qty
                    if not last_time or exec_time > last_time:
                        last_time = exec_time

            if total_qty == 0:
                return None

            avg_price = total_value / total_qty
            return {
                "avg_price": avg_price,
                "total_qty": total_qty,
                "last_time": last_time,
            }

        except Exception as e:
            print(f"_get_recent_trades_by_time 出错: {str(e)}")
            return None

    def _get_execution_info(self, order_id, symbol):
        """
        尝试根据 order_id 获取成交详情(若 execution_orderid 映射不到, 返回 None 或空数据).
        如果执行成功则返回 { avg_price, total_qty, last_time }，否则返回None或带有None时间的dict
        """
        try:
            # Step 1: 获取可能存在的execution_ids
            execution_ids = request_executionid(symbol=symbol)
            if not execution_ids:
                # 如果这里返回空列表, 说明根本拿不到任何成交ID
                print(f"[_get_execution_info] 无法获取任何成交ID: order_id={order_id}")
                return None

            # Step 2: 根据execution_id找对应的订单ID
            valid_executions = []
            for eid in execution_ids:
                try:
                    # 有些环境下 execution_orderid(eid) 可能抛异常, 所以用try
                    oid = execution_orderid(eid)
                    if oid == order_id:
                        valid_executions.append(eid)
                except Exception as ex:
                    print(f"执行execution_orderid({eid})时出现异常: {str(ex)}")
                    continue

            if not valid_executions:
                # 没有任何execution_id匹配此order_id
                print(f"[_get_execution_info] 未查到任何execution_id符合order_id={order_id}")
                return {
                    "avg_price": 0,
                    "total_qty": 0,
                    "last_time": None,
                }

            # Step 3: 汇总执行详情
            total_qty = 0
            total_value = 0
            last_time = None

            for eid in valid_executions:
                qty = execution_qty(eid)
                price = execution_price(eid)
                exec_time = execution_time(eid, time_zone=TimeZone.MARKET_TIME_ZONE)

                total_qty += qty
                total_value += price * qty
                if not last_time or exec_time > last_time:
                    last_time = exec_time

            if total_qty <= 0:
                print(f"[_get_execution_info] 订单{order_id}下的成交总数量=0")
                return {
                    "avg_price": 0,
                    "total_qty": 0,
                    "last_time": None,
                }

            avg_price = total_value / total_qty if total_qty > 0 else 0
            return {
                "avg_price": avg_price,
                "total_qty": total_qty,
                "last_time": last_time,
            }

        except Exception as e:
            print(f"Error in _get_execution_info: {str(e)}")
            return {
                "avg_price": 0,
                "total_qty": 0,
                "last_time": None,
            }

    def _fallback_exec_info(self, order_id):
        """无法获取实际成交详情时的fallback逻辑。
        使用下单记录或当前价格作为参考，返回一个模拟的exec_info。"""
        record = self.order_records.get(order_id, {})
        fallback_qty = record.get('qty', 0)

        if fallback_qty <= 0:
            print("fallback失败: 无法从订单记录获取有效数量信息")
            return None

        current_p = self._get_latest_price(self.stock)
        if not current_p:
            current_p = 1.0

        fallback_time = device_time(TimeZone.DEVICE_TIME_ZONE)
        exec_info = {
            'order_id': order_id,
            'avg_price': current_p,
            'total_qty': fallback_qty,
            'last_time': fallback_time
        }
        print(f"使用fallback信息更新订单{order_id}: 数量={fallback_qty}, 价格={current_p}")
        return exec_info

    def _batch_update_positions(self, updates):
        """批量更新持仓信息"""
        try:
            # 记录更新前的状态
            old_positions = self.positions.copy()
            old_records = {k: v.copy() for k, v in self.position_records.items()}
            old_total = self.total_position
            
            # 预检查更新是否会导致超限
            for update in updates:
                grid_price = update['grid_price']
                qty = update['qty']
                is_buy = update['is_buy']
                
                current_pos = self.positions.get(grid_price, 0)
                if is_buy:
                    new_qty = current_pos + qty
                    if new_qty > self.position_limit:
                        print(f"更新将导致网格{grid_price}超出限制:{new_qty}>{self.position_limit}")
                        return False
                        
            # 执行所有更新
            for update in updates:
                try:
                    grid_price = update['grid_price']
                    qty = update['qty']
                    price = update['price']
                    is_buy = update['is_buy']
                    
                    if is_buy:
                        # 买入更新
                        current_pos = self.positions.get(grid_price, 0)
                        current_cost = self.position_records.get(grid_price, {}).get('buy_price', 0)
                        new_qty = current_pos + qty
                        
                        # 计算加权平均成本(保持1位小数)
                        if current_pos > 0:
                            total_value = current_pos * current_cost + qty * price
                            new_cost = int(total_value / new_qty * 10) / 10
                        else:
                            new_cost = int(price * 10) / 10
                        
                        self.positions[grid_price] = new_qty
                        self.position_records[grid_price] = {
                            'buy_price': new_cost,
                            'quantity': new_qty,
                            'update_time': time.time()
                        }
                    else:
                        # 卖出更新
                        if grid_price in self.positions:
                            current_pos = self.positions[grid_price]
                            if current_pos <= qty:
                                del self.positions[grid_price]
                                self.position_records[grid_price] = {
                                    'buy_price': 0,
                                    'quantity': 0,
                                    'update_time': time.time()
                                }
                            else:
                                new_qty = current_pos - qty
                                self.positions[grid_price] = new_qty
                                self.position_records[grid_price].update({
                                    'quantity': new_qty,
                                    'update_time': time.time()
                                })
                    
                    # 更新总持仓
                    self.total_position = sum(qty for qty in self.positions.values() if qty > 0)
                    
                    # 每次更新后立即验证
                    if not self._verify_positions():
                        raise Exception(f"网格{grid_price}更新后验证失败")
                        
                except Exception as e:
                    if str(e):  # 只在有实际错误信息时打印
                        print(f"更新失败: {str(e)}")
                    self.positions = old_positions
                    self.position_records = old_records
                    self.total_position = old_total
                    return False
                    
            print(f"批量更新持仓成功 - 总持仓:{self.total_position}")
            self._print_grid_status(show_all=False)
            return True
                
        except Exception as e:
            if str(e):  # 只在有实际错误信息时打印
                print(f"批量更新持仓失败: {str(e)}")
            return False

    def _initialize_grids(self, base_price):
        """初始化或重置网格"""
        try:
            print(f"\n初始化网格 - 基准价格: {base_price}")

            if not base_price or base_price <= 0:
                print("无效的基准价格")
                return False

            # 同步当前持仓状态
            if not self._sync_positions():
                print("持仓同步失败")
                return False

            actual_position = self.total_position

            # 如果有持仓，先检查是否有盈利机会
            if actual_position > 0:
                print("检查重置前的盈利机会")
                if self._check_profit_before_reset(base_price):
                    print("完成盈利了结，继续重置网格")
                    # 再次同步状态
                    if not self._sync_positions():
                        print("持仓同步失败")
                        return False
                    actual_position = self.total_position

            # 生成新网格价格，使用更紧凑的间距
            grid_spacing = base_price * (self.grid_percentage * 0.8)  # 缩小网格间距
            half_grids = self.grid_num // 2
            new_grid_prices = []
            base_grid = int(base_price * 10) / 10

            # 优先生成接近基准价格的网格
            new_grid_prices.append(base_grid)
            for i in range(1, half_grids + 1):
                up_price = int((base_grid + i * grid_spacing) * 10) / 10
                down_price = int((base_grid - i * grid_spacing) * 10) / 10
                # 先添加更接近基准价格的网格
                if abs(up_price - base_price) < abs(down_price - base_price):
                    new_grid_prices.append(up_price)
                    new_grid_prices.append(down_price)
                else:
                    new_grid_prices.append(down_price)
                    new_grid_prices.append(up_price)

            new_grid_prices.sort()

            # 如果有持仓，执行网格迁移
            if actual_position > 0:
                if not self._migrate_positions(actual_position, new_grid_prices, base_price):
                    print("持仓迁移失败")
                    return False
            else:
                # 初始化空网格
                self.grid_prices = new_grid_prices
                self.positions = {}
                self.position_records = {
                    price: {
                        'buy_price': 0,
                        'quantity': 0,
                        'update_time': time.time()
                    }
                    for price in new_grid_prices
                }
                self.total_position = 0

            print("\n网格初始化完成")
            self._print_grid_status(show_all=True)

            # 如果启用非日内模式并且今天已经有过交易，则不进行盈利后的立即建仓
            if self.enable_non_intraday_mode and self._has_traded_today():
                print("非日内模式已启用，今天已进行交易，不再进行立即建仓")
                return True

            # 立即寻找建仓机会（仅一次）
            if actual_position < self.max_total_position:
                buy_opportunities = self._find_buy_opportunities(base_price)
                if buy_opportunities:
                    grid_price = buy_opportunities[0]
                    if self._can_trade_in_period(is_buy=True):
                        print(f"网格重置后尝试建仓: {grid_price:.1f}")
                        if self._place_buy_order(grid_price, base_price):
                            print(f"首次建仓成功: 网格={grid_price:.1f}")
                            # 成功后同步状态
                            self._sync_positions()

            return True

        except Exception as e:
            print(f"初始化网格时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return False

    def _verify_positions(self):
        """验证持仓数据一致性"""
        try:
            actual_position = self._get_position_qty(self.stock)
            calculated_position = sum(qty for qty in self.positions.values() if qty > 0)
            
            print(f"\n持仓验证:")
            print(f"计算持仓: {calculated_position}股")
            print(f"实际持仓: {actual_position}股")
            
            # 检查总持仓匹配
            if abs(calculated_position - actual_position) > 0.01:
                print(f"持仓不一致 - 实际:{actual_position} != 记录:{calculated_position}")
                return False
                
            # 数据完整性检查
            grid_positions = set(k for k, v in self.positions.items() if v > 0)
            record_positions = set(k for k, v in self.position_records.items() 
                                if v.get('quantity', 0) > 0)
            
            if grid_positions != record_positions:
                print("持仓记录不完整")
                print(f"网格记录: {grid_positions}")
                print(f"详细记录: {record_positions}")
                return False
                
            # 验证各个网格的数据
            for grid_price in grid_positions:
                qty = self.positions[grid_price]
                record = self.position_records.get(grid_price)
                
                if not record:
                    print(f"网格{grid_price}缺少详细记录")
                    return False
                    
                if abs(record['quantity'] - qty) > 0.01:
                    print(f"网格{grid_price}数量不匹配: {record['quantity']} != {qty}")
                    return False
                    
                if record['buy_price'] <= 0:
                    print(f"网格{grid_price}成本价无效: {record['buy_price']}")
                    return False
                    
                if qty > self.position_limit:
                    print(f"网格{grid_price}超出限制: {qty} > {self.position_limit}")
                    return False
                    
            # 验证总持仓限制
            if calculated_position > self.max_total_position:
                print(f"总持仓超出限制: {calculated_position} > {self.max_total_position}")
                return False
                
            self.total_position = calculated_position
            return True
                
        except Exception as e:
            print(f"验证持仓失败: {str(e)}")
            return False

    def _print_grid_status(self, show_all=True):
        """打印网格状态"""
        try:
            print("\n=== 网格状态 ===")
            latest_price = self._get_latest_price(self.stock)
            printed_grids = set()  # 记录已打印的网格
            
            if show_all:
                # 显示所有网格
                all_grids = sorted(set(self.grid_prices + list(self.positions.keys())))
                for grid in all_grids:
                    if grid in printed_grids:
                        continue
                    printed_grids.add(grid)
                    
                    pos = self.positions.get(grid, 0)
                    record = self.position_records.get(grid, {})
                    status = f"网格 {grid:.1f}: 持仓={pos}"
                    
                    if pos > 0:
                        buy_price = record.get('buy_price', 0)
                        status += f", 成本={buy_price:.1f}"
                        if latest_price:
                            profit = (latest_price - buy_price) * pos
                            profit_pct = (latest_price - buy_price) / buy_price * 100
                            status += f", 盈亏={profit:.2f}({profit_pct:.1f}%)"
                    print(status)
            else:
                # 只显示有持仓的网格
                for grid, pos in sorted(self.positions.items()):
                    if grid in printed_grids or pos <= 0:
                        continue
                    printed_grids.add(grid)
                    
                    record = self.position_records[grid]
                    buy_price = record['buy_price']
                    status = f"网格 {grid:.1f}: 持仓={pos}, 成本={buy_price:.1f}"
                    if latest_price:
                        profit = (latest_price - buy_price) * pos
                        profit_pct = (latest_price - buy_price) / buy_price * 100
                        status += f", 盈亏={profit:.2f}({profit_pct:.1f}%)"
                    print(status)
                
            if latest_price:  # 删除 and self.total_position > 0 的条件
                total_value = latest_price * self.total_position
                print(f"\n总持仓: {self.total_position}, 总市值: {total_value:.2f}")
            else:
                print(f"\n总持仓: {self.total_position}")  # 确保始终显示总持仓
                    
        except Exception as e:
            print(f"打印网格状态时发生错误: {str(e)}")

    def _migrate_positions(self, actual_position, new_grid_prices, current_price):
        """迁移持仓到新网格"""
        try:
            print("\n开始迁移持仓到新网格...")
            # 先尝试从成交记录恢复
            if self.use_trade_records:
                positions_from_trades = self._get_positions_from_trades()
                if positions_from_trades:
                    print("从成交记录恢复持仓分布")
                    self.positions = positions_from_trades['positions']
                    self.position_records = positions_from_trades['records']
                    self.total_position = positions_from_trades['total']
                    self.grid_prices = new_grid_prices
                    
                    # 验证持仓状态
                    if self._verify_positions():
                        print("持仓恢复验证成功")
                        return True
                    print("持仓恢复验证失败,尝试网格迁移")
            
            # 使用网格迁移
            print("执行网格迁移")
            
            # 保存当前状态用于回滚
            old_positions = self.positions.copy()
            old_records = {k: v.copy() for k, v in self.position_records.items()}
            old_total = self.total_position
            
            # 初始化新状态
            new_positions = {}
            new_records = {}
            
            # 计算最高价网格
            highest_grid = new_grid_prices[0]
            for price in new_grid_prices[1:]:
                if price > highest_grid:
                    highest_grid = price
            print(f"新网格最高价格: {highest_grid:.1f}")
            
            # 处理现有持仓
            for grid_price, qty in old_positions.items():
                if qty <= 0:
                    continue
                    
                record = old_records[grid_price]
                buy_price = record['buy_price']
                
                # 保留高位网格
                if grid_price > highest_grid:
                    print(f"保留高位网格 {grid_price:.1f} 的持仓 {qty}股")
                    new_positions[grid_price] = qty
                    new_records[grid_price] = record.copy()
                    continue
                    
                # 合并到新网格
                new_grid = self._find_nearest_grid_price(grid_price, new_grid_prices)
                if new_grid in new_positions:
                    old_qty = new_positions[new_grid]
                    old_cost = new_records[new_grid]['buy_price']
                    total_qty = old_qty + qty
                    
                    if total_qty <= self.position_limit:
                        new_positions[new_grid] = total_qty
                        total_value = old_qty * old_cost + qty * buy_price
                        weighted_cost = int(total_value / total_qty * 10) / 10
                        new_records[new_grid] = {
                            'buy_price': weighted_cost,
                            'quantity': total_qty,
                            'update_time': time.time()
                        }
                        print(f"合并至网格 {new_grid:.1f}: +{qty}股 => {total_qty}股")
                    else:
                        print(f"网格 {new_grid:.1f} 将超出限制，保持原网格")
                        new_positions[grid_price] = qty
                        new_records[grid_price] = record.copy()
                else:
                    new_positions[new_grid] = qty
                    new_records[new_grid] = {
                        'buy_price': buy_price,
                        'quantity': qty,
                        'update_time': time.time()
                    }
                    print(f"迁移至网格 {new_grid:.1f}: {qty}股")
                    
            # 更新状态
            self.grid_prices = new_grid_prices
            self.positions = new_positions
            self.position_records = new_records
            self.total_position = sum(qty for qty in self.positions.values() if qty > 0)
            
            # 验证迁移结果
            if self._verify_positions():
                print("网格迁移成功")
                return True
                
            # 验证失败时回滚
            print("网格迁移验证失败，回滚并尝试强制同步")
            self.positions = old_positions
            self.position_records = old_records
            self.total_position = old_total
            
            retry_count = 0
            while retry_count < self.position_sync_retry:
                print(f"尝试强制同步 ({retry_count + 1}/{self.position_sync_retry})")
                if self._sync_positions(force_mode=True):
                    print("强制同步成功")
                    # 使用同步后的状态初始化新网格
                    self.grid_prices = new_grid_prices
                    return True
                
                retry_count += 1
                if retry_count < self.position_sync_retry:
                    print("强制同步失败，等待重试...")
                    time.sleep(0.5)  # 添加短暂延迟
                    
            print("同步重试次数达到上限")
            return False
                
        except Exception as e:
            if str(e):  # 只在有实际错误信息时打印
                print(f"网格迁移失败: {str(e)}")
            return False

    def _find_nearest_grid_price(self, target_price, grid_prices):
        """在给定的价格列表中找到最接近的网格价格"""
        try:
            if not grid_prices:
                return None
                
            target_price = int(target_price * 10) / 10  # 保持1位小数
            
            nearest_price = grid_prices[0]
            min_distance = abs(target_price - nearest_price)
            
            for price in grid_prices[1:]:
                distance = abs(target_price - price)
                if distance < min_distance:
                    min_distance = distance
                    nearest_price = price
                    
            return nearest_price
            
        except Exception as e:
            print(f"查找最近网格价格失败: {str(e)}")
            return None

    def _find_buy_opportunities(self, latest_price):
        """寻找合适的买入机会"""
        try:
            potential_grids = []
            
            # 根据当前价格查找附近的网格
            for grid_price in sorted(self.grid_prices):
                # 检查价格偏差
                price_diff = abs(latest_price - grid_price) / grid_price
                max_deviation = self.grid_percentage * 0.75  # 允许更大的价格偏差
                
                if price_diff <= max_deviation:
                    current_pos = self.positions.get(grid_price, 0)
                    # 检查是否有空间建仓
                    if current_pos < self.position_limit:
                        potential_grids.append(grid_price)
                        
            return potential_grids
                
        except Exception as e:
            print(f"查找买入机会时发生错误: {str(e)}")
            return []

    def _find_nearest_grid(self, target_price):
        """在当前网格中找到最接近的价格"""
        return self._find_nearest_grid_price(target_price, self.grid_prices)

    def _should_reset_grid(self, latest_price):
        """判断是否需要重置网格"""
        try:
            if not self.grid_prices:
                return True
                    
            closest_grid = self._find_nearest_grid(latest_price)
            if not closest_grid:
                return True
                
            deviation = abs(latest_price - closest_grid) / closest_grid
            return deviation > self.grid_percentage
                
        except Exception as e:
            print(f"检查网格重置时发生错误: {str(e)}")
            return False

    def _recover_positions(self):
        """恢复已有持仓状态"""
        try:
            # 基础验证
            required_params = ['grid_percentage', 'grid_num', 'position_limit']
            for param in required_params:
                if not hasattr(self, param):
                    print(f"错误：参数 {param} 未初始化")
                    return False

            # 同步当前持仓状态
            if not self._sync_positions():
                print("持仓同步失败")
                return False
                
            actual_position = self.total_position
            if actual_position == 0:
                return True

            latest_price = self._get_latest_price(self.stock)
            if not latest_price:
                print("无法获取当前价格，恢复失败")
                return False

            print(f"当前持仓: {actual_position}股")
            
            # 从成交记录恢复持仓分布已由_sync_positions完成
            # 直接使用同步后的状态初始化网格
            
            # 初始化网格价格
            grid_spacing = latest_price * self.grid_percentage
            base_grid = int(latest_price * 10) / 10
            half_grids = self.grid_num // 2
            
            # 生成网格价格
            self.grid_prices = []
            for i in range(half_grids + 1):
                if i == 0:
                    self.grid_prices.append(base_grid)
                else:
                    up_price = int((base_grid + i * grid_spacing) * 10) / 10
                    down_price = int((base_grid - i * grid_spacing) * 10) / 10
                    self.grid_prices.extend([up_price, down_price])
            self.grid_prices.sort()
            
            print("\n恢复后的网格状态:")
            self._print_grid_status(show_all=True)
            
            # 验证恢复结果
            if not self._verify_positions():
                print("持仓验证失败")
                return False
                
            print("持仓恢复成功")
            return True
                
        except Exception as e:
            print(f"恢复持仓状态时发生错误: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return False

    def _check_profit_before_reset(self, current_price):
        """重置网格前检查盈利机会"""
        try:
            print("检查重置前的盈利机会")
            
            # 同步当前持仓状态
            if not self._sync_positions():
                print("持仓同步失败")
                return False
                
            # 获取实时卖出价格
            sell_price = bid(self.stock, level=1) or current_price
            
            # 检查所有持仓的盈利情况
            profitable_grids = []
            
            for grid_price, qty in sorted(self.positions.items()):
                if qty <= 0:
                    continue
                    
                record = self.position_records[grid_price]
                buy_price = record['buy_price']
                price_diff = (sell_price - buy_price) / buy_price
                
                if price_diff >= self.grid_percentage:
                    print(f"发现盈利机会: 网格={grid_price:.1f} 持仓={qty} 成本={buy_price:.1f} 盈利={price_diff:.1%}")
                    profitable_grids.append((grid_price, qty, buy_price))
            
            # 执行批量卖出
            if profitable_grids:
                # 不检查周期限制，因为这是网格重置前的强制检查
                if self._execute_batch_sell(profitable_grids, current_price):
                    print("完成盈利了结")
                    return True
                    
            return False
                
        except Exception as e:
            print(f"检查重置前盈利失败: {str(e)}")
            return False

    def _get_positions_from_trades(self):
        """从历史成交记录中恢复持仓"""
        try:
            actual_position = self._get_position_qty(self.stock)
            if actual_position == 0:
                return None
                
            print("开始从成交记录恢复持仓分布")
            print(f"当前实际持仓: {actual_position}股")
            
            # 获取成交记录
            execution_ids = request_executionid(symbol=self.stock)
            if not execution_ids:
                print("无法获取成交记录")
                return None
                
            # 按时间顺序处理成交记录
            trades = []
            for eid in execution_ids:
                if execution_status(eid) != "OK":
                    continue
                    
                trades.append({
                    'price': execution_price(eid),
                    'quantity': execution_qty(eid),
                    'side': execution_side(eid),
                    'time': execution_time(eid)
                })
                
            trades.sort(key=lambda x: x['time'])
            
            # 计算持仓分布
            positions = {}
            records = {}
            total_position = 0
            
            print("\n处理成交记录...")
            for trade in trades:
                price = int(trade['price'] * 10) / 10  # 保持1位小数
                qty = trade['quantity']
                
                if trade['side'] == OrderSide.BUY:
                    if price not in positions:
                        positions[price] = 0
                        records[price] = {
                            'buy_price': price,
                            'quantity': 0,
                            'update_time': time.time()
                        }
                    positions[price] += qty
                    records[price]['quantity'] = positions[price]
                    total_position += qty
                    print(f"买入: {qty}股 @ {price:.1f}")
                else:  # SELL
                    remaining_qty = qty
                    # 从最高价的持仓开始减少
                    for p in sorted(positions.keys(), reverse=True):
                        if remaining_qty <= 0:
                            break
                        if positions[p] > 0:
                            deduct = min(positions[p], remaining_qty)
                            positions[p] -= deduct
                            records[p]['quantity'] = positions[p]
                            remaining_qty -= deduct
                            total_position -= deduct
                            print(f"卖出: 从价格{p:.1f}扣减{deduct}股")
                            if positions[p] == 0:
                                del positions[p]
                                del records[p]
                                
            # 清理空持仓
            for price in list(positions.keys()):
                if positions[price] <= 0:
                    del positions[price]
                    del records[price]
                    
            # 验证计算结果
            calculated_position = sum(positions.values())
            print(f"\n计算持仓: {calculated_position}股")
            print(f"实际持仓: {actual_position}股")
            
            if abs(calculated_position - actual_position) > 0.01:
                print("持仓计算不一致")
                return None
                
            print("\n持仓分布:")
            for price, qty in sorted(positions.items()):
                cost = records[price]['buy_price']
                print(f"价格 {price:.1f}: {qty}股, 成本 {cost:.1f}")
                
            return {
                'positions': positions,
                'records': records,
                'total': calculated_position
            }
                
        except Exception as e:
            print(f"从成交记录恢复持仓失败: {str(e)}")
            return None

    def _is_price_within_grid(self, price, grid_price):
        """判断价格是否在网格允许范围内"""
        try:
            if not price or not grid_price:
                return False
                
            price_diff = abs(price - grid_price) / grid_price
            max_deviation = self.grid_percentage * 0.5  # 允许最大偏差为网格间距的一半
            return price_diff <= max_deviation
                
        except Exception as e:
            print(f"检查价格偏差失败: {str(e)}")
            return False

    def _should_execute_trade(self, grid_price, latest_price):
        """判断是否应该执行交易"""
        try:
            # 放宽价格偏差限制
            price_diff = abs(latest_price - grid_price) / grid_price
            max_deviation = self.grid_percentage * 0.8  # 允许更大的价格偏差
            
            if price_diff > max_deviation:
                print(f"当前价格{latest_price:.1f}超出网格{grid_price:.1f}允许范围")
                return False
                
            # 检查网格容量
            current_pos = self.positions.get(grid_price, 0)
            if current_pos >= self.position_limit:
                print(f"网格{grid_price:.1f}持仓{current_pos}已达上限{self.position_limit}")
                return False
                
            # 检查总持仓
            available_position = self.max_total_position - self.total_position
            if available_position < self.min_order_quantity:
                print(f"剩余可用持仓{available_position}小于最小交易数量{self.min_order_quantity}")
                return False
                
            # 获取实时买价进行二次验证
            ask_price = ask(self.stock, level=1)
            if ask_price:
                price_diff = abs(ask_price - grid_price) / grid_price
                if price_diff > max_deviation:
                    print(f"实时买价{ask_price:.1f}超出网格{grid_price:.1f}允许范围")
                    return False
                    
            return True
                
        except Exception as e:
            print(f"交易前检查失败: {str(e)}")
            return False

    def _sync_positions(self, force_mode=False):
        """
        同步持仓状态，使用 _get_recent_trades_by_time() 替代原来的 _get_recent_trades。

        Args:
            force_mode (bool): 是否使用强制同步模式
        """
        try:
            # 1. 获取实盘持仓数量
            actual_position = self._get_position_qty(self.stock)
            if actual_position == 0:
                # 如果实盘无持仓，则清空本地记录
                self.positions.clear()
                self.position_records.clear()
                self.total_position = 0
                print("检测到空仓，已清空所有持仓记录")
                return True

            print("\n同步持仓状态...")
            print(f"当前实际持仓: {actual_position}股")

            # 如果是强制模式，则直接调用内部强制同步方法
            if force_mode:
                return self._force_sync_position_internal(actual_position)

            # 2. 正常同步流程
            # 例如：获取过去 trade_record_days 天内的成交记录，默认 31 天
            now = device_time(TimeZone.DEVICE_TIME_ZONE)
            start_time_dt = now - datetime.timedelta(days=self.trade_record_days)
            start_str = start_time_dt.strftime("%Y-%m-%d %H:%M:%S")
            end_str = now.strftime("%Y-%m-%d %H:%M:%S")

            # 使用 _get_recent_trades_by_time 获取成交（不指定 order_id，查询所有）
            trades = self._get_recent_trades_by_time(
                order_id=None,
                start=start_str,
                end=end_str
            )

            if not trades:
                print("无法获取成交记录，尝试强制同步")
                return self._force_sync_position_internal(actual_position)

            # 3. 解析成交记录，构建新的持仓分布
            new_positions = {}
            new_records = {}
            total_position = 0

            for trade in trades:
                price = int(trade['price'] * 10) / 10
                qty = trade['quantity']
                is_buy = trade['is_buy']
                time_str = trade['time']

                if is_buy:
                    if price not in new_positions:
                        new_positions[price] = {
                            'quantity': 0,
                            'buy_price': price,
                            'last_update': time_str
                        }
                    pos = new_positions[price]
                    pos['quantity'] += qty
                    total_position += qty
                else:
                    remaining_qty = qty
                    # 从最高价开始逐渐扣减
                    for p in sorted(new_positions.keys(), reverse=True):
                        if remaining_qty <= 0:
                            break
                        pos = new_positions[p]
                        if pos['quantity'] > 0:
                            deduct = min(pos['quantity'], remaining_qty)
                            pos['quantity'] -= deduct
                            total_position -= deduct
                            remaining_qty -= deduct
                            pos['last_update'] = time_str

            # 4. 整理并生成 position_records
            for price, pos in list(new_positions.items()):
                if pos['quantity'] <= 0:
                    # 清理空持仓
                    del new_positions[price]
                else:
                    new_records[price] = {
                        'buy_price': pos['buy_price'],
                        'quantity': pos['quantity'],
                        'update_time': time.time()
                    }

            # 5. 验证与实盘持仓是否一致
            calculated_position = sum(p['quantity'] for p in new_positions.values())
            if abs(calculated_position - actual_position) > 0.01:
                print(f"持仓计算不一致: 计算={calculated_position}, 实际={actual_position}")
                print("尝试强制同步")
                return self._force_sync_position_internal(actual_position)

            # 6. 更新本地状态
            self.positions = {k: v['quantity'] for k, v in new_positions.items()}
            self.position_records = new_records
            self.total_position = calculated_position

            print("\n同步后的持仓分布:")
            for price, pos in sorted(new_positions.items()):
                print(f"价格 {price:.1f}: {pos['quantity']}股, 最后更新: {pos['last_update']}")

            # 可选：在这里调用一次 self._verify_positions() 做最终校验
            # if not self._verify_positions():
            #     print("同步后校验失败，可能需要人工处理。")
            #     return False

            return True

        except Exception as e:
            print(f"同步持仓状态失败: {str(e)}")
            return False

    def _force_sync_position_internal(self, actual_position):
        """内部强制同步方法"""
        try:
            print("执行强制持仓同步...")
            latest_price = self._get_latest_price(self.stock)
            if not latest_price:
                return False
                
            # 获取平均成本
            avg_cost = position_cost(self.stock, cost_price_model=CostPriceModel.AVG)
            if not avg_cost:
                avg_cost = latest_price
                
            # 保存旧状态用于回滚
            old_positions = self.positions.copy()
            old_records = self.position_records.copy()
            old_total = self.total_position
            
            # 寻找合适的网格
            target_grid = None
            cost_grid = self._find_nearest_grid(avg_cost)
            price_grid = self._find_nearest_grid(latest_price)
            
            if cost_grid and self._is_price_within_grid(avg_cost, cost_grid):
                target_grid = cost_grid
            elif price_grid and self._is_price_within_grid(latest_price, price_grid):
                target_grid = price_grid
                
            if not target_grid:
                print("无法找到合适的网格")
                return False
                
            # 更新持仓记录
            self.positions = {target_grid: actual_position}
            self.position_records = {
                target_grid: {
                    'buy_price': int(avg_cost * 10) / 10,
                    'quantity': actual_position,
                    'update_time': time.time()
                }
            }
            self.total_position = actual_position
            
            # 更新并验证
            if self._verify_positions():
                print(f"强制同步完成 - 网格:{target_grid:.1f}, 持仓:{actual_position}, 成本:{avg_cost:.1f}")
                self._print_grid_status(show_all=False)
                return True
                
            # 验证失败时回滚
            print("强制同步验证失败，执行回滚")
            self.positions = old_positions
            self.position_records = old_records
            self.total_position = old_total
            return False
                
        except Exception as e:
            if str(e):
                print(f"强制同步失败: {str(e)}")
            return False

    def _has_traded_today(self):
        current_day = device_time(TimeZone.DEVICE_TIME_ZONE).strftime('%Y-%m-%d')
        if self.last_trade_date == current_day and self.daily_trade_count > 0:
            return True
        return False

    def _mark_traded_today(self):
        current_day = device_time(TimeZone.DEVICE_TIME_ZONE).strftime('%Y-%m-%d')
        if self.last_trade_date != current_day:
            self.last_trade_date = current_day
            self.daily_trade_count = 0
        self.daily_trade_count += 1
