class Strategy(StrategyBase):
    """
    滚轮期权策略 (The Wheel Strategy)
    版本: 1.1.0
    作者: Gemini
    
    策略逻辑:
    1. 无持股时，卖出虚值看跌期权 (Sell Put)。
    2. 持股后，卖出虚值备兑看涨期权 (Sell Covered Call)。
    3. 循环往复，持续产生现金流或以较低成本持股。
    """

    def initialize(self):
        """初始化策略，仅在启动时运行一次"""
        print("🚀 开始初始化滚轮期权策略 v1.1.0...")
        self.trigger_symbols()
        self.custom_indicator() # 框架要求必须调用
        self.global_variables()
        self.state_variables()
        print("✅ 策略初始化完成")

    def trigger_symbols(self):
        """设置交易标的，策略的核心股票"""
        self.underlying_stock = declare_trig_symbol()

    def custom_indicator(self):
        """注册自定义指标（本策略中未使用，但框架要求保留）"""
        pass

    def global_variables(self):
        """定义全局变量和用户可调参数"""
        # 新增：模拟运行模式，True=只打印日志不交易, False=真实交易
        self.dry_run_mode = show_variable(True, GlobalType.BOOL)

        # 目标Delta值，决定期权的虚值程度
        self.target_delta_put = show_variable(-0.25, GlobalType.FLOAT)
        self.target_delta_call = show_variable(0.25, GlobalType.FLOAT)
        
        # 寻找期权的到期日范围（天）
        self.dte_min = show_variable(30, GlobalType.INT)
        self.dte_max = show_variable(45, GlobalType.INT)
        
        # 每次交易的合约数量
        self.contracts_to_trade = show_variable(1, GlobalType.INT)
        
        # 策略逻辑检查的时间间隔（分钟），避免过于频繁的轮询
        self.trade_interval_min = show_variable(60, GlobalType.INT)

    def state_variables(self):
        """定义策略运行中的状态变量"""
        self.last_check_time = None  # 上次检查时间，用于控制轮询频率
        self.active_option_contract = None # 当前持有的期权合约

    def handle_data(self):
        """策略主循环，按设定的周期或事件触发"""
        try:
            # --- 频率控制 ---
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            if self.last_check_time is not None:
                elapsed_minutes = (current_time - self.last_check_time).total_seconds() / 60
                if elapsed_minutes < self.trade_interval_min:
                    return # 未到检查时间，提前退出
            self.last_check_time = current_time

            print("\n🔎 [" + current_time.strftime("%Y-%m-%d %H:%M:%S") + "] 开始检查滚轮策略状态...")
            if self.dry_run_mode:
                print("   - ⚠️ 当前为模拟运行模式，不会执行真实交易。")

            # --- 获取核心状态：股票持仓 ---
            stock_qty = position_holding_qty(self.underlying_stock)
            print("   - 当前持股数量: {0}".format(stock_qty))

            # --- 状态机逻辑 ---
            # 如果股票持仓不足 (每张合约对应100股)，则进入“卖Put”逻辑
            if stock_qty < 100 * self.contracts_to_trade:
                self.handle_sell_put_logic()
            # 否则，进入“卖Call”逻辑
            else:
                self.handle_sell_call_logic()

        except Exception as e:
            print("❌ handle_data 执行错误: {0}".format(str(e)))

    def handle_sell_put_logic(self):
        """处理卖出看跌期权（Sell Put）的逻辑"""
        print("   - 状态: [卖出Put] - 当前无足够持股，准备寻找Put合约。")

        if self.check_if_has_active_short_option():
            return

        target_put = option_screener(
            underlying_symbol=self.underlying_stock,
            option_type=OptionType.PUT,
            moneyness=Moneyness.OTM,
            time_to_exp_start=self.dte_min,
            time_to_exp_end=self.dte_max
        )

        if target_put is None:
            print("   - 结果: 未找到在 {0}-{1} 天内到期的合适Put合约。".format(self.dte_min, self.dte_max))
            return

        actual_delta = option_delta(target_put)
        print("   - 找到候选Put: {0}, Delta为 {1:.4f}".format(target_put, actual_delta))
        
        if abs(actual_delta - self.target_delta_put) > 0.1:
            print("   - 结果: Delta ({0:.4f}) 与目标 ({1}) 相差过大，本轮不交易。".format(actual_delta, self.target_delta_put))
            return

        self.place_short_option_order(target_put)

    def handle_sell_call_logic(self):
        """处理卖出备兑看涨期权（Sell Covered Call）的逻辑"""
        print("   - 状态: [卖出Call] - 已持有股票，准备寻找Call合约。")

        if self.check_if_has_active_short_option():
            return

        target_call = option_screener(
            underlying_symbol=self.underlying_stock,
            option_type=OptionType.CALL,
            moneyness=Moneyness.OTM,
            time_to_exp_start=self.dte_min,
            time_to_exp_end=self.dte_max
        )

        if target_call is None:
            print("   - 结果: 未找到在 {0}-{1} 天内到期的合适Call合约。".format(self.dte_min, self.dte_max))
            return

        actual_delta = option_delta(target_call)
        print("   - 找到候选Call: {0}, Delta为 {1:.4f}".format(target_call, actual_delta))

        if abs(actual_delta - self.target_delta_call) > 0.1:
            print("   - 结果: Delta ({0:.4f}) 与目标 ({1}) 相差过大，本轮不交易。".format(actual_delta, self.target_delta_call))
            return

        self.place_short_option_order(target_call)

    def place_short_option_order(self, option_contract):
        """执行卖出期权的下单操作"""
        try:
            target_price = bid(option_contract, level=1)
            if target_price is None or target_price <= 0:
                print("   - 错误: 无法获取合约 {0} 的有效报价。".format(option_contract))
                return

            print("   - 准备下单: 卖出 {0} @ ${1}".format(option_contract, target_price))
            
            # 模拟运行模式检查
            if self.dry_run_mode:
                print("   - ⚠️ [模拟运行] 订单已模拟成交。若要实盘交易，请在参数中关闭模拟模式。")
                self.active_option_contract = option_contract # 模拟持仓，让策略逻辑继续
                return # 退出，不执行真实下单

            # 真实下单
            order_id = place_limit(
                symbol=option_contract,
                price=target_price,
                qty=self.contracts_to_trade,
                side=OrderSide.SELL,
                time_in_force=TimeInForce.DAY
            )

            if order_id:
                print("✅ [实盘] 下单成功! 合约: {0}, 数量: {1}, 价格: ${2}, 订单ID: {3}".format(
                    option_contract, self.contracts_to_trade, target_price, order_id))
                self.active_option_contract = option_contract
            else:
                print("❌ [实盘] 下单失败，未返回订单ID。")

        except Exception as e:
            print("❌ place_short_option_order 执行错误: {0}".format(str(e)))

    def check_if_has_active_short_option(self):
        """检查当前是否已经有活跃的空头期权仓位，防止重复开仓"""
        if self.active_option_contract is not None:
            try:
                option_qty = position_holding_qty(self.active_option_contract)
                if option_qty < 0:
                    print("   - 提示: 已持有活跃的空头期权仓位 ({0})，本轮跳过。".format(self.active_option_contract))
                    return True
                else:
                    self.active_option_contract = None
                    return False
            except Exception as e:
                print("   - 警告: 查询活跃期权仓位失败: {0}。为安全起见，本轮跳过。".format(e))
                return True
        return False