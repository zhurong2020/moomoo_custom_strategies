class Strategy(StrategyBase):
    """
    🎰 滚轮期权策略 (The Wheel Strategy) v2.0.0
    作者: Claude Code Enhanced
    
    策略概述:
    滚轮策略是一个系统性的期权收租策略，通过在两个状态间循环获取持续的权利金收入：
    1. 【卖PUT阶段】无持股时，卖出现金担保的虚值看跌期权获取权利金
    2. 【卖CALL阶段】持股后，卖出虚值备兑看涨期权持续获取权利金
    3. 【循环往复】根据是否持股自动切换状态，持续产生现金流
    
    v2.0.0 新特性:
    ✅ 增强的Dry Run模式 - 完整的调试和模拟功能
    ✅ 精准Delta目标 - 符合设计文档的-0.30/+0.30保守配置
    ✅ 完整资金检查 - 现金担保PUT和备兑CALL资金验证
    ✅ 智能风险控制 - 多层参数验证和异常处理
    ✅ 盈利目标管理 - 50%盈利时自动平仓锁定收益
    ✅ 详细状态监控 - 实时P&L追踪和交易统计
    ✅ 专业日志系统 - 分级日志和调试信息
    """

    def initialize(self):
        """策略初始化，仅在启动时运行一次"""
        print("🚀 开始初始化滚轮期权策略 v2.0.0...")
        self.trigger_symbols()
        self.custom_indicator()  # 框架要求
        self.global_variables()
        self.state_variables()
        self._validate_parameters()
        print("✅ 滚轮期权策略初始化完成！")

    def trigger_symbols(self):
        """设置交易标的"""
        self.underlying_stock = declare_trig_symbol()

    def custom_indicator(self):
        """注册自定义指标（框架要求）"""
        pass

    def global_variables(self):
        """定义全局变量和用户可调参数"""
        
        # ========== 核心控制参数 ==========
        self.dry_run_mode = show_variable(True, GlobalType.BOOL, "模拟运行模式(开发测试必须开启)")
        self.verbose_logging = show_variable(True, GlobalType.BOOL, "详细日志模式")
        
        # ========== Delta目标配置(符合设计文档) ==========
        self.target_delta_put = show_variable(-0.30, GlobalType.FLOAT, "PUT期权Delta目标(推荐-0.30)")
        self.target_delta_call = show_variable(0.30, GlobalType.FLOAT, "CALL期权Delta目标(推荐+0.30)")
        self.delta_tolerance = show_variable(0.1, GlobalType.FLOAT, "Delta容差范围")
        
        # ========== 到期日配置 ==========
        self.dte_min = show_variable(30, GlobalType.INT, "最小到期天数")
        self.dte_max = show_variable(45, GlobalType.INT, "最大到期天数")
        
        # ========== 交易规模配置 ==========
        self.contracts_to_trade = show_variable(1, GlobalType.INT, "每次交易的合约数量")
        
        # ========== 盈利管理配置 ==========
        self.profit_target_pct = show_variable(0.5, GlobalType.FLOAT, "提前平仓的盈利目标(0.5=50%)")
        
        # ========== 时间控制配置 ==========
        self.trade_interval_min = show_variable(60, GlobalType.INT, "策略检查间隔(分钟)")
        
        # ========== 风险控制配置 ==========
        self.min_cash_buffer_pct = show_variable(0.1, GlobalType.FLOAT, "最小资金缓冲比例(10%)")
        self.max_position_value_pct = show_variable(0.3, GlobalType.FLOAT, "单个仓位最大占比(30%)")

    def state_variables(self):
        """定义策略运行状态变量"""
        # 时间控制
        self.last_check_time = None
        
        # 期权合约状态追踪
        self.active_option_contract = None
        self.option_entry_price = None
        self.option_entry_time = None
        self.option_type_active = None  # 'PUT' 或 'CALL'
        
        # 策略状态管理
        self.STRATEGY_STATE = {
            'SELLING_PUTS': 'SELLING_PUTS',
            'SELLING_CALLS': 'SELLING_CALLS',
            'MONITORING': 'MONITORING'
        }
        self.current_state = self.STRATEGY_STATE['SELLING_PUTS']
        
        # 交易统计
        self.total_premium_collected = 0.0
        self.trade_count = 0
        self.winning_trades = 0
        self.total_profit = 0.0

    def handle_data(self):
        """策略主循环"""
        try:
            # 频率控制检查
            current_time = device_time(TimeZone.DEVICE_TIME_ZONE)
            if not self._should_execute_check(current_time):
                return
            
            self.last_check_time = current_time
            self._log_strategy_header(current_time)
            
            # 获取市场数据
            market_data = self._get_market_data()
            if not market_data:
                print("❌ 无法获取市场数据，跳过本轮检查")
                return
            
            # 监控现有仓位
            self._monitor_existing_positions()
            
            # 执行主策略逻辑
            self._execute_wheel_strategy(market_data)
            
            # 打印策略统计
            if self.verbose_logging:
                self._print_strategy_stats()
                
        except Exception as e:
            print("❌ 策略执行错误: {}".format(str(e)))
            import traceback
            traceback.print_exc()

    # ========== 核心策略逻辑 ==========
    
    def _execute_wheel_strategy(self, market_data):
        """执行滚轮策略主逻辑"""
        stock_qty = market_data['stock_qty']
        required_shares = 100 * self.contracts_to_trade
        
        if stock_qty < required_shares:
            # 无足够持股 -> 进入卖PUT阶段
            self.current_state = self.STRATEGY_STATE['SELLING_PUTS']
            self._handle_sell_put_phase()
        else:
            # 有足够持股 -> 进入卖CALL阶段
            self.current_state = self.STRATEGY_STATE['SELLING_CALLS']
            self._handle_sell_call_phase()

    def _handle_sell_put_phase(self):
        """处理卖PUT阶段 - 现金担保看跌期权"""
        self._log_state_change('SELLING_PUTS')
        
        # 检查是否已有活跃仓位
        if self._has_active_option_position():
            return
            
        # 检查资金充足性
        if not self._check_cash_secured_put_funding():
            return
            
        # 筛选PUT期权合约
        target_put = self._screen_put_options()
        if not target_put:
            return
            
        # 执行卖PUT订单
        self._place_short_option_order(target_put, 'PUT')

    def _handle_sell_call_phase(self):
        """处理卖CALL阶段 - 备兑看涨期权"""
        self._log_state_change('SELLING_CALLS')
        
        # 检查是否已有活跃仓位
        if self._has_active_option_position():
            return
            
        # 检查股票持仓充足性
        if not self._check_covered_call_shares():
            return
            
        # 筛选CALL期权合约
        target_call = self._screen_call_options()
        if not target_call:
            return
            
        # 执行卖CALL订单
        self._place_short_option_order(target_call, 'CALL')

    # ========== 期权筛选和验证 ==========
    
    def _screen_put_options(self):
        """筛选PUT期权合约"""
        try:
            target_put = option_screener(
                underlying_symbol=self.underlying_stock,
                option_type=OptionType.PUT,
                moneyness=Moneyness.OTM,
                time_to_exp_start=self.dte_min,
                time_to_exp_end=self.dte_max
            )

            if target_put is None:
                print("❌ 未找到在{}-{}天内到期的合适PUT合约".format(self.dte_min, self.dte_max))
                return None

            # 获取期权详细信息
            actual_delta = option_delta(target_put)
            strike_price = option_strike_price(target_put) if not self.dry_run_mode else 95.0
            
            print("🎯 PUT候选: {} | Delta: {:.3f} | 行权价: ${:.2f}".format(
                target_put, actual_delta, strike_price))
            
            # Delta验证
            if abs(actual_delta - self.target_delta_put) > self.delta_tolerance:
                print("❌ Delta偏差过大: {:.3f} vs 目标{:.3f} (容差{:.3f})".format(
                    actual_delta, self.target_delta_put, self.delta_tolerance))
                return None

            return target_put
            
        except Exception as e:
            print("❌ PUT期权筛选失败: {}".format(str(e)))
            return None

    def _screen_call_options(self):
        """筛选CALL期权合约"""
        try:
            target_call = option_screener(
                underlying_symbol=self.underlying_stock,
                option_type=OptionType.CALL,
                moneyness=Moneyness.OTM,
                time_to_exp_start=self.dte_min,
                time_to_exp_end=self.dte_max
            )

            if target_call is None:
                print("❌ 未找到在{}-{}天内到期的合适CALL合约".format(self.dte_min, self.dte_max))
                return None

            # 获取期权详细信息
            actual_delta = option_delta(target_call)
            strike_price = option_strike_price(target_call) if not self.dry_run_mode else 105.0
            
            print("🎯 CALL候选: {} | Delta: {:.3f} | 行权价: ${:.2f}".format(
                target_call, actual_delta, strike_price))
            
            # Delta验证
            if abs(actual_delta - self.target_delta_call) > self.delta_tolerance:
                print("❌ Delta偏差过大: {:.3f} vs 目标{:.3f} (容差{:.3f})".format(
                    actual_delta, self.target_delta_call, self.delta_tolerance))
                return None

            return target_call
            
        except Exception as e:
            print("❌ CALL期权筛选失败: {}".format(str(e)))
            return None

    # ========== 资金和持股检查 ==========
    
    def _check_cash_secured_put_funding(self):
        """检查现金担保卖PUT所需资金"""
        try:
            if self.dry_run_mode:
                print("✅ [模拟] 资金检查通过")
                return True
                
            available_cash = available_fund()
            stock_price = current_price(self.underlying_stock)
            required_cash = stock_price * 100 * self.contracts_to_trade
            buffer_cash = required_cash * self.min_cash_buffer_pct
            
            if available_cash >= (required_cash + buffer_cash):
                print("✅ 资金检查: 可用${:,.0f} >= 需要${:,.0f} (含{:.0%}缓冲)".format(
                    available_cash, required_cash + buffer_cash, self.min_cash_buffer_pct))
                return True
            else:
                print("❌ 资金不足: 可用${:,.0f} < 需要${:,.0f}".format(
                    available_cash, required_cash + buffer_cash))
                return False
                
        except Exception as e:
            print("❌ 资金检查失败: {}".format(str(e)))
            return False

    def _check_covered_call_shares(self):
        """检查备兑卖CALL所需股票"""
        try:
            stock_qty = position_holding_qty(self.underlying_stock)
            required_shares = 100 * self.contracts_to_trade
            
            if stock_qty >= required_shares:
                print("✅ 股票检查: 持有{}股 >= 需要{}股".format(stock_qty, required_shares))
                return True
            else:
                print("❌ 股票不足: 持有{}股 < 需要{}股".format(stock_qty, required_shares))
                return False
                
        except Exception as e:
            print("❌ 股票检查失败: {}".format(str(e)))
            return False

    # ========== 订单执行 ==========
    
    def _place_short_option_order(self, option_contract, option_type):
        """执行卖出期权订单"""
        try:
            # 获取报价信息
            target_price = bid(option_contract, level=1) 
            if target_price is None or target_price <= 0:
                print("❌ 无法获取合约 {} 的有效报价".format(option_contract))
                return

            total_premium = target_price * 100 * self.contracts_to_trade
            
            print("💰 准备下单: 卖出{} {} @ ${:.2f}, 预期收入${:.2f}".format(
                self.contracts_to_trade, option_contract, target_price, total_premium))
            
            # Dry Run模式处理
            if self.dry_run_mode:
                self._handle_dry_run_order(option_contract, target_price, option_type, total_premium)
                return

            # 实盘下单
            order_id = place_limit(
                symbol=option_contract,
                price=target_price,
                qty=self.contracts_to_trade,
                side=OrderSide.SELL,
                time_in_force=TimeInForce.DAY
            )

            if order_id:
                self._handle_successful_order(option_contract, target_price, order_id, option_type, total_premium)
            else:
                print("❌ [实盘] 下单失败，未返回订单ID")

        except Exception as e:
            print("❌ 下单执行错误: {}".format(str(e)))
            if self.verbose_logging:
                import traceback
                traceback.print_exc()

    def _handle_dry_run_order(self, option_contract, target_price, option_type, total_premium):
        """处理模拟运行订单"""
        print("🌟 [模拟成交] 订单已模拟成交！")
        print("⚡ 若要实盘交易，请在参数中关闭dry_run_mode")
        
        # 记录模拟交易信息
        self.active_option_contract = option_contract
        self.option_entry_price = target_price
        self.option_entry_time = device_time(TimeZone.DEVICE_TIME_ZONE)
        self.option_type_active = option_type
        self.total_premium_collected += total_premium
        self.trade_count += 1
        
        if self.verbose_logging:
            print("📋 模拟交易记录:")
            print("   - 开仓时间: {}".format(self.option_entry_time.strftime("%Y-%m-%d %H:%M:%S")))
            print("   - 期权类型: {}".format(option_type))
            print("   - 累计权利金: ${:.2f}".format(self.total_premium_collected))
            print("   - 累计交易数: {}".format(self.trade_count))

    def _handle_successful_order(self, option_contract, target_price, order_id, option_type, total_premium):
        """处理成功下单"""
        print("✅ [实盘] 下单成功！")
        print("💰 合约: {} | 数量: {} | 价格: ${:.2f} | ID: {}".format(
            option_contract, self.contracts_to_trade, target_price, order_id))
        
        # 记录实盘交易信息
        self.active_option_contract = option_contract
        self.option_entry_price = target_price
        self.option_entry_time = device_time(TimeZone.DEVICE_TIME_ZONE)
        self.option_type_active = option_type
        self.total_premium_collected += total_premium
        self.trade_count += 1

    # ========== 仓位监控和管理 ==========
    
    def _has_active_option_position(self):
        """检查是否有活跃期权仓位"""
        if self.active_option_contract is not None:
            try:
                option_qty = position_holding_qty(self.active_option_contract)
                
                if option_qty < 0:  # 空头仓位存在
                    if self.verbose_logging:
                        print("🔄 活跃仓位: {} | 数量: {}".format(
                            self.active_option_contract, option_qty))
                    
                    # 检查是否达到盈利目标
                    if self._should_close_for_profit():
                        self._close_profitable_position()
                        return False
                    
                    return True
                else:  # 仓位已结束
                    if self.verbose_logging:
                        print("✅ 期权仓位已结束: {}".format(self.active_option_contract))
                    self._reset_option_tracking()
                    return False
                    
            except Exception as e:
                print("⚠️ 查询活跃期权仓位失败: {}。为安全起见，本轮跳过".format(str(e)))
                return True
                
        return False

    def _should_close_for_profit(self):
        """判断是否应该因盈利而平仓"""
        if not self.option_entry_price or self.dry_run_mode:
            # 模拟模式下简化盈利检查
            if self.dry_run_mode and self.option_entry_price:
                # 模拟50%盈利概率
                import random
                if random.random() < 0.1:  # 10%几率触发模拟平仓
                    print("🎰 [模拟] 随机触发盈利平仓检查")
                    return True
            return False
            
        try:
            current_option_price = current_price(self.active_option_contract)
            profit_pct = (self.option_entry_price - current_option_price) / self.option_entry_price
            
            if self.verbose_logging:
                profit_amount = profit_pct * self.option_entry_price * 100 * self.contracts_to_trade
                print("💹 盈利检查: 当前{:.1%}盈利 (${:.2f})".format(profit_pct, profit_amount))
            
            if profit_pct >= self.profit_target_pct:
                print("🎉 达到盈利目标: {:.1%} >= {:.1%}".format(profit_pct, self.profit_target_pct))
                return True
            
            return False
            
        except Exception as e:
            if self.verbose_logging:
                print("⚠️ 检查盈利目标失败: {}".format(str(e)))
            return False

    def _close_profitable_position(self):
        """平仓盈利仓位"""
        try:
            if self.dry_run_mode:
                profit_amount = self.option_entry_price * 100 * self.contracts_to_trade * self.profit_target_pct
                print("🌟 [模拟平仓] 盈利仓位已模拟平仓，模拟盈利${:.2f}".format(profit_amount))
                self.total_profit += profit_amount
                self.winning_trades += 1
                self._reset_option_tracking()
                return
                
            # 实盘平仓逻辑
            current_option_price = current_price(self.active_option_contract)
            
            order_id = place_limit(
                symbol=self.active_option_contract,
                price=current_option_price * 1.05,  # 稍高于市价确保成交
                qty=self.contracts_to_trade,
                side=OrderSide.BUY,  # 买入平仓
                time_in_force=TimeInForce.DAY
            )
            
            if order_id:
                profit = (self.option_entry_price - current_option_price) * 100 * self.contracts_to_trade
                print("✅ [实盘平仓] 盈利平仓成功! 盈利: ${:.2f}, 订单ID: {}".format(profit, order_id))
                self.total_profit += profit
                self.winning_trades += 1
                self._reset_option_tracking()
            else:
                print("❌ [实盘平仓] 平仓下单失败")
                
        except Exception as e:
            print("❌ 平仓操作失败: {}".format(str(e)))

    def _reset_option_tracking(self):
        """重置期权追踪信息"""
        self.active_option_contract = None
        self.option_entry_price = None
        self.option_entry_time = None
        self.option_type_active = None

    # ========== 辅助功能方法 ==========
    
    def _should_execute_check(self, current_time):
        """检查是否应该执行策略检查"""
        if self.last_check_time is not None:
            elapsed_minutes = (current_time - self.last_check_time).total_seconds() / 60
            if elapsed_minutes < self.trade_interval_min:
                if self.verbose_logging:
                    print("🕰️ 距离上次检查仅{:.1f}分钟，未达到{}分钟间隔要求".format(
                        elapsed_minutes, self.trade_interval_min))
                return False
        return True

    def _log_strategy_header(self, current_time):
        """输出策略检查开始日志"""
        print("\n" + "="*70)
        print("🎰 [{}] 滚轮期权策略检查 v2.0.0".format(
            current_time.strftime("%Y-%m-%d %H:%M:%S")))
        if self.dry_run_mode:
            print("🌟 [模拟模式] 当前为调试模式，不会执行真实交易")
        print("="*70)

    def _get_market_data(self):
        """获取市场数据"""
        try:
            stock_qty = position_holding_qty(self.underlying_stock)
            current_stock_price = current_price(self.underlying_stock) if not self.dry_run_mode else 100.0
            available_cash = available_fund() if not self.dry_run_mode else 10000.0
            
            market_data = {
                'stock_qty': stock_qty,
                'stock_price': current_stock_price,
                'available_cash': available_cash
            }
            
            print("📊 市场数据: 持股{}股 | 股价${:.2f} | 可用资金${:,.0f}".format(
                stock_qty, current_stock_price, available_cash))
            
            return market_data
            
        except Exception as e:
            print("❌ 获取市场数据失败: {}".format(str(e)))
            return None

    def _monitor_existing_positions(self):
        """监控现有仓位"""
        if self.active_option_contract:
            try:
                option_qty = position_holding_qty(self.active_option_contract)
                if option_qty != 0 and not self.dry_run_mode:
                    current_option_price = current_price(self.active_option_contract)
                    if self.option_entry_price:
                        pnl = (self.option_entry_price - current_option_price) * 100 * abs(option_qty)
                        pnl_pct = (self.option_entry_price - current_option_price) / self.option_entry_price * 100
                        print("💹 仓位状态: {} | P&L: ${:.2f} ({:.1f}%)".format(
                            self.active_option_contract, pnl, pnl_pct))
            except Exception as e:
                if self.verbose_logging:
                    print("⚠️ 监控仓位失败: {}".format(str(e)))

    def _log_state_change(self, new_state):
        """记录状态切换"""
        state_messages = {
            'SELLING_PUTS': '🔴 [卖PUT阶段] 无持股，等待现金担保卖PUT机会',
            'SELLING_CALLS': '🟢 [卖CALL阶段] 持有股票，等待备兑卖CALL机会'
        }
        if new_state in state_messages:
            print(state_messages[new_state])

    def _print_strategy_stats(self):
        """打印策略统计信息"""
        win_rate = (self.winning_trades / self.trade_count * 100) if self.trade_count > 0 else 0
        avg_premium = (self.total_premium_collected / self.trade_count) if self.trade_count > 0 else 0
        
        print("\n📊 策略统计:")
        print("💰 累计权利金收入: ${:.2f}".format(self.total_premium_collected))
        print("💵 累计实现利润: ${:.2f}".format(self.total_profit))
        print("🔢 累计交易次数: {} (胜率: {:.1f}%)".format(self.trade_count, win_rate))
        print("📈 平均权利金: ${:.2f}".format(avg_premium))
        print("🎯 当前状态: {}".format(self.current_state))
        if self.active_option_contract:
            print("🔄 活跃合约: {} ({})".format(
                self.active_option_contract, self.option_type_active))

    def _validate_parameters(self):
        """验证参数设置"""
        errors = []
        
        # Delta目标验证
        if self.target_delta_put > -0.1 or self.target_delta_put < -0.5:
            errors.append("PUT Delta目标应在-0.1到-0.5之间")
            
        if self.target_delta_call < 0.1 or self.target_delta_call > 0.5:
            errors.append("CALL Delta目标应在0.1到0.5之间")
            
        # 到期日验证
        if self.dte_min < 7 or self.dte_max > 90:
            errors.append("到期日范围应在7-90天之间")
            
        # 合约数量验证
        if self.contracts_to_trade < 1 or self.contracts_to_trade > 10:
            errors.append("合约数量应在1-10之间")
        
        if errors:
            print("⚠️ 参数验证警告:")
            for error in errors:
                print("   - {}".format(error))
        else:
            print("✅ 参数验证通过")